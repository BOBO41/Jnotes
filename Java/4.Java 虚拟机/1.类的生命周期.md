---
title : 1.类的生命周期
categories : 
- JavaSE
- ch4类与对象的生命周期
date : 2018-10-29
---

# 类的生命周期

一个类从被加载、连接和初始化开始，到被使用，最后被卸载，这整个过程称为类的生命周期。

## 1.类加载机制

类加载机制：通过给定的全限定类名把描述该类的二进制字节流加载进内存，然后通过一系列处理，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。

类加载的全过程由加载、连接、初始化三部分所组成。其中连接又由验证、准备、解析三部分组成。

**注意：这些过程不是按部就班的执行的，有可能在执行一个过程的途中，执行另一个过程。**

![1540873591543](https://github.com/huangdaren1997/pictures/blob/master/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%9E%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96.png?raw=true)

### 1.1加载

**注意：加载是类加载过程的一个阶段，别混淆了。**

加载（Loading）是一个过程，通过类的全限定名来获取该类或接口的二进制表示，然后根据该二进制表示创建类或接口。

在加载阶段，虚拟机需要完成以下三个任务：

- 通过类的全限定名来获取定义此类的二进制字节流。

- 把类的数据结构存放在方法区中

- 在内存里创建一个`java.lang.Class`对象，作为在方法区中的这个类的各种数据结构的访问入口。

    （一般来说对象都是存放在Java堆里面，但是Class对象有点特殊，有些虚拟机的实现会把它放到方法区中）

![1540878379661](https://github.com/huangdaren1997/pictures/blob/master/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD.png?raw=true)

**注意：加载阶段和连接阶段的部分内容其实是交叉进行的，例如一部分字节码文件格式的验证。**

Java虚拟机能够从多种来源加载类的二进制数据

- 从本地文件系统加载类的.class文件
- 通过网络下载类的.class文件
- 从ZIP、JAR或其他归档文件中提取.class文件
- 从一个专有数据库中提取.class文件
- 把一个java源文件动态编译为.class文件

### 1.2连接

#### 1.2.1类的验证

验证的目的是确保Class文件的字节流中信息符合虚拟机的要求,不会危害虚拟机安全.

大致完成以下四个校验动作:

- 文件格式验证
- 源数据验证
- 字节码验证
- 符号引用验证

#### 1.2.2类的准备

在方法区中为类变量分配内存，并设置默认初始值；

```java
public static int value = 123；
// 这时候value的值为0，类初始化以后value才为123
public static final int value = 123；
// 被final修饰的类变量会在准备阶段进行正确的赋值，所以这里的value是123
```

#### 1.2.3类的解析

解析阶段是虚拟机把常量池内的符号引用替换为直接引用的过程。

**符号引用**：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。

```java
public void gotoWrok(){
    car.run(); // 这个car.run()就是符号引用，在解析阶段，会被替换成这个方法在内存位置的指针。
}
```

### 1.3初始化

在初始化阶段才是真正开始执行类中定义的Java程序代码（或者说是字节码）。

在初始化阶段，Java虚拟机执行类的初始化语句，为类的静态变量赋予初始值。

#### 1.3.1类的初始化时机

前面讲过，Java虚拟机只有在程序首次主动使用一个类或接口时才会初始化它，下面行为属于主动使用

- 创建类的实例，例如new、反射、克隆、反序列化
- 调用类的静态方法
- 访问或操作某个类或接口的静态变量
- 启动Java虚拟机时，指定运行的类 例如 `java Sample`

**注意**

对于final类型的静态变量，如果在编译时就能计算出变量的取值，那么这个变量会被看做是编译时常量，访问它不会导致类的初始化。

## 2.类加载器

**作用**：通过一个类的全限定名来获取描述此类的二进制字节流。

**分类**：

- Java虚拟机自带的类加载器
    - 启动类加载器：负责加载核心类库，例如java.lang.*等
    - 扩展类加载器：它从JDK的安装目录的jre\lib\ext子目录和java.ext.dirs系统属性所指定的目录下加载类库。它是java.lang.ClassLoader类的子类。
    - 应用程序类加载器：它从classpath环境变量或者系统属性java.class.path所指定的目录中加载类。是ClassLoader中的getSystemClassLoader方法的返回值。
- 用户自定义的类加载器

注意：类加载器可以在预料某个类将要被使用时就预先加载它，如果在预先加载过程，遇到.class文件缺失或存在错误，类加载器必须等到程序首次主动使用该类时才报告错误。如果该类没有被程序主动使用，则不报错。

### 2.1类加载器的双亲委派模型

​	类的加载过程采用双亲委派模型，双亲委派模型是一种组织类加载器之间关系的一种规范,他的工作原理是:如果一个类加载器收到了加载类的请求,它首先会把这个请求委派给父加载器去完成,层层递进,最终所有的加载请求都被传到最顶层的启动类加载器中,只有当父类加载器无法完成这个加载请求(它的搜索范围内没有找到所需的类)时,才会交给子类加载器去尝试加载.

双亲委派模型的作用：可以避免类的重复加载，当父亲已经加载了该类时，子类就不用加载了。其次是考虑到安全因素，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器早就加载了这个类，这样便可以防止核心类库被随意篡改。

### 2.2loadClass

ClassLoader类的loadClass方法是内加载的重中之重，现在让我们来了解一下它的源码

```java
protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name)) {
            // 使用一个native方法查看是否已经加载过该类
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    //父类不为空则先让父类加载
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                    //父类是null就是BootstrapClassLoader，使用启动类类加载器加载
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // 非null父类加载器无法找到该类时，抛出该异常
                }

                //如果父类未加载该类
                if (c == null) {
                    // If still not found, then invoke findClass in order
                    // to find the class.
                    long t1 = System.nanoTime();
                    //让当前类加载器加载
                    c = findClass(name);
                }
            }
            return c;
        }
    }
```

总体而言，loadClass方法就是接收一个全限定类名，然后判断该类是否已经被加载，如果没有则调用父类加载器加载这个类，如果父类加载器无法加载这个类，这调用自身的findClass方法来加载该类

### 2.3自定义类加载器

要创建自己的类加载器，只需要继承`java.lang.ClassLoader`类，重写`findClass`方法即可。

```java
protected Class<?> findClass(String name) throws ClassNotFoundException {
    throw new ClassNotFoundException(name);
}
```

```java
public class MyClassLoader extends ClassLoader {

   private String classPath;

   public MyClassLoader(String classPath) {
      this.classPath = classPath;
   }

   /**
    * 根据全限定类名，获取类的二进制字节流
    *
    * @param name 全限定类名
    * @return 描述次类的二进制字节流
    */
   private byte[] getClassByte(String name) {
      String className = name.substring(name.lastIndexOf(".") + 1);
      try {
         FileInputStream fis = new FileInputStream(classPath + className);
         byte[] bytes = new byte[1024];
         ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
         while (fis.read(bytes) > 0) {
            byteArrayOutputStream.write(bytes);
         }
         return byteArrayOutputStream.toByteArray();
      } catch (IOException e) {
         e.printStackTrace();
      }
      return new byte[]{};
   }
	 /**
    * 重写findClass方法
    * @param name 全限定类名
    * @return 代表该类的Class对象
    */
   @Override
   protected Class<?> findClass(String name) throws ClassNotFoundException {
      byte[] classByte = getClassByte(name);
      return defineClass(name, classByte, 0, classByte.length);
   }
  
  public static void main(String[] args) {
		String classPath = MyClassLoader.class.getResource("").getPath();
		try {
			Person p = ((Person) (new MyClassLoader(classPath)
                            .loadClass("com.hdr.learn.Person").newInstance()));
			p.sayHi();
		} catch (InstantiationException | IllegalAccessException | ClassNotFoundException e) {
			e.printStackTrace();
	}
	
  
}
```

### 2.4Class.forname()与ClassLoader.loadClass()

Class.forname():是一个静态方法,最常用的是Class.forname(String className);根据传入的类的全限定名返回一个Class对象.该方法在将Class文件加载到内存的同时,会执行类的初始化.

ClassLoader.loadClass():这是一个实例方法,需要一个ClassLoader对象来调用该方法,该方法将Class文件加载到内存时,并不会执行类的初始化,直到这个类第一次使用时才进行初始化.该方法因为需要得到一个ClassLoader对象,所以可以根据需要指定使用哪个类加载器.

## 3.类的卸载

Java虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载。也就是用户自定义的类加载器所加载的类才会被卸载



