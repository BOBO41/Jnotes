# 对象的生命周期

对象的生命周期就是对象从创建到销毁这一个过程。

## 1.对象的创建方式与过程

**1.1有4种显式地创建对象的方式：**

- new
- 反射
- 对象的clone方法
- 反序列化手段

**1.2对象的创建过程**

1. 给对象分配内存
2. 将对象的实例变量自动初始化为其变量类型的默认值
3. 初始化对象，主要负责给实例变量赋予正确的初始值

对于第3步，不同方法创建对象其初始化不一样

- clone方法创建的，那就把被克隆对象的实例变量的值复制到新对象中
- 如果对象是通过反序列化方式创建了，那就从输入流中读入数据来初始化

## 2.对象的销毁：垃圾回收

当对象被创建后，就会在Java虚拟机的堆区中拥有一块内存，如果对象没用了，那么就Java虚拟机的垃圾回收器就会回收对象。

### 2.1对象的触及状性

- 可触及状态：对象被创建后，有引用变量引用它。
- 可复活状态：对象没有被任何引用变量引用。在这个状态下，垃圾回收器会准备释放它占用的内存，在释放之前会调用它及其其它该状态下的对象的`finalize`方法，这些方法有可能使对象转为可触及状态。
- 不可触及状态：对象执行了`finalize`方法后没有恢复成可触及状态，就会变成不可触及状态，这时候垃圾回收器才会真正的收回它占用的内存。

### 2.2finalize方法

`finalize`方法定义在Object类

```java
protected void finalize() throws Throwable { }
```

## 3.深入垃圾回收

### 3.1无用对象的判定

**引用计数算法**

给对象添加一个引用计数器，每当有一个地方引用它，引用次数加1。

缺点：难以解决循环引用问题。

**可达性分析算法**

通过一系列称为`GC Roots`的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到`GC Roots`之间没有那么的引用链，则说明该对象不可用。

**关于GC Root** ：目前还迷迷糊糊。。。

### 3.2垃圾收集算法

#### 3.2.1标记-清除算法

**Mark and Sweep** ：标记出需要回收的对象，然后统一回收所有被标记的对象。

![Java GC sweep](../images/GC-mark-sweep.png)

缺点：对象清除后产生大量不连续的内存碎片，还需要额外记录空闲内存的位置和大小。

#### 3.2.2标记-清除-整理算法

**Mark-Sweep-Compact** 

![Java GC sweep](../images/GC-mark-sweep-compact.png)

添加了一个compact操作，把存活对象移动到the beginning of the memory region。

缺点：we need to copy all objects to a new place and to update all references to such objects.

#### 3.2.3标记-复制算法

**Mark and Copy** ：把内存分为两部分，当其中一块内存用完，就把该内存中存活的对象复制到另一块内存中。

![Java GC Mark and Copy Collector](../images/GC-mark-and-copy-in-Java.png)

优点：移动和标记可以同时进行

缺点： need for one more memory region, which should be large enough to accommodate survived objects.

#### 3.2.4分代收集算法

原理：根据对象存活周期的不同将内存划分为几块。一般分为新生代和老年代，然后根据各个年代的特点采用合适的收集算法。新生代朝生夕死，所以采用复制算法，老年代则采用标记-整理算法。

关于新生代、老年代请看[新生代、老年代](https://www.cnblogs.com/snowwhite/p/9532311.html)。

Minor GC 新生代 、Major GC 老年代、Full GC 新老年代。

### 3.3垃圾收集器

如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。

垃圾收集器有很多种，有的作用于新生代，有的作用于老年代，有的老少通吃。

| 新生代                | 老年代             | **JVM options**             |
| :-------------------- | :----------------- | :-------------------------- |
| Incremental           | Incremental        | -Xincgc                     |
| **Serial**            | **Serial Old**     | **-XX:+UseSerialGC**        |
| Parallel Scavenge     | Serial Old         | -XX:+UseParallelOldGC       |
| Parallel New          | Serial Old         | -XX:+UseParNewGC            |
| Serial                | Parallel Old       | N/A                         |
| **Parallel Scavenge** | **Parallel Old**   | **-XX:+UseParallelGC **     |
| Parallel New          | Parallel Old       | N/A                         |
| Serial                | CMS                |                             |
| Parallel Scavenge     | CMS                | N/A                         |
| **Parallel New**      | **CMS+Serial Old** | **-XX:+UseConcMarkSweepGC** |
| **G1**                | **G1**             | **-XX:+UseG1GC**            |

看上去好像很多选择，但我们只需要记住加粗的就可以了，总结起来就是

- Serial GC for both the Young and Old generations
- Parallel GC for both the Young and Old generations
- Parallel New for Young CMS+Serial  Old for the Old Generation
- G1

#### 术语

在讲垃圾收集器之前，需要先了解三个术语，分别是**stop the world**、**并发**、**并行**

**stop the world** 指的就是垃圾回收时，应用线程会被暂停

在垃圾收集器中，并发和并行的意思跟我们平时了解的有点不一样，在垃圾收集器中，**并行**指的是，垃圾回收是通过多个线程来完成的，**并发**指的是，垃圾回收线程与应用线程同时运行。

一个垃圾收集器可以用以上3个术语进行组合描述，例如一个并行并发收集器，讲的就是一个收集器，利用多线程进行垃圾回收，在回收时不需要暂停应用线程。

#### Serial ＧＣ

分代的单线程收集器，新生代使用标记－复制，老年代使用标记－清除－整理。

它在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集完成。

```java
//启动命令 
java -XX:+UseSerialGC -jar Application.java
```

**使用场景：**单核ＣＰＵ、堆内存１００Ｍ左右。

```java
// 建议自己写个程序使用该垃圾收集器跑一下，然后看看ＧＣ日志
-XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps
```

画风大概是这样的（我用的不是Ｓｅｒｉａｌ　ＧＣ）

```java
// 这是Ｍｉｎｏｒ　ＧＣ的信息
2019-04-02T16:15:38.604+0800: 664.824: [GC (Allocation Failure) [PSYoungGen: 13728K->6295K(22016K)] 52479K->51710K(72704K), 0.0118202 secs] [Times: user=0.03 sys=0.00, real=0.02 secs] 
// ------------------------------------------------------------
2019-04-02T16:15:38.604+0800:　　ＧＣ开始时间
664.824:   这次ＧＣ的开始时间距离ＪＶＭ开始运行有６６４．８２４秒
ＧＣ　ＧＣ的类型，这是一次Ｍｉｎｏｒ　ＧＣ
(Allocation Failure)　产生这次ＧＣ的原因，这次是因为新生代不够内存了
PSYoungGen：垃圾收集器的名称
13728K->6295K　垃圾回收前后新生代已用内存
(22016K)　新生代内存有多大
52479K->51710K　垃圾回收前后整个堆已用的内存
(72704K)　整个堆内存有多大
0.0118202 secs　ＧＣ事件持续的时间
[Times: user=0.03 sys=0.00, real=0.02 secs]　从不同的角度对这次ＧＣ进行评估
user　在这次垃圾回收中，垃圾回收线程占用了ＣＰＵ多少时间
ｓｙｓ　Time spent in OS calls or waiting for system event
real　Clock time for which your application was stopped. With Parallel GC this number should be close to (user time + system time) divided by the number of threads used by Garbage Collector.
```

```java
// 这是Ｆｕｌｌ　ＧＣ　自己分析一下
2019-04-02T16:15:38.616+0800: 664.836: [Full GC (Ergonomics) [PSYoungGen: 6295K->0K(22016K)] [ParOldGen: 45414K->23700K(56832K)] 51710K->23700K(78848K), [Metaspace: 12390K->12390K(1060864K)], 0.0142322 secs] [Times: user=0.06 sys=0.00, real=0.01 secs] 
```

进阶 [Serial Garbage Collector](https://www.infoq.com/presentations/JVM-Performance-Tuning-twitter-QCon-London-2012)



#### Parallel GＣ

分代的多线程的垃圾收集器，新生代使用标记－复制，老年代使用标记－清除－整理。同样会｀ＳＴＯＰ　ＴＨＥ　ＷＯＲＬＤ｀。

并行收集器有时候也被叫吞吐量收集器，所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即 吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）。

| 新生代                | 老年代             | **JVM options**             |
| :-------------------- | :----------------- | :-------------------------- |
| Parallel Scavenge     | Serial Old         | -XX:+UseParallelOldGC       |
| Parallel New          | Serial Old         | -XX:+UseParNewGC            |
| **Parallel Scavenge** | **Parallel Old**   | **-XX:+UseParallelGC **     |
| **Parallel New**      | **CMS+Serial Old** | **-XX:+UseConcMarkSweepGC** |

在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenger 加 Parallel Old收集器。

#### The Mostly Concurrent Collectors

顾名思义，这种收集器在垃圾回收的部分时期，是并发的。这种收集器有两个，分别是CMS和G1。

**CMS，Concurrent Mark Sweep**

一种以获取最短回收停顿时间为目标的收集器。这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾回收线程和用户线程同时工作，在JDK9以后被废弃了，推荐使用G1收集器。

```java
java -XX:+UseConcMarkSweepGC com.mypackages.MyExecutableClass
```

[Concurrent Mark and Sweep](https://plumbr.io/handbook/garbage-collection-algorithms-implementations#concurrent-mark-and-sweep)

## G1收集器





优点：

- 并行与并发
    利用多CPU来缩短停顿时间，可以通过并发的方式让Java程序继续执行。
- 分代收集
- 空间整理 （标记整理算法，复制算法）
- 可预测的停顿（G1处处理追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒）



#### 3.3.8垃圾收集器参数总结

并行收集器的常用参数

- `-XX:ParallelGCThreads=<N>`

  执行垃圾回收的线程数为N

- `-XX:MaxGCPauseMillis=<N>` 

  通过牺牲吞吐量和降低新生代空间来控制最大垃圾收集停顿时间

- `-XX:GCTimeRatio=<N>`

  设置吞吐量大小，参数值应该是一个0到100的整数，代表垃圾回收时间占总时间的百分比

- `-Xmx<N>`

  最大堆内存为N

- `-Xms<N>`

  初始堆内存为N

- `-XX:+UseAdaptiveSizePolicy=`

  一个开关参数，当这个参数打开后，就不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数，只需要把基本的内存数据设置好（如-Xmx设置最大堆），然后使用MaxGVPauseMillis参数或GCTimeRation参数给虚拟机设立一个优化目标。

> If more than 98% of the total time is spent in garbage collection and less than 2% of the heap is recovered, then an `OutOfMemoryError`, is thrown. This feature is designed to prevent applications from running for an extended period of time while making little or no progress because the heap is too small. If necessary, this feature can be disabled by adding the option `-XX:-UseGCOverheadLimit` to the command line.



#### 3.3.9总结：

新生代收集器：Serial、ParNew、Parallel Scavenge

老年代收集器：Serial Old、Parallel Old、CMS

### 3.4内存分配与回收策略

**对象优先分配到Eden区**

大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。

**大对象直接进入老年区**

**长期存活的对象将进入老年代**

**动态对象年龄判定**

如果幸存区中相同年龄的所有对象的大小总和大于幸存区空间的一半，大于等于该年龄的对象就可以直接进入老年代。

**空间分配担保**



－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－

**废弃**

ＣＭＳ

目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务器的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。

CMS收集器的运作过程相对前面几种收集器来说更复杂一些，整个过程分为4个步骤：

1. 初始标记：标记一下GCRoot能直接关联到的对象
2. 并发标记：GCRoot Tracing
3. 重新标记：
4. 并发清除：

其中，初始标记、重新标记这两个步骤仍然需要“Stop The World”.

**优点**：并发收集，低停顿。

**缺点**：

（1）CMS收集器对CPU资源非常敏感。CPU个数少于4个时，CMS对于用户程序的影响就可能变得很大，为了应付这种情况，虚拟机提供了一种称为“增量式并发收集器”的CMS收集器变种。所做的事情和单CPU年代PC机操作系统使用抢占式来模拟多任务机制的思想

（2）CMS收集器无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。

​	浮动垃圾：CMS运行的时候，用户线程还在继续工作，会产生一些没有被标记的垃圾，这些垃圾只有在下一次GC时再清掉。

（3）CMS是基于“标记-清除”算法实现的收集器，收集结束时会有大量空间碎片产生。空间碎片过多，可能会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发FullGC。为了解决这个问题，CMS收集器提供了一个-XX:+UseCMSCompactAtFullCollection开关参数（默认就是开启的），用于在CMS收集器顶不住要进行FullGC时开启内存碎片合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间变长了。虚拟机设计者还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction,这个参数是用于设置执行多少次不压缩的Full GC后，跟着来一次带压缩的（默认值为0，标识每次进入Full GC时都进行碎片整理）

> If more than 98% of the total time is spent in garbage collection and less than 2% of the heap is recovered, then an `OutOfMemoryError`, is thrown. This feature is designed to prevent applications from running for an extended period of time while making little or no progress because the heap is too small. If necessary, this feature can be disabled by adding the option `-XX:-UseGCOverheadLimit` to the command line.

