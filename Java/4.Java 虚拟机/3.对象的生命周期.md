---
title : 3.对象的生命周期
categories : 
- JavaSE
- ch4类与对象的生命周期
date : 2018-10-31
---

# 对象的生命周期

对象的生命周期就是对象从创建到销毁这一个过程。

## 1.对象的创建方式与过程

**1.1有4种显式地创建对象的方式：**

- new
- 反射
- 对象的clone方法
- 反序列化手段

**1.2对象的创建过程**

1. 给对象分配内存
2. 将对象的实例变量自动初始化为其变量类型的默认值
3. 初始化对象，主要负责给实例变量赋予正确的初始值

对于第3步，不同方法创建对象其初始化不一样

- clone方法创建的，那就把被克隆对象的实例变量的值复制到新对象中
- 如果对象是通过反序列化方式创建了，那就从输入流中读入数据来初始化

## 2.对象的销毁：垃圾回收

当对象被创建后，就会在Java虚拟机的堆区中拥有一块内存，如果对象没用了，那么就Java虚拟机的垃圾回收器就会回收对象。

### 2.1对象的触及状性

- 可触及状态：对象被创建后，有引用变量引用它。
- 可复活状态：对象没有被任何引用变量引用。在这个状态下，垃圾回收器会准备释放它占用的内存，在释放之前会调用它及其其它该状态下的对象的`finalize`方法，这些方法有可能使对象转为可触及状态。
- 不可触及状态：对象执行了`finalize`方法后没有恢复成可触及状态，就会变成不可触及状态，这时候垃圾回收器才会真正的收回它占用的内存。

### 2.2finalize方法

`finalize`方法定义在Object类

```java
protected void finalize() throws Throwable { }
```

## 3.深入垃圾回收

### 3.1无用对象的判定

**引用计数算法**

给对象添加一个引用计数器，每当有一个地方引用它，引用次数加1。

缺点：难以解决相互循环引用问题。

**可达性分析算法**

通过一系列称为`GC Roots`的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到`GC Roots`之间没有那么的引用链，则说明该对象不可用。

**关于GC Root**：GC Root不是垃圾回收目标区域的对象，譬如你要回收年轻代，那年老代必然是Root之一。

### 3.2垃圾收集算法

#### 3.2.1标记-清除算法

原理：标记出需要回收的对象，然后统一回收所有被标记的对象。

缺点：效率不高、而且清除后产生大量不连续的内存碎片。

#### 3.2.2复制算法

原理：把内存分为两部分，当其中一块内存用完，就把该内存中存活的对象复制到另一块内存中。

#### 3.2.3标记-整理-清除算法

原理：标记出需要回收的对象，让所有存活的对象往一端移动，然后直接清除掉端边界以外的内存。

#### 3.2.4分代收集算法

原理：根据对象存活周期的不同将内存划分为几块。一般分为新生代和老年代，然后根据各个年代的特点采用合适的收集算法。新生代死得快，所以采用复制算法，老年代则采用标记-整理算法。

关于新生代、老年代请看[新生代、老年代、永久代](https://www.cnblogs.com/snowwhite/p/9532311.html)。

### 3.3垃圾收集器

如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。

下面以JDK1.7Update14之后的HostSpot虚拟机为例，讲解这个虚拟机包含的收集器。

![]()

上图展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。

**并发与并行**

并发的关键是你有处理多个任务的能力，不一定要同时。
并行的关键是你有同时处理多个任务的能力。
它们最关键的点就是：是否是『同时』。

#### 3.3.1Serial收集器

Serial（串行）收集器是最基本、最古老的收集器。是单线程的收集器。它在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集完成。

**缺点：**需要暂停所有用户线程，用户体验不好。

**优点：**简单而高效（与其他垃圾收集器在单线程运行中比较）

Serial收集器对于运行在Client模式下的虚拟机来说是一个很好的选择。

#### 3.3.2ParNew收集器

ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集之外，其余行为都与Serial 收集器基本一样，在实现上两者也公用了相当多的代码。

ParNew收集器是许多运行在Server模式下的虚拟机中首选新生代收集器，其中有一个与性能无关但很重要的原因是，除Serial收集器之外，目前只有ParNew它能与CMS收集器配合工作。

#### 3.3.3CMS收集器

CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾回收线程和用户线程同时工作。

目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务器的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。

CMS收集器是基于“标记-清除”算法实现的。它的运作过程相对前面几种收集器来说更复杂一些，整个过程分为4个步骤：

1. 初始标记

    标记一下GCRoot能直接关联到的对象

2. 并发标记

    GCRoot Tracing

3. 重新标记

4. 并发清除

其中，初始标记、重新标记这两个步骤仍然需要“Stop The World”.

**优点**：并发收集，低停顿。

**缺点**：

（1）CMS收集器对CPU资源非常敏感。CPU个数少于4个时，CMS对于用户程序的影响就可能变得很大，为了应付这种情况，虚拟机提供了一种称为“增量式并发收集器”的CMS收集器变种。所做的事情和单CPU年代PC机操作系统使用抢占式来模拟多任务机制的思想

（2）CMS收集器无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。

​	浮动垃圾：CMS运行的时候，用户线程还在继续工作，会产生一些没有被标记的垃圾，这些垃圾只有在下一次GC时再清掉。

（3）CMS是基于“标记-清除”算法实现的收集器，收集结束时会有大量空间碎片产生。空间碎片过多，可能会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发FullGC。为了解决这个问题，CMS收集器提供了一个-XX:+UseCMSCompactAtFullCollection开关参数（默认就是开启的），用于在CMS收集器顶不住要进行FullGC时开启内存碎片合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间变长了。虚拟机设计者还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction,这个参数是用于设置执行多少次不压缩的Full GC后，跟着来一次带压缩的（默认值为0，标识每次进入Full GC时都进行碎片整理）

#### 3.3.4Parallel Scavenge收集器

Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器。该收集器的目标是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即 吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）。

停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可用高效率地利用CPU，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。

Parallel Scavenge收集器提供两个参数用于精确控制吞吐量

- 控制最大垃圾收集停顿时间的`-XX:MaxGCPauseMillis`参数

    通过牺牲吞吐量和降低新生代空间来降低垃圾回收的停顿时间

- 设置吞吐量大小的`-XX:GCTimeRatio`参数

    参数值应该是一个0到100的整数，代表垃圾回收时间占总时间的百分比。

Parallel Scavenge收集器还有一个参数：`-XX:+UseAdaptiveSizePolicy`。这是一个开关参数，当这个参数打开后，就不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数，只需要把基本的内存数据设置好（如-Xmx设置最大堆），然后使用MaxGVPauseMillis参数或GCTimeRation参数给虚拟机设立一个优化目标。

#### 3.3.5Serial Old 收集器

Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记整理算法。

这个收集器的主要意义也是在于给Client模式下的虚拟机使用。

如果在Server模式下，主要两大用途：

- 在JDK1.5以及之前的版本中与Parallel Scavenge收集器搭配使用
- 作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用

#### 3.3.6Parallel Old 收集器

Parallel Old 是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。这个收集器在1.6中才开始提供。

在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenger 加 Parallel Old收集器。

#### 3.3.7G1收集器

优点：

- 并行与并发
    利用多CPU来缩短停顿时间，可以通过并发的方式让Java程序继续执行。
- 分代收集
- 空间整理 （标记整理算法，复制算法）
- 可预测的停顿（G1处处理追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒）

#### 3.3.8垃圾收集器参数总结

#### 3.3.9总结：

新生代收集器：Serial、ParNew、Parallel Scavenge

老年代收集器：Serial Old、Parallel Old、CMS

### 3.4内存分配与回收策略

**对象优先分配到Eden区**

大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。

**大对象直接进入老年区**

**长期存活的对象将进入老年代**

**动态对象年龄判定**

如果幸存区中相同年龄的所有对象的大小总和大于幸存区空间的一般，大于等于该年龄的对象就可以直接进入老年代。

**空间分配担保**

