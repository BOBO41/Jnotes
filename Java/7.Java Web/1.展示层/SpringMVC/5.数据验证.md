# Data Validation

Data Validation 数据验证,在网络开发中,对用户提交的数据进行检验,是常见的需求.在本章中我们会讲解Java中常用的两种数据验证方式.

- Bean Validation
- Spring Validation

## Bean Validation

Bean Validation是一种规范,为验证JavaBean定义了相应的Annotation和API。

- 关于该规范的详细内容,可以上网查看JSR-303.
- **JSRs** Java Specification Requests Java 规范提案,它是一份文档,里面描述了添加到Java平台的建议规范和技术.

## Hibernate Validator

Hibernate Validator 是 Bean Validation 规范的实现. 

Hibernate Validator 提供了 JSR 303 规范中所有内置 constraint 的实现，除此之外还有一些附加的 constraint。

简而言之,Bean Validation是一种方案,Hibernate Validator则是该方案的实施者.



## Spring Validator

---

# Hibernate Validator

概括

- 了解Hibernate Validator 内置约束
- 学会单独使用Hibernate Validator
  - 使用内置的约束
  - 自定义约束

## Hibernate Validator 内置约束

约束(constraint)其实就是,规定某样东西必须符合某种要求.

由于Hibernate Validator是JSR303规范的实现库,也就是说Hibernate Validator 内置的约束,其实就是JSR303规定的约束.

### JSR303规定的约束

JSR303中定义了很多常用的约束注解，使用方法就是把约束注解添加到目标(字段 方法等等)上,然后通过验证器(validator)进行验证.下面是常见的约束.

**空检查** 
@Null 验证对象是否为null 
@NotNull 验证对象是否不为null, 无法查检长度为0的字符串 
@NotBlank 检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格. 
@NotEmpty 检查约束元素是否为NULL或者是EMPTY.

**Booelan检查** 
@AssertTrue 验证 Boolean 对象是否为 true 
@AssertFalse 验证 Boolean 对象是否为 false

**长度检查**
@Size(min=, max=) 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内 
@Length(min=, max=) 限制字符长度

**日期检查**
@Past 验证 Date 和 Calendar 对象是否在当前时间之前，验证成立的话被注释的元素一定是一个过去的日期 
@Future 验证 Date 和 Calendar 对象是否在当前时间之后 ，验证成立的话被注释的元素一定是一个将来的日期 

**正则表达式**
@Pattern 验证 String 对象是否符合正则表达式的规则，被注释的元素符合制定的正则表达式，regexp:正则表达式 flags: 指定 Pattern.Flag 的数组，表示正则表达式的相关选项。

**数值检查** 
建议使用在Stirng,Integer类型，不建议使用在int类型上，因为表单值为“”时无法转换为int,Integer则为null  
@Min 验证 Number 和 String 对象是否大等于指定的值  
@Max 验证 Number 和 String 对象是否小等于指定的值  
@DecimalMax 被标注的值必须不大于约束中指定的最大值. 这个约束的参数是一个通过BigDecimal定义的最大值的字符串表示.小数存在精度  
@DecimalMin 被标注的值必须不小于约束中指定的最小值. 这个约束的参数是一个通过BigDecimal定义的最小值的字符串表示.小数存在精度  
@Digits 验证 Number 和 String 的构成是否合法  
@Digits(integer=,fraction=) 验证字符串是否是符合指定格式的数字，interger指定整数精度，fraction指定小数精度。  
@Range(min=, max=) 被指定的元素必须在合适的范围内  
@Range(min=10000,max=50000,message=”range.bean.wage”)  
@Valid 递归的对关联对象进行校验, 如果关联对象是个集合或者数组,那么对其中的元素进行递归校验,如果是一个map,则对其中的值部分进行校验.(是否进行递归验证)  
@CreditCardNumber信用卡验证  
@Email 验证是否是邮件地址，如果为null,不进行验证，算通过验证。  
@ScriptAssert(lang= ,script=, alias=)  
@URL(protocol=,host=, port=,regexp=, flags=)  

### Hibernate Validator扩展的约束

Hibernate validator 在JSR303的基础上对校验注解进行了扩展，扩展注解如下：

 ![](https://github.com/huangdaren1997/Java/blob/master/JavaWeb/5.%E8%A1%A8%E7%A4%BA%E5%B1%82/SpringMVC/image/hibernate%20validator%20annotation.png?raw=true)



## 使用内置的约束

### 引入依赖

```xml
<dependency>
    <groupId>org.hibernate</groupId>
    <artifactId>hibernate-validator</artifactId>
    <version>5.2.4.Final</version>
    <scope>compile</scope>
</dependency>
```

### 使用约束

```java
public class Person {
    @NotNull
    @Pattern(regexp = "[0-9]{15}|[0-9]{18}" ,message = "身份证格式错误,必须是15或18位数字")
    private String id;
    
    @NotNull(message = "名字不能为空")
    private String name;
    // setter getter
}
```

### 验证

在上代码前,我们需要了解两个对象,分别是validator对象以及ConstraintViolation对象.

#### validator对象

`Validator`用于检验对象是否遵循其约束

```java
//获取Validator的实例
Validator validator = Validation.buildDefaultValidatorFactory().getValidator();
```

`Validator`中有三个方法能够用来校验整个实体对象或者实体对象中的属性. 这三个方法都会返回一个`Set<ConstraintViolation>`对象, 如果整个验证过程没有发现问题的话,那么这个set是空的, 否则, 每个违反约束的地方都会被包装成一个`ConstraintViolation`的实例然后添加到set当中. 

- validate(obj)
  - 使用`validate()`方法对一个给定的实体对象中定义的所有约束条件进行校验 
- validateProperty(obj,"propertyName")
  - 对一个给定实体对象的单个属性进行校验. 其中属性名称需要符合JavaBean规范中定义的属性名称 
- validateValue(Class,"propertyName",null)
  - 测试把一个特定的值赋给一个类的某一个属性,是否会违反此类中定义的约束条件. 

#### ConstraintViolation对象

ConstraintViolation对象包含了违反约束的相关信息.

- getMessage() 获取message
- getMessageTemplate() 获取信息模板
- getRootBean() 获取校验的对象
- getRootBeanClass() 获取校验的对象的类
- getLeafBean() 
  - 如果约束是添加在一个bean(实体对象)上的,那么则返回这个bean的实例
  - 如果是约束是定义在一个属性上的, 则返回这个属性所属的bean的实例对象
- getPropertyPath()  从被验证的根对象到被验证的属性的路径. 
- getConstraintDescriptor() 导致校验失败的约束定义 

```java
public class TestValidation {
    private static Validator validator = 
        Validation.buildDefaultValidatorFactory().getValidator();

    @Test
    public void personValidation(){
        Person person = new Person();
        person.setId("123456789012345");
        Set<ConstraintViolation<Person>> constraintViolations = validator.validate(person);
        for(ConstraintViolation<Person> cv:constraintViolations){
            System.out.println(cv.getMessage());
        }
    }
}
```



## 自定义约束

尽管Bean Validation API定义了一大堆标准的约束条件, 但是肯定还是有这些约束不能满足我们需求的时候, 在这种情况下, 你可以根据你的特定的校验需求来创建自己的约束条件. 

按照以下三个步骤来创建一个自定义的约束

- 创建约束注解
- 实现一个验证器

#### 创建约束注解

```java
@Target( { METHOD, FIELD, ANNOTATION_TYPE })
@Retention(RUNTIME) //注解信息是在运行期通过反射被读取的
@Constraint(validatedBy = IdValidator.class) //验证器
@Documented //对使用了@CheckCase的类进行javadoc操作到时候, 这个标注会被添加到javadoc当中
public @interface IdConstraint {
	//默认的消息模版, 当这个约束条件被验证失败的时候,通过此属性来输出错误信息
    String message() default "{身份证号有误,必须是15或18位数字}";
	//指定这个约束条件属于哪(些)个校验组
    Class<?>[] groups() default {};
	//使用者可以通过此属性来给约束条件指定严重级别
    Class<? extends Payload>[] payload() default {};
}
```

#### 验证器

```java
import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;

public class IdValidator implements ConstraintValidator<IdConstraint, String> {
   public void initialize(IdConstraint constraint) {
   }

   public boolean isValid(String id, ConstraintValidatorContext context) {
      return id.matches("[0-9]{15}|[0-9]{18}");
   }
}
```

#### 使用

```java
public class Person {

    @IdConstraint
    private String id;
	// getter setter
}
```

#### 测试

```java
public class TestValidation {
    private static Validator validator = 
        Validation.buildDefaultValidatorFactory().getValidator();

    @Test
    public void personValidation(){
        Person person = new Person();
        person.setId("123456");
        Set<ConstraintViolation<Person>> constraintViolations = 
            validator.validate(person);
        for(ConstraintViolation<Person> cv:constraintViolations){
            System.out.println(cv.getMessage());
        }
    }
    
}
```

**掌握了上面的知识就可以去看下一篇文章了.**

------

## Spring MVC整合Hibernate Validator

### 注册Validator

```xml
    <bean id="validator" class=
          "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean">
        <property name="providerClass" value=
                  "org.hibernate.validator.HibernateValidator"/>
    </bean>
    <mvc:annotation-driven validator="validator"/>
```

### 使用信息源

```xml
    <bean id="messageSource" class=
          "org.springframework.context.support.ResourceBundleMessageSource"> 
            <property name="basename" value="message"/>
    </bean>

   <bean id="validator" class=
         "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"> 
       <property name="providerClass" value="org.hibernate.validator.HibernateValidator"/> 
       <property name="validationMessageSource" ref="messageSource"/> 
   </bean>

    <mvc:annotation-driven validator="validator" />
```

### 国际化

```xml
<bean id="localeResolver" class=
      "org.springframework.web.servlet.i18n.SessionLocaleResolver">
    <property name="defaultLocale" value="en"/>
</bean>
```



## Hibernate Validator进阶

### 约束条件组合

有些时候一个属性可能会有多个约束注解,如果这个属性在多个地方出现,重复写这些注解就有违DRY原则了.

这是我们可以定义一个约束,然后在其中添加其他约束.

```java
@NotNull
@Size(min = 2, max = 14)
@CheckCase(CaseMode.UPPER)
@Target( { METHOD, FIELD, ANNOTATION_TYPE })
@Retention(RUNTIME)
@Constraint(validatedBy = {})
@Documented
public @interface ValidLicensePlate {

    String message() default ".......";

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};

}
```

---

# Spring Validation

在Bean Validation中,validator只需要进行验证,然后返回boolean类型的结果.

在Spring Validation中,validator使用Errors对象,由它来存放验证错误的信息.



## Validator接口

spring提供了一个Validator接口,通过实现Validator接口进行验证,Validator接口里面有一个Errors对象，该对象存放验证错误的信息.

看个例子

```java
public class Person {

    private String name;
    private int age;

    // the usual getters and setters...
}
```

接下来我们要为Person类提供数据验证的服务,通过实现 org.springframework.validation.Validator 接口的两个方法

- supports(Class)  此验证器可以验证提供的类的实例吗？
- validate(Object, org.springframework.validation.Errors) 对传入的对象进行验证,如果有错误则传递给Errors对象.

```java
public class PersonValidator implements Validator {

    public boolean supports(Class clazz) {
        return Person.class.equals(clazz);
    }

    public void validate(Object obj, Errors e) {
        Person p = (Person) o;
        String name = p.getName();
        int age = p.getAge();
        if(name==null) errors.rejectValue("name","name.empty");
        if(age<0||age>110) errors.rejectValue("age","请输入正确的年龄");
    }
}
```

## Errors接口

Errors接口的作用:存储和公开有关特定对象的数据绑定和验证错误的信息。

具体内容看API,注意看它的方法和实现类.

## 使用

```java
public class TestValidation {
    private static Validator validator = new PersonValidator();

    @Test
    public void personValidation(){
        Person person = new Person();
        person.setAge(-1);
        Errors errors = new BeanPropertyBindingResult(person,"person");
        if(validator.supports(person.getClass())){
            validator.validate(person,errors);
        }
        List<ObjectError> allErrors = errors.getAllErrors();
        for(ObjectError e:allErrors){
            System.out.println(e.toString());
        }
        System.out.println(errors.getObjectName());
    }
    
}
```

## DataBinder

从Spring3开始,可以使用Validator配置DataBinder实例.一旦配置了,可以通过binder.validate()方法调用Validator.
所有的验证错误都会被添加到BindingResult.

```java
Foo target = new Foo();
DataBinder binder = new DataBinder(target);
binder.setValidator(new FooValidator());

// bind to the target object
binder.bind(propertyValues);

// validate the target object
binder.validate();

// get BindingResult that includes any validation errors
BindingResult results = binder.getBindingResult();
```



## 嵌套的validator

```java
public class CustomerValidator implements Validator {

    private final Validator addressValidator;

    public CustomerValidator(Validator addressValidator) {
        if (addressValidator == null) {
            throw new IllegalArgumentException("The supplied [Validator] is " +
                "required and must not be null.");
        }
        if (!addressValidator.supports(Address.class)) {
            throw new IllegalArgumentException("The supplied [Validator] must " +
                "support the validation of [Address] instances.");
        }
        this.addressValidator = addressValidator;
    }

    /**
     * This Validator validates Customer instances, and any subclasses of Customer too
     */
    public boolean supports(Class clazz) {
        return Customer.class.isAssignableFrom(clazz);
    }

    public void validate(Object target, Errors errors) {
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "firstName", "field.required");
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "surname", "field.required");
        Customer customer = (Customer) target;
        try {
            errors.pushNestedPath("address");
            ValidationUtils.invokeValidator(this.addressValidator, 
                                            customer.getAddress(), errors);
        } finally {
            errors.popNestedPath();
        }
    }
}
```

# Spring MVC Validation

## LocalValidatorFactoryBean

默认的,如果Bean Validation存在于类路径(例如引入了Hibernate Validator库),`LocalValidatorFactoryBean`会被注册为全局Validator,用于与控制器方法参数上的@Valid和@Validated一起使用。

基于java配置

```java
@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

    @Override
    public Validator getValidator(); {
        // ...
    }
}
```

基于XML

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:mvc="http://www.springframework.org/schema/mvc"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc.xsd">

    <mvc:annotation-driven validator="globalValidator"/>

</beans>
```

# 整合Spring Validation和 BeanValidation

## 编写Validator

```java
package com.packt.webstore.validation.validator;

import com.packt.webstore.domain.bean.Product;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.validation.Errors;
import org.springframework.validation.Validator;

import javax.validation.ConstraintViolation;
import javax.validation.Path;
import java.util.HashSet;
import java.util.Set;

public class ProductValidator implements Validator {

    @Autowired
    private javax.validation.Validator beanValidator;

    private Set<Validator> springValidators;

    public ProductValidator(){
        this.springValidators = new HashSet<Validator>();
    }

    public void setSpringValidators(Set<Validator> springValidators) {
        this.springValidators = springValidators;
    }

    @Override
    public boolean supports(Class<?> aClass) {
        return Product.class.isAssignableFrom(aClass);
    }

    @Override
    public void validate(Object o, Errors errors) {
        Set<ConstraintViolation<Object>> constraintViolationSet = beanValidator.validate(o);
        for(ConstraintViolation<Object> cv:constraintViolationSet){
            String propertyPath = cv.getPropertyPath().toString();
            String message = cv.getMessage();
            errors.rejectValue(propertyPath,"",message);
        }

        for(Validator validator:springValidators){
            validator.validate(o,errors);
        }

    }
}
```

## 注册Validator Bean

```xml
<bean id="productValidator" class="com.packt.webstore.validation.validator.ProductValidator">
    <property name="springValidators">
        <set>
            <bean class="com.packt.webstore.validation.validator.UnitsInStockValidator"/>
        </set>
    </property>
</bean>
```

## 在Controller注入Bean

```java
@Autowired
private ProductValidator productValidator;
```

## 绑定Validator

```java
binder.setValidator(productValidator);
```

