# Java配置

## Web Security 配置入门

通过配置文件，我们会创建一个叫`SpringSecurityFilterChain`的Servlet Filter。应用中所有与安全相关的事情都由它来负责，例如验证提交的用户名和密码、保护URL的访问、重定向到登录页面等等。

```java
import org.springframework.beans.factory.annotation.Autowired;

import org.springframework.context.annotation.*;
import org.springframework.security.config.annotation.authentication.builders.*;
import org.springframework.security.config.annotation.web.configuration.*;

@EnableWebSecurity
public class WebSecurityConfig implements WebMvcConfigurer {

    @Bean
    public UserDetailsService userDetailsService() throws Exception {
        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
        manager.createUser(User.withDefaultPasswordEncoder()
                           .username("user").password("password")
                           .roles("USER").build());
        return manager;
    }
}
```

上面是一个很常见的配置文件，虽然内容没多少，但是做的事情可不少：

- 除了登录页面，所有URL都需要先登录才能访问
- 生成登录页面
- 允许用户通过用户名和密码的方式登录以及退出登录
- 预防CSRF攻击
- [Session Fixation](https://en.wikipedia.org/wiki/Session_fixation) 保护
- Security Header integration
  - [HTTP Strict Transport Security](https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security) for secure requests
  - [X-Content-Type-Options](https://msdn.microsoft.com/en-us/library/ie/gg622941(v=vs.85).aspx) integration
  - Cache Control (can be overridden later by your application to allow caching of your static resources)
  - [X-XSS-Protection](https://msdn.microsoft.com/en-us/library/dd565647(v=vs.85).aspx) integration
  - X-Frame-Options integration to help prevent [Clickjacking](https://en.wikipedia.org/wiki/Clickjacking)
- Integrate with the following Servlet API methods
  - [HttpServletRequest#getRemoteUser()](https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getRemoteUser())
  - [HttpServletRequest.html#getUserPrincipal()](https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getUserPrincipal())
  - [HttpServletRequest.html#isUserInRole(java.lang.String)](https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#isUserInRole(java.lang.String))
  - [HttpServletRequest.html#login(java.lang.String, java.lang.String)](https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#login(java.lang.String, java.lang.String))
  - [HttpServletRequest.html#logout()](https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#logout())

**AbstractSecurityWebApplicationInitializer**

下一步就是注册`springSecurityFilterChain`。Spring提供了`AbstractSecurityWebApplicationInitializer`方便我们注册`springSecurityFilterChain`。

**非Spring环境**

```java
import org.springframework.security.web.context.*;

public class SecurityWebApplicationInitializer
    extends AbstractSecurityWebApplicationInitializer {

    public SecurityWebApplicationInitializer() {
        super(WebSecurityConfig.class);
    }
}
```

**与Spring MVC整合**

如果我们的程序使用了SpringMVC，那么我们很可能已经有一个`WebApplicationInitializer`用来加载Spring配置。这时候我们需要往已经存在的`ApplicationContext`注册Spring Security。

```java
import org.springframework.security.web.context.*;

public class SecurityWebApplicationInitializer
    extends AbstractSecurityWebApplicationInitializer {

}
```

上面的配置会让`springSecurityFilterChain`拦截除了登录页面之外的所有URL，我们还需要往已经存在的`WebApplicationInitializer`导入我们对`Spring Security`的配置

```java
public class MvcWebApplicationInitializer extends
        AbstractAnnotationConfigDispatcherServletInitializer {

    @Override
    protected Class<?>[] getRootConfigClasses() {
        return new Class[] { WebSecurityConfig.class };
    }

    // ... other overrides ...
}
```

## HttpSecurity

目前为止，我们只在`WebSecurityConfig`类上配置了如何对用户进行认证。那么Spring Security为什么会要求所有用户都需要登录呢?为什么会要求通过表单的方式登录呢？这是因为`@EnableWebSecurity`导入了一个叫`WebSecurityConfiguration`的配置类，这个配置类默认使用`WebSecurityConfigurerAdapter`，这个类里面有一个`configure(HttpSecurity http)`方法

```java
protected void configure(HttpSecurity http) throws Exception {
   logger.debug("Using default configure(HttpSecurity). If subclassed this will potentially override subclass configure(HttpSecurity).");

   http
      .authorizeRequests()
         .anyRequest().authenticated()
         .and()
      .formLogin().and()
      .httpBasic();
}
```

这个方法设置了：

- Ensures that any request to our application requires the user to be authenticated
- Allows users to authenticate with form based login
- Allows users to authenticate with HTTP Basic authentication

## 表单登录

Spring Security自动帮我们设置了登录页面和登录的URL，如果想要改写：

```java
@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

	// @formatter:off
	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http.
			authorizeRequests()
				.anyRequest().authenticated()
				.and()
			.formLogin()
				.loginPage("/login")
				.permitAll();

	}
	// @formatter:on
    
    @Override
	@Bean
	public UserDetailsService userDetailsService() {
		InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
		manager.createUser(User.withDefaultPasswordEncoder()
				.username("user").password("password")
				.roles("USER").build());
		return manager;
	}
    
}
```

## 授权请求

上面的例子，访问所有的页面都需要认证（除了登录）。如果需要自定义那些URL不用认证

```java
	// @formatter:off
	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http.
			authorizeRequests()
				.antMatchers("/resources/**","/signup","/about").permitAll()
				.antMatchers("/admin/**").hasRole("ADMIN")
				.antMatchers("/db/**").access("hasRole('ADMIN') and hasRole('DBA')")
				.anyRequest().authenticated()
				.and()
			.formLogin()
				.loginPage("/login")
				.permitAll();
	}
	// @formatter:on
```

- 任何访问`/admin`路径的请求，都需要具有"ROLE_ADMIN"权限级别。调用hasRole方法，我们不需要写`ROLE_`前缀。

## 处理退出登录

`WebSecurityConfigurerAdapter`默认启动退出登录功能`/logout`。退出登录会经过以下步骤

- 使Session失效
- 清除`RememberMe`、清除`SecurityContextHolder`
- 重定向到`/login?logout`

自定义退出登录

```java
@Override
protected void configure(HttpSecurity http) throws Exception {
    http
        .logout() // 1
            .logoutUrl("/my/logout") // 2                                
            .logoutSuccessUrl("/my/index") // 3 
            .logoutSuccessHandler(logoutSuccessHandler) // 4
            .invalidateHttpSession(true) // 5
            .addLogoutHandler(logoutHandler) // 6
            .deleteCookies(cookieNamesToClear) // 7
            .and()
        ...
}
```

- 提供退出登录功能。使用`WebSecurityConfigurerAdapter`时，默认启动该功能
- The URL that triggers log out to occur (default is `/logout`). If CSRF protection is enabled (default), then the request must also be a POST. 
- The URL to redirect to after logout has occurred. 
- 指定`LogoutSuccessHandler`，如果使用了，`logoutSuccessUrl()`会被忽略。
- Specify whether to invalidate the `HttpSession` at the time of logout. This is **true** by default. Configures the `SecurityContextLogoutHandler` under the covers. 
- Adds a `LogoutHandler`. `SecurityContextLogoutHandler` is added as the last `LogoutHandler` by default.
- Allows specifying the names of cookies to be removed on logout success. This is a shortcut for adding a `CookieClearingLogoutHandler` explicitly.

### LogoutHandler

`LogoutHandler`参与退出登录的处理，主要是执行一些清理工作。它们不能抛出异常。

默认实现：

- [PersistentTokenBasedRememberMeServices](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/rememberme/PersistentTokenBasedRememberMeServices.html)
- [TokenBasedRememberMeServices](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/rememberme/TokenBasedRememberMeServices.html)
- [CookieClearingLogoutHandler](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/logout/CookieClearingLogoutHandler.html)
- [CsrfLogoutHandler](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/csrf/CsrfLogoutHandler.html)
- [SecurityContextLogoutHandler](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/logout/SecurityContextLogoutHandler.html)

Please see [Section 10.5.4, “Remember-Me Interfaces and Implementations”](https://docs.spring.io/spring-security/site/docs/5.1.5.RELEASE/reference/htmlsingle/#remember-me-impls) for details.

Instead of providing `LogoutHandler` implementations directly, the fluent API also provides shortcuts that provide the respective `LogoutHandler` implementations under the covers. E.g. `deleteCookies()` allows specifying the names of one or more cookies to be removed on logout success. This is a shortcut compared to adding a `CookieClearingLogoutHandler`.

### LogoutSuccessHandler

The `LogoutSuccessHandler` is called after a successful logout by the `LogoutFilter`, to handle e.g. redirection or forwarding to the appropriate destination.与`LogoutHandler`类似，但是可以抛出异常

The following implementations are provided:

- [SimpleUrlLogoutSuccessHandler](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/logout/SimpleUrlLogoutSuccessHandler.html)
- HttpStatusReturningLogoutSuccessHandler

As mentioned above, you don’t need to specify the `SimpleUrlLogoutSuccessHandler`directly. Instead, the fluent API provides a shortcut by setting the `logoutSuccessUrl()`. This will setup the `SimpleUrlLogoutSuccessHandler` under the covers. The provided URL will be redirected to after a logout has occurred. The default is `/login?logout`.

The `HttpStatusReturningLogoutSuccessHandler` can be interesting in REST API type scenarios. Instead of redirecting to a URL upon the successful logout, this `LogoutSuccessHandler` allows you to provide a plain HTTP status code to be returned. If not configured a status code 200 will be returned by default.

### 更多退出登录相关内容

- [Logout Handling](https://docs.spring.io/spring-security/site/docs/5.1.5.RELEASE/reference/htmlsingle/#ns-logout)
- [Testing Logout](https://docs.spring.io/spring-security/site/docs/5.1.5.RELEASE/reference/htmlsingle/#test-logout)
- [HttpServletRequest.logout()](https://docs.spring.io/spring-security/site/docs/5.1.5.RELEASE/reference/htmlsingle/#servletapi-logout)
- [Section 10.5.4, “Remember-Me Interfaces and Implementations”](https://docs.spring.io/spring-security/site/docs/5.1.5.RELEASE/reference/htmlsingle/#remember-me-impls)
- [Logging Out](https://docs.spring.io/spring-security/site/docs/5.1.5.RELEASE/reference/htmlsingle/#csrf-logout) in section CSRF Caveats
- Section [Single Logout](https://docs.spring.io/spring-security/site/docs/5.1.5.RELEASE/reference/htmlsingle/#cas-singlelogout) (CAS protocol)
- Documentation for the [logout element](https://docs.spring.io/spring-security/site/docs/5.1.5.RELEASE/reference/htmlsingle/#nsa-logout) in the Spring Security XML Namespace section

## OAuth 2.0 Client

[OAuth 2.0 的简单解释](http://www.ruanyifeng.com/blog/2019/04/oauth_design.html)

[OAuth 2.0 的四种授权方式](http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html)

The OAuth 2.0 Client features provide support for the Client role as defined in the [OAuth 2.0 Authorization Framework](https://tools.ietf.org/html/rfc6749#section-1.1).

The following main features are available:

- [Authorization Code Grant](https://tools.ietf.org/html/rfc6749#section-1.3.1)
- [Client Credentials Grant](https://tools.ietf.org/html/rfc6749#section-1.3.4)
- [`WebClient` extension for Servlet Environments](https://docs.spring.io/spring-security/site/docs/5.1.5.RELEASE/reference/htmlsingle/#servlet-webclient) (for making protected resource requests)

**术语**

- `authorization grant ` ： 授权方式
- `authorization-code` ： 授权码
- `implicit` ：隐藏式
- `password` ：密码式
- `client credentials` ：客户端凭证

```java
@EnableWebSecurity
public class OAuth2ClientSecurityConfig 
    extends WebSecurityConfigurerAdapter{

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .oauth2Client()
                .clientRegistrationRepository(this.clientRegistrationRepository())
                .authorizedClientRepository(this.authorizedClientRepository())
                .authorizedClientService(this.authorizedClientService())
                .authorizationCodeGrant()
                    .authorizationRequestRepository(this.authorizationRequestRepository())
                    .authorizationRequestResolver(this.authorizationRequestResolver())
                    .accessTokenResponseClient(this.accessTokenResponseClient());
    }
}
```

### ClientRegistration

`ClientRegistration`表示使用OAuth 2.0或OpenID Connect 1.0 Provider注册的客户端。

```java
public final class ClientRegistration {
    // 本次注册的Id
    private String registrationId;  
    // 客户端Id
    private String clientId;    密码shizi
    private String clientSecret;    
    // 客户端授权方法 basic 或 post
    private ClientAuthenticationMethod clientAuthenticationMethod;  
    // 授权方式 授权码、隐藏式、密码式、客户端凭证
    private AuthorizationGrantType authorizationGrantType;  
    // 授权成功或失败后重定向到
    private String redirectUriTemplate; 
    private Set<String> scopes; 
    private ProviderDetails providerDetails;
    // 客户端名称
    private String clientName;  

    public class ProviderDetails {
        private String authorizationUri;    
        private String tokenUri;    
        private UserInfoEndpoint userInfoEndpoint;
        private String jwkSetUri;   
        private Map<String, Object> configurationMetadata;  

        public class UserInfoEndpoint {
            private String uri; 
            private AuthenticationMethod authenticationMethod;  
            private String userNameAttributeName;   

        }
    }
}
```

**总的来说就是用来设置申请授权相关信息的**

### ClientRegistrationRepository

存放ClientRegistration的仓库。

```java
@Controller
public class OAuth2ClientController {

    @Autowired
    private ClientRegistrationRepository clientRegistrationRepository;

    @RequestMapping("/")
    public String index() {
        ClientRegistration googleRegistration =
            this.clientRegistrationRepository.findByRegistrationId("google");

        ...

        return "index";
    }
}
```

### OAuth2AuthorizedClient

`OAuth2AuthorizedClient`代表一个已经被授权的客户端。

serves the purpose of associating an `OAuth2AccessToken`(and optional `OAuth2RefreshToken`) to a `ClientRegistration` (client) and resource owner

保管权限令牌与更新令牌。

### OAuth2AuthorizedClientRepository / OAuth2AuthorizedClientService



### @RegisteredOAuth2AuthorizedClient

修饰方法参数，用于快速获取`OAuth2AuthorizedClient`。

```java
@Controller
public class OAuth2LoginController {

    @RequestMapping("/userinfo")
    public String userinfo(@RegisteredOAuth2AuthorizedClient("google") OAuth2AuthorizedClient authorizedClient) {
        OAuth2AccessToken accessToken = authorizedClient.getAccessToken();
        ...
        return "userinfo";
    }
}
```

### AuthorizationRequestRepository



### OAuth2AuthorizationRequestResolver



### OAuth2AccessTokenResponseClient

## OAuth 2.0 Login



## OAuth 2.0 Resource Server

## Authentication

## Multiple HttpSecurity

## Method Security

## Post Processing Configured Objects

## Custom DSLs

