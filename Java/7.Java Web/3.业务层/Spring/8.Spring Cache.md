# 基于注解实现缓存

## `@Cacheable`

用来修饰方法，该方法的结果会被添加到缓存中，再次调用该方法直接返回缓存中的结果。

```java
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
public @interface Cacheable {

   // 用来设置缓存名称
   @AliasFor("cacheNames")
   String[] value() default {};
    
   @AliasFor("value")
   String[] cacheNames() default {};

   // Spring提供了一个SimpleKeyGenerator用来生成key,默认情况下它的算法如下
   // 如果方法参数个数为0，那么返回一个SimpleKey.EMPTY
   // 如果方法参数个数为1，且该参数不是一个数组，返回该参数
   // 返回所有参数
    
   // 但是有些时候，我们想指定哪些参数用来作为key，这时候就可以设置该选项
   // 该选项支持 SpEL
   String key() default "";

   // 顾名思义就是一个KeyGenerator，要求填写的是实现了KeyGenerator接口的bean的名称
   String keyGenerator() default "";

   // 填写一个实现了CacheManager接口的Bean的名称，用来创建cacheResolver。
   String cacheManager() default "";
   
   // 填写一个实现了CacheResolver接口的Bean的名称，用来设置Cache实例。
   String cacheResolver() default "";
	
   // 根据方法的参数判断是否使用缓存
   String condition() default "";

   // 根据方法的结果判断是否要存放到缓存中
   String unless() default "";

   // 写上锁
   boolean sync() default false;

}
```

## Example

```java
@Cacheable("books") 
public Book findBook(ISBN isbn) {...}
```

```java
@Cacheable({"books", "isbns"})
public Book findBook(ISBN isbn) {...}
```

```java
@Cacheable(cacheNames="books", key="#isbn")
public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)

@Cacheable(cacheNames="books", key="#isbn.rawNumber")
public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)

@Cacheable(cacheNames="books", key="T(someType).hash(#isbn)")
public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)
```

```java
@Cacheable(cacheNames="books", keyGenerator="myKeyGenerator")
public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)
```

