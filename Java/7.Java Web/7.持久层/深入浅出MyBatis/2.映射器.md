# 映射器

## 1.映射器的主要元素

- select
- insert
- update
- delete
- sql  （允许自定义一部分的SQL然后在各个地方引用）
- resultMap
- cache
- cache-ref

## 2.CRUD

### 1.Select元素

#### Select元素的属性

| 属性          | 说明                                            | 备注       |
| ------------- | ----------------------------------------------- | ---------- |
| id            | 对应的方法名称                                  |            |
| parameterType | 参数类型，可以使类的全命令，也可以使用别名      |            |
| resultType    | 结果类型                                        |            |
| resultMap     | 结果映射                                        |            |
| flushCache    | 调用SQL后，是否清空之前查询的本地缓存和二级缓存 | 默认 false |
| useCache      | 是否启动二级缓存，存储该结果                    | 默认 true  |
| timeout       |                                                 |            |
| fetchSize     | 设定获取记录的总条数                            |            |
| statementType |                                                 |            |
| resultSetType |                                                 |            |
| databaseId    |                                                 |            |
| resultOrdered |                                                 |            |
| resultSets    |                                                 |            |

#### 传递多个参数

#### 使用Map传递参数

可读性差

#### 使用注解的方式传递参数

```java
List<Role> findRoleByAnnotation(@Param("roleName")String roleName,
                                @Param("note")String note);
```

当参数个数一多，写起来也是难受

#### 使用JavaBean传递参数

### 2.insert元素

#### insert元素的属性

| 属性名称         | 描述 | 备注 |
| ---------------- | ---- | ---- |
| id               |      |      |
| parameterType    |      |      |
| flushCache       |      |      |
| timeout          |      |      |
| statementType    |      |      |
| useGeneratedKeys |      |      |
| keyProperty      |      |      |
| keyColumn        |      |      |
| databaseI        |      |      |
| lang             |      |      |

## 3.sql元素

通过sql元素，我们可以写sql语句，然后在其他地方使用。

```xml
<sql id="role_columns">
	id,role_name,note
</sql>

<select id="getRole" parameterType="long" resultMap="roleMap">
	select <include refid="role_columns"> from t_role where id = #{id};
</select>
```



## 4.ResultType

ResultType不是元素,它只是select元素中的一个属性.

其作用就是说明,查询结果应该映射到哪种Java类型上.

### 使用集合类型的resultType

#### 单个集合

```xml
<select id="selectById" parameterType="int" resultType="map">
    <!--resultType中的map是java.util.HashMap的别名-->
	select * from tb_user where id = #{id};
</select>
```

```java
public interface UserRepository {
    public Map<String,Object> selectById(int id);
}
```

```java
UserRepository userRepository = sqlSession.getMapper("UserRepository.xml");

Map<String,Object> userMap = userRepository.selectById(id);
for(String key:userMap.keySet()){
     System.out.println(key+": "+userMap.get(key));
}
```

#### 嵌套集合

```xml
<select id="selectAllUser" resultType="map">
	select * from tb_user;
</select>
<!--最后的返回结果类型List<Map<String,Object>>-->
```

```java
public interface UserRepository {
    public List<Map<String,Object>> selectAllUser();
}
```

------

## 5.Result Maps元素

ResultMaps其实就是ResultType的升级版,都是用来把select语句返回的结果映射到JavaBean的属性上。

 ResultMap 的设计思想是，简单的语句不需要明确的结果映射，而复杂一点的语句只需要描述它们的关系就行了。 

当JavaBean属性名与数据表中列明不相同时,使用resultType就会有点麻烦,如下

```xml
<typeAlias type="com.someapp.model.User" alias="User"/>
<select id="selectUsers" resultType="User">
  select
  user_id             as "id",
  user_name           as "userName",
  hashed_password     as "hashedPassword"
  from tb_user
  where id = #{id}
</select>
```

**使用Result Map**

```xml
<!--结果映射 将数据库返回结果的数据与java数据对应-->
<resultMap id="userResultMap" type="User">
  <!--id元素跟result元素相似,但它是用来映射标识符属性(标识符属性:用来比较对象是否相等的属性)-->
  <id property="id" column="user_id" />
  <!--result元素用来把结果中列的值映射到JavaBean的属性上-->
  <result property="username" column="user_name"/>
  <result property="password" column="hashed_password"/>
</resultMap>

<select id="selectUsers" resultMap="userResultMap">
  select user_id, user_name, hashed_password
  from some_table
  where id = #{id}
</select>
```

resultMap是非常强大的,下面让我们看看它其它作用.



### ResultMap的继承

```xml
<resultMap type="Student" id="StudentResult">
    <id property="studId" column="stud_id"/>
    <result property="name" column="name"/>
    <result property="email" column="email"/>
    <result property="phone" column="phone"/>
</resultMap>

<resultMap type="Student" id="StudentWithAddressResult" extends="StudentResult">
    <result property="address.addrId" column="addr_id"/>
    <result property="address.street" column="street"/>
    <result property="address.city" column="city"/>
    <result property="address.state" column="state"/>
    <result property="address.zip" column="zip"/>
    <result property="address.country" column="country"/>
</resultMap>
```

**最佳实践：使用框架的缺点是有时候它们看上去像黑盒子(无论源代码是否可见)。 为了确保你实现的行为和想要的一致，最好的选择是编写单元测试。** 

### 一对一关系的映射处理

在我们的领域对象中,每个学生都具有一个地址,着就是一对一关系.

```java
public class Address
{
    private Integer addrId;
    private String street;
    private String city;
    private String state;
    private String zip;
    private String country;
    // setters & getters
}
```

```java
public class Student
{
    private Integer studId;
    private String name;
    private String email;
    private PhoneNumber phone;
    private Address address;
    //setters & getters
}
```

有三种方法来处理一对一关系.

#### 直接处理法

```xml
<resultMap type="Student" id="StudentWithAddressResult">
    <id property="studId" column="stud_id"/>
    <result property="name" column="name"/>
    <result property="email" column="email"/>
    <result property="phone" column="phone"/>
    <result property="address.addrId" column="addr_id"/>
    <result property="address.street" column="street"/>
    <result property="address.city" column="city"/>
    <result property="address.state" column="state"/>
    <result property="address.zip" column="zip"/>
    <result property="address.country" column="country"/>
</resultMap>
```

```xml
<select id="selectStudentWithAddress" parameterType="int" resultMap="StudentWithAddressResult">
    SELECT STUD_ID, NAME, EMAIL, A.ADDR_ID, STREET, CITY, STATE,ZIP, COUNTRY
    FROM STUDENTS S LEFT OUTER JOIN ADDRESSES A ON <!--这里其实是SQL语句知识-->
    S.ADDR_ID=A.ADDR_ID
    WHERE STUD_ID=#{studId}
</select>
```

这种方法的缺点是,如果我们只需要用到address的信息,则需要另外写一个address的resultMap.

#### 使用嵌套ResultMap

上面的例子向我们展示一种处理一对一表的方法,接下来我们介绍另一种实现方法.

```xml
<resultMap type="Address" id="AddressResult">
    <id property="addrId" column="addr_id"/>
    <result property="street" column="street"/>
    <result property="city" column="city"/>
    <result property="state" column="state"/>
    <result property="zip" column="zip"/>
    <result property="country" column="country"/>
</resultMap>

<resultMap type="Student" id="StudentWithAddressResult">
    <id property="studId" column="stud_id"/>
    <result property="name" column="name"/>
    <result property="email" column="email"/>
    <association property="address" resultMap="AddressResult"/>
    <!--association元素可以引用在同一个XML文件中定义的resultMap元素-->
</resultMap>

```

```xml
<select id="findStudentWithAddress" parameterType="int" 
        resultMap="StudentWithAddressResult">
    SELECT STUD_ID, NAME, EMAIL, A.ADDR_ID, STREET, CITY, STATE,ZIP, COUNTRY
    FROM STUDENTS S LEFT OUTER JOIN ADDRESSES A ON
    S.ADDR_ID=A.ADDR_ID
    WHERE STUD_ID=#{studId}
</select>
```

你也可以直接resultMap元素中,使用association元素配置结果的映射

```xml
<resultMap type="Student" id="StudentWithAddressResult">
    <id property="studId" column="stud_id"/>
    <result property="name" column="name"/>
    <result property="email" column="email"/>
    <association property="address" javaType="Address">
        <id property="addrId" column="addr_id"/>
        <result property="street" column="street"/>
        <result property="city" column="city"/>
        <result property="state" column="state"/>
        <result property="zip" column="zip"/>
        <result property="country" column="country"/>
    </association>
</resultMap>
```

#### 使用嵌套的select语句

通过使用嵌套的select语句,我们可以获取student以及address的内容.

```xml
<select id="findAddressById" parameterType="int"
    resultMap="AddressResult">
    SELECT * FROM ADDRESSES WHERE ADDR_ID=#{id}
</select>

<resultMap type="Student" id="StudentWithAddressResult">
    <id property="studId" column="stud_id"/>
    <result property="name" column="name"/>
    <result property="email" column="email"/>
    <association property="address" column="addr_id" select="findAddressById"/>
    <!--其实也是使用association元素而已-->
</resultMap>

<select id="findStudentWithAddress" parameterType="int" resultMap="StudentWithAddressResult">
    SELECT * FROM STUDENTS WHERE STUD_ID=#{Id}
</select>

```

在本例子中,该嵌套select语句,会在数据库中执行两次查询操作.

### 一对多关系的映射处理

在我们的领域对象中,每个导师可以教一到多门课程,这就是一对多关系.

我们可以使用collection元素,处理一对多关系的结果.

```java
public class Course
{
    private Integer courseId;
    private String name;
    private String description;
    private Date startDate;
    private Date endDate;
    private Integer tutorId;
    //setters & getters
}
```

```java
public class Tutor
{
    private Integer tutorId;
    private String name;
    private String email;
    private Address address;
    private List<Course> courses;
    /setters & getters
}
```

有两种方法处理一对多关系

#### 使用嵌套ResultMap

```xml
<resultMap type="Course" id="CourseResult">
    <id column="course_id" property="courseId"/>
    <result column="name" property="name"/>
    <result column="description" property="description"/>
    <result column="start_date" property="startDate"/>
    <result column="end_date" property="endDate"/>
</resultMap>

<resultMap type="Tutor" id="TutorResult">
    <id column="tutor_id" property="tutorId"/>
    <result column="tutor_name" property="name"/>
    <result column="email" property="email"/>
    <collection property="courses" resultMap="CourseResult"/>
</resultMap>

<select id="findTutorById" parameterType="int" resultMap="TutorResult">
    SELECT T.TUTOR_ID, T.NAME AS TUTOR_NAME, EMAIL, C.COURSE_ID,
    C.NAME, DESCRIPTION, START_DATE, END_DATE
    FROM TUTORS T LEFT OUTER JOIN ADDRESSES A ON T.ADDR_ID=A.ADDR_ID
    LEFT OUTER JOIN COURSES C ON T.TUTOR_ID=C.TUTOR_ID
    WHERE T.TUTOR_ID=#{tutorId}
</select>
```

#### 使用嵌套select语句

```xml
<resultMap type="Course" id="CourseResult">
    <id column="course_id" property="courseId"/>
    <result column="name" property="name"/>
    <result column="description" property="description"/>
    <result column="start_date" property="startDate"/>
    <result column="end_date" property="endDate"/>
</resultMap>

<select id="findCoursesByTutor" parameterType="int" resultMap="CourseResult">
    SELECT * FROM COURSES WHERE TUTOR_ID=#{tutorId}
</select>

<resultMap type="Tutor" id="TutorResult">
    <id column="tutor_id" property="tutorId"/>
    <result column="tutor_name" property="name"/>
    <result column="email" property="email"/>
    <collection property="courses" column="tutor_id" select="findCoursesByTutor"/>
</resultMap>

<select id="findTutorById" parameterType="int" resultMap="TutorResult">
    SELECT T.TUTOR_ID, T.NAME AS TUTOR_NAME, EMAIL
    FROM TUTORS T WHERE T.TUTOR_ID=#{tutorId}
</select>
```



------

## 6.缓存

**一级缓存**

MyBatis支持缓存功能，在默认情况下，它只开启一级缓存。（一级缓存只是相对于同一个SqlSession而言）

在第一次查询的后，MyBatis会把查询的结果缓存起来，如果之后并没有发生更新、插入、删除等操作，而且缓存也没有过期，对于接下来相同的查询，MyBatis会返回缓存中的结果。

**二级缓存**

由于一级缓存SqlSession层面的，而且SqlSession又是相互隔离的，为了解决这个问题，我们就需要开启二级缓存。

开启二级缓存,只需要在你的 SQL 映射文件中添加一行:

```xml
<cache/>
```

这个简单语句的效果如下:

- 映射语句文件中的所有 select 语句将会被缓存。
- 映射语句文件中的所有 insert,update 和 delete 语句会刷新缓存。
- 缓存会使用 Least Recently Used(LRU,最近最少使用的)算法来收回。
- 根据时间表(比如 no Flush Interval,没有刷新间隔), 缓存不会以任何时间顺序 来刷新。
- 缓存会存储列表集合或对象(无论查询方法返回什么)的 1024 个引用。
- 缓存会被视为是 read/write(可读/可写)的缓存,意味着对象检索不是共享的,而 且可以安全地被调用者修改,而不干扰其他调用者或线程所做的潜在修改。

上面的这些属性都可以通过缓存元素的属性来修改，例如:

```xml
<cache
  eviction="FIFO"
  flushInterval="60000"
  size="512"
  readOnly="true"/>
```

这里定义了一个 FIFO,并每隔 60 秒刷新,存数结果对象或列表的 512 个引用,而且返回的对象被认为是只读的缓存配置。

## 7.动态SQL

MyBatis的动态SQL包括以下几种元素

| 元素                      | 作用                        | 备注                    |
| ------------------------- | --------------------------- | ----------------------- |
| if                        | 判断语句                    |                         |
| choose（when、otherwise） | 相当于Java中的case when语句 |                         |
| trim（where、set）        | 辅助元素                    | 用于处理一些SQL拼接问题 |
| foreach                   | 循环语句                    |                         |

### 7.1if

```xml
<select id="searchCourses" parameterType="hashmap" resultMap="CourseResult">
    <![CDATA[
        SELECT * FROM COURSES
        WHERE TUTOR_ID= #{tutorId}
        <if test="courseName != null">
        	AND NAME LIKE #{courseName}
        </if>
        <if test="startDate != null">
        	AND START_DATE >= #{startDate}
        </if>
        <if test="endDate != null">
        	AND END_DATE <= #{endDate}
        </if>
    ]]>
</select>
<!--
	所有 XML 文档中的文本均会被解析器解析。
	只有 CDATA 区段（CDATA section）中的文本会被解析器忽略。
	主要是解决特殊字符的问题，例如 < & 等等
	< &lt;
	> &gt;
	&amp; &
	&apos; '
	&quot; "
-->
```

### 7.2choose  when  otherwise 

```xml
<select id="searchCourses" parameterType="hashmap" resultMap="CourseResult">
    SELECT * FROM COURSES
    <choose>
        <when test="searchBy == 'Tutor'">WHERE TUTOR_ID= #{tutorId}</when>
        <when test="searchBy == 'CourseName'">WHERE name like #{courseName}</when>
        <otherwise>WHERE TUTOR start_date &gt;= now()</otherwise>
    </choose>
</select>
<!--类似与switch语句-->
```

### 7.3where元素

```xml
<select id="searchCourses" parameterType="hashmap" resultMap="CourseResult">
    SELECT * FROM COURSES
    <where>
        <if test=" tutorId != null ">
            TUTOR_ID= #{tutorId}
        </if>
        <if test="courseName != null">
            AND name like #{courseName} <!--如果where后面是AND或者OR,则会除去AND/OR-->
        </if>
        <if test="startDate != null">
            AND start_date &gt;= #{startDate}
        </if>
        <if test="endDate != null">
            AND end_date &lt;= #{endDate}
        </if>
    </where>
</select>
```

### 7.4trim元素

trim元素类似于where元素,它更加灵活.

```xml
<select id="searchCourses" parameterType="hashmap" resultMap="CourseResult">
    SELECT * FROM COURSES
    <trim prefix="WHERE" prefixOverrides="AND | OR">
        <!--
			1.在语句开头添加WHERE关键字
			2.如果语句的开头是AND 或者 OR 则改写成WHERE
		-->
        <if test=" tutorId != null ">
            TUTOR_ID= #{tutorId}
        </if>
        <if test="courseName != null">
            AND name like #{courseName}
        </if>
    </trim>
</select>
```

### 7.5set元素

```xml
<update id="updateStudent" parameterType="Student">
    update students
    <set>
        <if test="name != null">name=#{name},</if>
        <if test="email != null">email=#{email},</if>
        <if test="phone != null">phone=#{phone},</if>
    </set>
    where stud_id=#{id}
</update>
```

### 7.6foreach元素

```xml
<select id="searchCoursesByTutors" parameterType="map" resultMap="CourseResult">
    SELECT * FROM COURSES
    <if test="tutorIds != null">
        <where>
            <foreach item="tutorId" collection="tutorIds">
                OR tutor_id=#{tutorId}
            </foreach>
        </where>
    </if>
</select>
```

------

## 