# Mapper.xml

该文件用于填写需要执行的sql语句。

SQL 映射文件提供了以下的元素（按照它们应该被定义的顺序）：

- `cache` – 给定命名空间的缓存配置。
- `cache-ref` – 其他命名空间缓存配置的引用。
- `resultMap` – 是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。
- `sql` – 可被其他语句引用的可重用语句块。
- `insert` – 映射插入语句
- `update` – 映射更新语句
- `delete` – 映射删除语句
- `select` – 映射查询语句



## SQL 语句

### insert

```xml
<insert id="insert" parameterType="User">
    insert into tb_user(username,password,age)
    values(#{userName},#{password},#{age})
</insert>
```

#### Autogenerated keys

```xml
<!--把自动生成的值，写入到User对象的id字段-->
<insert id="insert" parameterType="User" useGeneratedKeys="true" keyProperty="id">
    insert into tb_user(username,password,age)
    values(#{userName},#{password},#{age})
</insert>
```

### update

```xml
<update id="update" parameterType="User">
        update tb_user
        set
        username = #{userName} ,
        password = #{password},
        age=#{age}
        where username=#{userName}
</update>
```

### delete

```xml
<delete id="delete" parameterType="String">
    delete from tb_user where username=#{userName}
</delete>
```

### select

MyBatis真正强大之处在于它能够非常灵活的把select的结果映射到JavaBean上。

```xml
<select id="selectById" parameterType="int" resultType="User">
	select * from tb_user where id=#{id};
</select>
<!--MyBatis会把select语句返回的结果，自动映射到UserBean中。-->
```

注意：当数据库表中列名与JavaBean中对应的属性名不同时，需要特殊的处理。

```xml
<select id="findStudentById" parameterType="int" resultType="Student">
    SELECT STUD_ID AS studId, NAME,EMAIL, PHONE
    FROM STUDENTS
    WHERE STUD_ID=#{studId}
</select>
```

### 使用SQL语句的两种方法

SQL语句编写好了，接下来就要看看怎么使用，MyBatis提供了两种调用SQL语句的途径。

- SqlSession.getMapper(XXXMaper.class)  推荐

  该方法通过把XXXMapper.xml与XXXDao接口连接起来的方式，让我们调用接口的方法来执行对应的SQL语句。

  ```java
  try(SqlSession sqlSession = SqlSessionProvider.getSqlSession()){
              UserDao userDao = sqlSession.getMapper(UserDao.class);
              User u = userDao.selectById(1);
              System.out.println(u);
          }
  ```

  

- SqlSession.[selectOne/delete/update/insert]

    ```java
    try(SqlSession sqlSession = SqlSessionProvider.getSqlSession()){
                int id = 1;
                User u = sqlSession.selectOne("com.hdr.mybatisDemo.dao.UserDao.selectById", id);
                System.out.println(u);
            }
    // 一看就觉得麻烦
    ```

----

## ResultType

ResultType不是元素,它只是select元素中的一个属性.

其作用就是说明,查询结果应该映射到哪种Java类型上.

### 使用集合类型的resultType

#### 单个集合

```xml
<select id="selectById" parameterType="int" resultType="map">
    <!--resultType中的map是java.util.HashMap的别名-->
	select * from tb_user where id = #{id};
</select>
```

```java
public interface UserRepository {
    public Map<String,Object> selectById(int id);
}
```


```java
UserRepository userRepository = sqlSession.getMapper("UserRepository.xml");

Map<String,Object> userMap = userRepository.selectById(id);
for(String key:userMap.keySet()){
     System.out.println(key+": "+userMap.get(key));
}
```

#### 嵌套集合

```xml
<select id="selectAllUser" resultType="map">
	select * from tb_user;
</select>
<!--最后的返回结果类型List<Map<String,Object>>-->
```

```java
public interface UserRepository {
    public List<Map<String,Object>> selectAllUser();
}
```
---

## Result Maps元素

ResultMaps其实就是ResultType的升级版,都是用来把select语句返回的结果映射到JavaBean的属性上。

 ResultMap 的设计思想是，简单的语句不需要明确的结果映射，而复杂一点的语句只需要描述它们的关系就行了。 

当JavaBean属性名与数据表中列明不相同时,使用resultType就会有点麻烦,如下

```xml
<typeAlias type="com.someapp.model.User" alias="User"/>
<select id="selectUsers" resultType="User">
  select
  user_id             as "id",
  user_name           as "userName",
  hashed_password     as "hashedPassword"
  from tb_user
  where id = #{id}
</select>
```

**使用Result Map**

```xml
<!--结果映射 将数据库返回结果的数据与java数据对应-->
<resultMap id="userResultMap" type="User">
  <!--id元素跟result元素相似,但它是用来映射标识符属性(标识符属性:用来比较对象是否相等的属性)-->
  <id property="id" column="user_id" />
  <!--result元素用来把结果中列的值映射到JavaBean的属性上-->
  <result property="username" column="user_name"/>
  <result property="password" column="hashed_password"/>
</resultMap>

<select id="selectUsers" resultMap="userResultMap">
  select user_id, user_name, hashed_password
  from some_table
  where id = #{id}
</select>
```

resultMap是非常强大的,下面让我们看看它其它作用.

#### 





### ResultMap的继承

```xml
<resultMap type="Student" id="StudentResult">
    <id property="studId" column="stud_id"/>
    <result property="name" column="name"/>
    <result property="email" column="email"/>
    <result property="phone" column="phone"/>
</resultMap>

<resultMap type="Student" id="StudentWithAddressResult" extends="StudentResult">
    <result property="address.addrId" column="addr_id"/>
    <result property="address.street" column="street"/>
    <result property="address.city" column="city"/>
    <result property="address.state" column="state"/>
    <result property="address.zip" column="zip"/>
    <result property="address.country" column="country"/>
</resultMap>
```

**最佳实践：使用框架的缺点是有时候它们看上去像黑盒子(无论源代码是否可见)。 为了确保你实现的行为和想要的一致，最好的选择是编写单元测试。** 

### 一对一关系的映射处理

在我们的领域对象中,每个学生都具有一个地址,着就是一对一关系.

```java
public class Address
{
    private Integer addrId;
    private String street;
    private String city;
    private String state;
    private String zip;
    private String country;
    // setters & getters
}
```

```java
public class Student
{
    private Integer studId;
    private String name;
    private String email;
    private PhoneNumber phone;
    private Address address;
    //setters & getters
}
```

有三种方法来处理一对一关系.

#### 直接处理法

```xml
<resultMap type="Student" id="StudentWithAddressResult">
    <id property="studId" column="stud_id"/>
    <result property="name" column="name"/>
    <result property="email" column="email"/>
    <result property="phone" column="phone"/>
    <result property="address.addrId" column="addr_id"/>
    <result property="address.street" column="street"/>
    <result property="address.city" column="city"/>
    <result property="address.state" column="state"/>
    <result property="address.zip" column="zip"/>
    <result property="address.country" column="country"/>
</resultMap>
```

```xml
<select id="selectStudentWithAddress" parameterType="int" resultMap="StudentWithAddressResult">
    SELECT STUD_ID, NAME, EMAIL, A.ADDR_ID, STREET, CITY, STATE,ZIP, COUNTRY
    FROM STUDENTS S LEFT OUTER JOIN ADDRESSES A ON <!--这里其实是SQL语句知识-->
    S.ADDR_ID=A.ADDR_ID
    WHERE STUD_ID=#{studId}
</select>
```

这种方法的缺点是,如果我们只需要用到address的信息,则需要另外写一个address的resultMap.

#### 使用嵌套ResultMap

上面的例子向我们展示一种处理一对一表的方法,接下来我们介绍另一种实现方法.

```xml
<resultMap type="Address" id="AddressResult">
    <id property="addrId" column="addr_id"/>
    <result property="street" column="street"/>
    <result property="city" column="city"/>
    <result property="state" column="state"/>
    <result property="zip" column="zip"/>
    <result property="country" column="country"/>
</resultMap>

<resultMap type="Student" id="StudentWithAddressResult">
    <id property="studId" column="stud_id"/>
    <result property="name" column="name"/>
    <result property="email" column="email"/>
    <association property="address" resultMap="AddressResult"/>
    <!--association元素可以引用在同一个XML文件中定义的resultMap元素-->
</resultMap>

```

```xml
<select id="findStudentWithAddress" parameterType="int" resultMap="StudentWithAddressResult">
    SELECT STUD_ID, NAME, EMAIL, A.ADDR_ID, STREET, CITY, STATE,ZIP, COUNTRY
    FROM STUDENTS S LEFT OUTER JOIN ADDRESSES A ON
    S.ADDR_ID=A.ADDR_ID
    WHERE STUD_ID=#{studId}
</select>
```

你也可以直接resultMap元素中,使用association元素配置结果的映射


```xml
<resultMap type="Student" id="StudentWithAddressResult">
    <id property="studId" column="stud_id"/>
    <result property="name" column="name"/>
    <result property="email" column="email"/>
    <association property="address" javaType="Address">
        <id property="addrId" column="addr_id"/>
        <result property="street" column="street"/>
        <result property="city" column="city"/>
        <result property="state" column="state"/>
        <result property="zip" column="zip"/>
        <result property="country" column="country"/>
    </association>
</resultMap>
```

#### 使用嵌套的select语句

通过使用嵌套的select语句,我们可以获取student以及address的内容.

```xml
<select id="findAddressById" parameterType="int"
    resultMap="AddressResult">
    SELECT * FROM ADDRESSES WHERE ADDR_ID=#{id}
</select>

<resultMap type="Student" id="StudentWithAddressResult">
    <id property="studId" column="stud_id"/>
    <result property="name" column="name"/>
    <result property="email" column="email"/>
    <association property="address" column="addr_id" select="findAddressById"/>
    <!--其实也是使用association元素而已-->
</resultMap>

<select id="findStudentWithAddress" parameterType="int" resultMap="StudentWithAddressResult">
    SELECT * FROM STUDENTS WHERE STUD_ID=#{Id}
</select>

```

在本例子中,该嵌套select语句,会在数据库中执行两次查询操作.

## 一对多关系的映射处理

在我们的领域对象中,每个导师可以教一到多门课程,这就是一对多关系.

我们可以使用collection元素,处理一对多关系的结果.

```java
public class Course
{
    private Integer courseId;
    private String name;
    private String description;
    private Date startDate;
    private Date endDate;
    private Integer tutorId;
    //setters & getters
}
```

```java
public class Tutor
{
    private Integer tutorId;
    private String name;
    private String email;
    private Address address;
    private List<Course> courses;
    /setters & getters
}
```

有两种方法处理一对多关系

#### 使用嵌套ResultMap

```xml
<resultMap type="Course" id="CourseResult">
    <id column="course_id" property="courseId"/>
    <result column="name" property="name"/>
    <result column="description" property="description"/>
    <result column="start_date" property="startDate"/>
    <result column="end_date" property="endDate"/>
</resultMap>

<resultMap type="Tutor" id="TutorResult">
    <id column="tutor_id" property="tutorId"/>
    <result column="tutor_name" property="name"/>
    <result column="email" property="email"/>
    <collection property="courses" resultMap="CourseResult"/>
</resultMap>

<select id="findTutorById" parameterType="int" resultMap="TutorResult">
    SELECT T.TUTOR_ID, T.NAME AS TUTOR_NAME, EMAIL, C.COURSE_ID,
    C.NAME, DESCRIPTION, START_DATE, END_DATE
    FROM TUTORS T LEFT OUTER JOIN ADDRESSES A ON T.ADDR_ID=A.ADDR_ID
    LEFT OUTER JOIN COURSES C ON T.TUTOR_ID=C.TUTOR_ID
    WHERE T.TUTOR_ID=#{tutorId}
</select>
```

#### 使用嵌套select语句

```xml
<resultMap type="Course" id="CourseResult">
    <id column="course_id" property="courseId"/>
    <result column="name" property="name"/>
    <result column="description" property="description"/>
    <result column="start_date" property="startDate"/>
    <result column="end_date" property="endDate"/>
</resultMap>

<select id="findCoursesByTutor" parameterType="int" resultMap="CourseResult">
    SELECT * FROM COURSES WHERE TUTOR_ID=#{tutorId}
</select>

<resultMap type="Tutor" id="TutorResult">
    <id column="tutor_id" property="tutorId"/>
    <result column="tutor_name" property="name"/>
    <result column="email" property="email"/>
    <collection property="courses" column="tutor_id" select="findCoursesByTutor"/>
</resultMap>

<select id="findTutorById" parameterType="int" resultMap="TutorResult">
    SELECT T.TUTOR_ID, T.NAME AS TUTOR_NAME, EMAIL
    FROM TUTORS T WHERE T.TUTOR_ID=#{tutorId}
</select>


```



---

## 动态SQL

MyBatis提供<if>, <choose>, <where>, <foreach>,  <trim>.等元素来让我们构建动态SQL语句.

### If元素

If元素由判断条件和sql语句组成,当判断为真时,则使用if元素中的sql语句.

```xml
<resultMap type="Course" id="CourseResult">
    <id column="course_id" property="courseId"/>
    <result column="name" property="name"/>
    <result column="description" property="description"/>
    <result column="start_date" property="startDate"/>
    <result column="end_date" property="endDate"/>
</resultMap>

<select id="searchCourses" parameterType="hashmap" resultMap="CourseResult">
    <![CDATA[
        SELECT * FROM COURSES
        WHERE TUTOR_ID= #{tutorId}
        <if test="courseName != null">
        	AND NAME LIKE #{courseName}
        </if>
        <if test="startDate != null">
        	AND START_DATE >= #{startDate}
        </if>
        <if test="endDate != null">
        	AND END_DATE <= #{endDate}
        </if>
    ]]>
</select>
<!--
	所有 XML 文档中的文本均会被解析器解析。
	只有 CDATA 区段（CDATA section）中的文本会被解析器忽略。
-->
```

### choose  when  otherwise 元素

```xml
<select id="searchCourses" parameterType="hashmap" resultMap="CourseResult">
    SELECT * FROM COURSES
    <choose>
        <when test="searchBy == 'Tutor'">WHERE TUTOR_ID= #{tutorId}</when>
        <when test="searchBy == 'CourseName'">WHERE name like #{courseName}</when>
        <otherwise>WHERE TUTOR start_date &gt;= now()</otherwise>
    </choose>
</select>
<!--类似与switch语句-->
```

### where元素

```xml
<select id="searchCourses" parameterType="hashmap" resultMap="CourseResult">
    SELECT * FROM COURSES
    <where>
        <if test=" tutorId != null ">
            TUTOR_ID= #{tutorId}
        </if>
        <if test="courseName != null">
            AND name like #{courseName} <!--如果where后面是AND或者OR,则会出去AND/OR-->
        </if>
        <if test="startDate != null">
            AND start_date &gt;= #{startDate}
        </if>
        <if test="endDate != null">
            AND end_date &lt;= #{endDate}
        </if>
    </where>
</select>
```

### trim元素

trim元素类似于where元素,它更加灵活.

```xml
<select id="searchCourses" parameterType="hashmap" resultMap="CourseResult">
    SELECT * FROM COURSES
    <trim prefix="WHERE" prefixOverrides="AND | OR">
        <if test=" tutorId != null ">
            TUTOR_ID= #{tutorId}
        </if>
        <if test="courseName != null">
            AND name like #{courseName}
        </if>
    </trim>
</select>
```

### set元素

```xml
<update id="updateStudent" parameterType="Student">
    update students
    <set>
        <if test="name != null">name=#{name},</if>
        <if test="email != null">email=#{email},</if>
        <if test="phone != null">phone=#{phone},</if>
    </set>
    where stud_id=#{id}
</update>
```



### foreach元素

```xml
<select id="searchCoursesByTutors" parameterType="map" resultMap="CourseResult">
    SELECT * FROM COURSES
    <if test="tutorIds != null">
        <where>
            <foreach item="tutorId" collection="tutorIds">
                OR tutor_id=#{tutorId}
            </foreach>
        </where>
    </if>
</select>
```

----

## MyBatis食谱

### 处理枚举类

MyBatis默认使用EnumTypeHandler来处理枚举类型,我们不需要做任何配置,我们可以想使用基本数据类型一样的时候枚举类型.

```java
public class Student
{
    private Integer id;
    private String name;
    private String email;
    private PhoneNumber phone;
    private Address address;
    private Gender gender;
    //setters and getters
}
```

```xml
<insert id="insertStudent" parameterType="Student" useGeneratedKeys="true" keyProperty="id">
    insert into students(name,email,addr_id, phone,gender)
    values(#{name},#{email},#{address.addrId},#{phone},#{gender})
</insert>
<!--这样他就会把FEMALE/MALE存在GENDER列中-->
```

如果你想存储枚举类型对应的数字(声明的顺序),而不是名字,那你需要做下面的配置.

你需要在mybatis-config.xml文件中注册EnumOrdinalTypeHandler.

```xml
<typeHandler handler="org.apache.ibatis.type.EnumOrdinalTypeHandler"
javaType="com.mybatis3.domain.Gender"/>
<!--根据声明顺序,这时候0代表FEMALE ,1代表MALE-->
```

### 处理BLOB/CLOB类型

BLOB (binary large object)，二进制大对象. 使用二进制保存数据。 如：保存位图。

CLOB(character large object), 字符大对象. 使用CHAR来保存数据。如：保存XML文档。

```sql
CREATE TABLE USER_PICS
(
    ID INT(11) NOT NULL AUTO_INCREMENT,
    NAME VARCHAR(50) DEFAULT NULL,
    PIC BLOB,
    BIO LONGTEXT,
    PRIMARY KEY (ID)
) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=LATIN1;
```

```java
public class UserPic
{
    private int id;
    private String name;
    // 默认使用String类型处理CLOB,使用byte[]处理BLOB
    private byte[] pic;  
    private String bio;
    //setters & getters
}
```

```xml
<insert id="insertUserPic" parameterType="UserPic">
    INSERT INTO USER_PICS(NAME, PIC,BIO)
    VALUES(#{name},#{pic},#{bio})
</insert>

<select id="getUserPic" parameterType="int" resultType="UserPic">
    SELECT * FROM USER_PICS WHERE ID=#{id}
</select>
```

```java
public void insertUserPic()
{
    byte[] pic = null;
    try {
        File file = new File("C:\\Images\\UserImg.jpg");
        InputStream is = new FileInputStream(file);
        pic = new byte[is.available()];
        is.read(pic);
        is.close();
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    }
    
    String name = "UserName";
    String bio = "put some lenghty bio here";
    UserPic userPic = new UserPic(0, name, pic , bio);
    SqlSession sqlSession = MyBatisUtil.openSession();
    try {
        UserPicMapper mapper =
        sqlSession.getMapper(UserPicMapper.class);
        mapper.insertUserPic(userPic);
        sqlSession.commit();
    }
    finally {
    sqlSession.close();
    }
}
```

```java
public void getUserPic()
{
    UserPic userPic = null;
    SqlSession sqlSession = MyBatisUtil.openSession();
    try {
        UserPicMapper mapper = sqlSession.getMapper(UserPicMapper.class);
        userPic = mapper.getUserPic(1);
    }
    finally {
    sqlSession.close();
    }
    
    byte[] pic = userPic.getPic();
    try {
        OutputStream os = new FileOutputStream(new File("C:\\Images\\UserImage_FromDB.jpg"));
        os.write(pic);
        os.close();
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

### 传递多个参数 (parameters)

有两种方法可以实现传递多个参数.

1. 把所有参数装入HashMap,然后传递给映射语句.

2. 使用#{param}

   ```java
   Public interface StudentMapper
   {
       List<Student> findAllStudentsByNameEmail(String name, String email);
   }
   ```

   ```xml
   <select id="findAllStudentsByNameEmail" resultMap="StudentResult">
       select stud_id, name,email, phone from Students
       where name=#{param1} and email=#{param2}
   </select>
   ```

### Multiple results as a map

```xml
<select id=" findAllStudents" resultMap="StudentResult">
    select * from Students
</select>
```

```java
Map<Integer, Student> studentMap =
sqlSession.selectMap("com.mybatis3.mappers.StudentMapper.findAllStudents", "studId");
// studId作为key
```

### RowBounds Object

RowBounds Object 由offset 和limit两个参数所构造,offset就是起始点,limit就是数目,作用就是从返回的一堆数据中,获取从第offset开始,一共limit行的数据.

```java
int offset =0 , limit =25;
RowBounds rowBounds = new RowBounds(offset, limit);
List<Student> = studentMapper.getStudents(rowBounds);
```

在网络应用程序中,我们一般使用分页的方式来展示大量的数据,我们可以通过该方式实现.

使用offset=25,limit=25来获取第二页的信息.

### 使用ResultSetHandler自定义ResultSet

MyBatis提供了ResultHandler插件,让我们可以自定义ResultSet.

```java
public interface ResultHandler
{
	void handleResult(ResultContext context);
}
```

```java
public Map<Integer, String> getStudentIdNameMap()
{
    final Map<Integer, String> map = new HashMap<Integer, String>();
    SqlSession sqlSession = MyBatisUtil.openSession();
    try {
    	sqlSession.select("com.mybatis3.mappers.StudentMapper.findAllStudents",
    	new ResultHandler() {
            @Override
            public void handleResult(ResultContext context) {
                Student student = (Student) context.getResultObject();
                map.put(student.getStudId(), student.getName());
                }
            }
    	);
    } 
    finally {sqlSession.close();}
    return map;
}
```

### Cache

MyBatis自带支持缓存select语句获取的结果.默认激活一级缓存,就是如果你在同一个SqlSession接口中,调用同一个select语句,那么结果是从缓存中获取,而不是从数据库中获取的.

我们可以在映射文件中使用<cache/>元素,添加全局二级缓存.

映射文件中所有select语句获取的结果都会被缓存.

所有的insert  update delete语句都会刷新缓存.

```xml
<select ... flushCache="false" useCache="true"/>
<insert ... flushCache="true"/>
<update ... flushCache="true"/>
<delete ... flushCache="true"/>
```

MyBatis使用LRU(Least Recently Used最近用的最少)算法来清理缓存.

缓存会存储1024个列表/对象.

读取到的缓存数据可以安心修改,不会影响缓存.

你可以通过重写属性来自定义缓存行为.

```xml
<cache eviction="FIFO" flushInterval="60000" size="512" readOnly="true"/>
```

eviction(逐出):默认LRU (least recently used),可选 FIFO(first in first out),SOFT(soft reference), WEAK(weak reference)

flushInterval(刷新间隔).  size最大缓存数. readOnly只读.返回同一个对象.

缓存配置以及缓存对象绑定到SQL映射文件的命令空间.因此所有与缓存相同的命令空间表中的所有语句都由它绑定.

---

## 自定义SQL元素

### 定义sql元素

```xml
<sql id="userColumns"> ${alias}.id,${alias}.username,${alias}.password </sql>
```

### 使用sql元素

```xml
<select id="selectUsers" resultType="map">
  select
    <include refid="userColumns"><property name="alias" value="t1"/></include>,
    <include refid="userColumns"><property name="alias" value="t2"/></include>
  from some_table t1
    cross join some_table t2
</select>
```







## 自动映射