# MyBatis的配置

MyBatis的配置文件对整个MyBatis系统具有深远的影响,接下来我们详细了解MyBatis的配置.

下面是MyBatis XML配置文件的层次结构

**注意：元素的定义的顺序不能颠倒**

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
  PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
	<properties></properties> <!--属性-->
    <settings></settings> <!--设置-->
    <typeAliases></typeAliases> <!--命名类型-->
    <typeHandler></typeHandler> <!--类型处理器-->
    <objectFactory></objectFactory> <!--对象工厂-->
    <plugins></plugins> <!--插件-->
    <environments> 
        <environment>
            <transactionManager></transactionManager>
            <dataSource></dataSource>
        </environment>
    </environments>
    <databaseIdProvider></databaseIdProvider> <!--数据库厂商标识-->
    <mappers></mappers> <!--映射器-->
</configuration>
```



## Properties元素

Properties元素有两个作用

1.获取外部属性文件的内容

2.定义属性配置

配置属性后，就可以在配置文件中替换需要动态配置的属性值。 

### property子元素

```xml
<properties>
  <property name="username" value="hdr"/>     <!--自定义属性配置-->
  <property name="password" value="admin"/>     <!--自定义属性配置-->
</properties>
```

### properties配置文件

```xml
<properties resource="config.properties">     <!---通过resource属性引用外部文件-->
</properties>
```

### 程序传递参数

XXXXXX

### 优先级

propertie子元素的内容先背读取,然后再读取resource属性引入的properties文件,最后才是读取作为方法参数传递的属性.

如果由相同的属性,后者会覆盖前者.

## Settings元素

Settings的配置内容如下表所示,配置不需要修改太多,未来我们还会再接触,这里有点印象即可.

| 设置参数                  | 描述                                           | 有效值            | 默认值  |
| ------------------------- | ---------------------------------------------- | ----------------- | ------- |
| cacheEnabled              | 映射器中缓存配置的全局开关                     | true / false      | true    |
| lazyLoadingEnabled        | 对象延迟加载的全局开关,可通过fetchType属性覆盖 | true / false      | false   |
| aggressiveLazyLoding      |                                                | true / false      | true    |
| multipleResultSetsEnabled | 是否允许单一语句返回多结果集(需要兼容驱动)     | true / false      | true    |
| useColumnLabel            | 使用标签代替列名                               | true / false      | true    |
| useGeneratedKeys          | 允许JDBC支持自动生成主键                       | true / false      | true    |
| autoMappingBehavior       | 指定MyBatis如何自动映射列到字段(属性)          | NONE PRATIAL FULL | PARTIAL |
| defaultExecutorType       |                                                |                   |         |
| defaultStatementTimeout   |                                                |                   |         |
| safeRowBoundsEnabled      | 允许在嵌套语句中使用分页                       |                   |         |
| mapUnderscoreToCamelCase  | 开启驼峰命名规则映射                           | true / false      | false   |
| localCacheScope           |                                                |                   |         |
| jdbcTypeForNull           |                                                |                   |         |
| lazyLoadTriggerMethods    |                                                |                   |         |
| defaultScriptingLanguage  |                                                |                   |         |
| callSettersOnNulls        |                                                |                   |         |
| logPrefix                 |                                                |                   |         |
| logImpl                   |                                                |                   |         |
| proxyFactory              |                                                |                   |         |

## typeAliases

类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。 

### 定义typeAliases

```xml
<typeAliases>
  <typeAlias alias="User" type="com.hdr.mybatisDemo.domain.User"/> 
  <!---这时候User代表com.hdr.mybatisDemo.domain.User-->
  <package name="com.hdr.mybatisDemo.domain"/>
  <!--指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean-->
</typeAliases>
```

**注意：**

指定包中Java Bean，如果没有注解则使用 Bean 的首字母小写的非限定类名来作为它的别名。 

 比如 com.hdr.mybatisDemo.beans.User 的别名为 `user`；

若有注解，则别名为其注解值。看下面的例子： 

```java
@Alias("User")
public class Author {
    ...
}
```

MyBatis默认实现了一些类型别名，具体请看 [别名](http://www.mybatis.org/mybatis-3/zh/configuration.html#typeAliases)。

### 使用typeAliases

```xml
<update id="update" parameterType="User">
    update tb_user
    set
    username = #{userName} ,
    password = #{password},
    age=#{age}
    where username=#{userName}
</update>
```

------

MyBatis通过对JDBC进行抽象，从而大大简化我们对持久层的操作。

下面我们通过一个例子来看看这个过程是怎么实现的。

```xml
<insert id="insertStudent" parameterType="Student">
	INSERT INTO STUDENTS(STUD_ID,NAME,EMAIL,DOB)
	VALUES(#{id},#{name},#{email},#{dob})
</insert>
```

1. MyBatis会创建一个PreparedStatement接口如下

   ```java
   PreparedStatement pstmt = connection.prepareStatement
   ("INSERT INTO STUDENTS(STUD_ID,NAME,EMAIL,DOB) VALUES(?,?,?,?)");
   ```

2. 检查传递过来的属性(studentId name email)的数据类型，然后调用相应的setXXX（）方法

   ```java
   pstmt.setInt(1,student.getId());
   pstmt.setString(2, student.getName());
   pstmt.setString(3, student.getEmail());
   pstmt.setTimestamp(4, new Timestamp((student.getDob()).getTime()));
   ```

不错吧~ MyBatis真的能让我们少写点代码呢~

看了上面的例子，你可能会有点疑问，所有的数据类型都能被处理吗？

不是的，MyBatis内部定义了一些类型处理器，可以处理byte[], java.util.Date, java.sql.Date, java.sql.Time, java.
sql.Timestamp, java enums,等等。如果要处理其它类型，那么就需要你自己实现一个Type handler。

### 重写或自定义type handler

重写或自定义类型处理器有两种方法：

- 实现 `org.apache.ibatis.type.TypeHandler` 接口
- 继承 `org.apache.ibatis.type.BaseTypeHandler`类， 然后可以选择性地将它映射到一个 JDBC 类型。 

**假设我们现在处于这种状态**

```java
public class Student
{
    private Integer id;
    private String name;
    private String email;
    private PhoneNumber phone;  
    // Setters and getters
}
```

```java
public class PhoneNumber
{
    private String countryCode;
    private String stateCode;
    private String number;
    
    public PhoneNumber() {}
    
    public PhoneNumber(String countryCode, String stateCode, String number) {
        this.countryCode = countryCode;
        this.stateCode = stateCode;
        this.number = number;
    }
    public PhoneNumber(String string) {
        if(string != null){
        	String[] parts = string.split("-");
            if(parts.length>0) this.countryCode=parts[0];
            if(parts.length>1) this.stateCode=parts[1];
            if(parts.length>2) this.number=parts[2];
        }
	}
    public String getAsString() {
		return countryCode+"-"+stateCode+"-"+number;
    }
    // setters and getters
}
```

很明显，Student类型中的phone字段是一种自定义的类型，要存储该类型，我们就要为她实现type handler

```java
// ExampleTypeHandler.java
/*
  MyBatis提供了两种途径，让我们指定被关联的 JDBC 类型
  ① 在配置文件typeHandler元素上增加一个jdbcType属性（比如：jdbcType="VARCHAR"）；
  ② 给TypeHandler类增加一个 @MappedJdbcTypes 注解来指定与其关联的JDBC类型列表。
    如果同时使用，前者会覆盖后者。
*/
@MappedJdbcTypes(JdbcType.VARCHAR)
/*
 根据泛型，MyBatis 可以得知该类型处理器处理的 Java 类型。
 MyBatis还另外提供了两种做法，可以让我们实现相同的效果。
 ① 在配置文件typeHandler元素上增加一个 javaType 属性（比如：javaType="String"）；
 ② 给TypeHandler类增加一个 @MappedTypes 注解来指定与其关联的 Java 类型列表。
   如果同时使用，前者会覆盖后者。
*/
public class PhoneTypeHandler extends BaseTypeHandler<PhoneNumber>{
    
    @Override
    public void setNonNullParameter(PreparedStatement ps , int i , 
                                    PhoneNumber parameter ,JdbcType jdbcType) 
    throws SQLException{
        ps.setString(i,parameter.getAsString());
    }
    
    @Override
    public PhoneNumber getNullableResult(Result rs, String columnName) 
    throws SQLException{
        return new PhoneNumber(rs.getString(columnName));
    }
    @Override
	public PhoneNumber getNullableResult(ResultSet rs, int columnIndex)
    throws SQLException {
		return new PhoneNumber(rs.getString(columnIndex));
	}
    @Override
    public PhoneNumber getNullableResult(CallableStatement cs, int columnIndex)
    throws SQLException{
    	return new PhoneNumber(cs.getString(columnIndex));
    }
    
}
```

**注册type handler**

```xml
<!-- mybatis-config.xml -->
<typeHandlers>
  <typeHandler handler="com.hdr.mybatisDemo.typeHandler.PhoneTypeHandler"/>
  <package name="com.hdr.mybatisDemo.typeHandler"/>
  <!--指定一个包名，MyBatis 会在包名下面搜索需要的类型处理器-->
</typeHandlers>
```

**补充：使用一个type handler 处理多个自定义java类**

```java
//GenericTypeHandler.java
public class GenericTypeHandler<E extends MyObject> extends BaseTypeHandler<E> {
/*
  为了使用泛型类型处理器， 需要增加一个接受该类的class作为参数的构造器，
  这样在构造一个类型处理器的时候 MyBatis 就会传入一个具体的类。
*/
  private Class<E> type;

  public GenericTypeHandler(Class<E> type) {
    if (type == null) throw new IllegalArgumentException("Type argument cannot be null");
    this.type = type;
  }
```

------

### 枚举类型typeHandler

MyBatis内部提供了两个typeHandler给我们处理枚举类

- org.apache.ibatis.EnumTypeHandler            使用枚举名称作为参数传递
- org.apache.ibatis.EnumOrinalTypeHandler   使用整数下标作为参数传递

如果上面两个typeHandler不能满足我们的需求，我们还能自定义typeHandler

```java
public enum Gender {
   MALE(1, "男"), FEMALE(2, "女");
   private int id;
   private String string;

   private Gender(int id, String string) {
      this.id = id;
      this.string = string;
   }

   public static Gender getGender(int id) {
      if (id == 1) {return MALE;} 
      else if (id == 2) {return FEMALE;} 
      else {return null;}
   }
    
    // getter setter
}
```

#### EnumOrinalTypeHandler

**注册typeHandler**

```xml
<typeHandler handler="org.apache.ibatis.type.EnumOrdinalTypeHandler" 
             javaType="com.hdr.learn.mybatis.enums.Gender"/>
```

**使用typeHandler**

```xml
<result column="gender" property="gender" 
        typeHandler="org.apache.ibatis.type.EnumOrdinalTypeHandler" />
```

#### EnumTypeHandler 

```xml
<result column="gender" property="gender" 
        typeHandler="org.apache.ibatis.type.EnumTypeHandler" />
```

#### 自定义TypeHandler

参考上面的自定义typeHandler

## ObejctFactory

当MyBatis在构建一个结果返回的时候，会使用ObjectFactory去构建POJO。

一般来说，我们使用MyBatis提供的ObjectFactory即可，但是我们也能自定义ObjectFactory

## 插件

插件很强大，但是也很复杂，在没有很好了解MyBatis的运行原理之前，我们还无法讨论它。

## environments

environments元素下可以编写一到多个environment元素。（注意有s和没有s）

一个environment元素可以粗略看做一个数据库。

```xml
<environments default="development">
	<environment id="development">
     	<transactionManager type="JDBC"/>
     	<dataSource type="POOLED">
        	<property name="driver" value="com.mysql.jdbc.Driver"/>
            <property name="url" value="jdbc:mysql://127.0.0.1:3306/mybatis3"/>
            <property name="username" value="root"/>
            <property name="password" value="admin"/>
        </dataSource>
    </environment>
    
</environments>
```

### default="shoppingcart"

你可以看到environments元素有个default的属性，这是干嘛用的呢？

其实，在我们build一个SqlSessionFactory的时候，是要指定使用哪一个environment元素中的配置信息。

```java
SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader,"development");
```

但是我们之前例子并没有传递这个值的呀，不也是可以吗？

```java
SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader);
```

这是因为default属性在暗中帮助呢

default属性的作用就是，设置默认使用哪一个environment元素的配置信息建立SqlSessionFactory对象。

### transactionManager 与 dataSource

我们可以看到，environment元素具有两个子元素，分别是transactionManager 与 dataSource。

#### transactionManager元素 

MyBatis支持两种类型的事务管理器，分别是JDBC和MANAGED。

**什么是事务管理?**

事务管理是对于一系列数据库操作进行管理，一个事务包含一个或多个[SQL](https://baike.baidu.com/item/SQL)语句，是逻辑管理的工作单元 。事务中的SQL语句，如果有任何一条出现异常，那么回滚之前的所有操作。这样可以防止出现脏数据，防止数据库数据出现问题。

- JDBC – 这个配置就是直接使用了 JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。
- MANAGED – 这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期。     默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。

**补充**：

1. 在JDBC中是通过Connection对象进行事务管理的，默认是自动提交事务，可以手工将自动提交关闭，关闭后需要通过commit方法进行提交，rollback方法进行回滚，如果不提交，则数据不会真正的插入到数据库中。
2. 如果你正在使用 Spring + MyBatis，则没有必要配置事务管理器， 因为 Spring 模块会使用自带的管理器来覆盖前面的配置。 

#### dataSource

dataSource元素是用来配置连接数据库的属性的。

```xml
<dataSource type="JNDI">
	<property name="data_source" value="java:comp/jdbc/ShoppingcartDS"/>
</dataSource>
```

dataSource元素的type属性具有三个值，分别是UNPOOLED, POOLED, JNDI。

UNPOOLED- 对于每次数据库操作，MyBatis会打开一个新的session执行数据库操作，操作完成后关闭session。

POOLED- MyBatis会创建一个数据库连接池，要对数据库进行操作就从这个池里获取连接对象。（一般用于研发和测试）

JNDI- MyBatis通过JDNI获取连接，生产环境中最好使用它。

补充：JNDI API 允许java软件客户端，通过名称发现和查找数据和资源。

## Mappers元素

Mappers元素是用来对Mapper XML文件进行定位的。

```xml
<mappers>
    <!-- 使用相对于类路径的资源引用 -->
  <mapper resource="org/mybatis/builder/AuthorMapper.xml"/>
    <!-- 使用完全限定资源定位符（URL） -->
  <mapper url="file:///var/mappers/BlogMapper.xml"/>
    <!-- 使用映射器接口实现类的完全限定类名 -->
  <mapper class="org.mybatis.builder.PostMapper"/>
    <!-- 将包内的映射器接口实现全部注册为映射器 -->
  <package name="org.mybatis.builder"/>
</mappers>
```

## 