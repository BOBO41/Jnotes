---
title : 3.深入Spring Bean
categories : 
- JavaWeb
- Spring
date : 2018-7-11
---

# 1.给容器注入Bean

## @Configuration与@Bean

Spring IoC容器管理一到多个Bean.我们在配置元数据中对Bean进行定义。

@Configuration修饰的类就是配置类，是配置元数据的一种。

```java
@Configuration
public class AppConfig  {
    @Bean
    public Student student(){
        return new Student();
    }
}
```

上面的例子创建了一个Bean，Bean的名字是student。

Spring容器内部使用BeanDefinition对象来代表这些Bean。[BeanDefinition API](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/config/BeanDefinition.html)

Spring容器允许用户在运行期间往容器添加Bean，原理是通过`getBeanFactory`方法获取容器，然后再调用容器的registerXXX方法。

## @ComponentScan与@Component

@ComponentScan:扫描组件  

```java
@ComponentScan（value="com.hdr", includeFilters = {
    @Filter(type=FilterType.ANNOTATION,classes={Controller.class}),
    @Filter(type=FilterType.ASSIGNABLE_TYPE,classes={BookService.class})
}）
```

@Component:组件 

### @Controller @Service @Repository

上面三种注解都是用来注册Bean的,分表代表表现层的Bean,业务层的Bean,持久层的Bean.

查看源码会发现，这三个注解都是组合了@Component的。

## @Conditional

制定条件，满足条件的Bean才注入容器

```java
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Conditional {

   /**
    * All {@link Condition Conditions} that must {@linkplain Condition#matches match}
    * in order for the component to be registered.
    */
   Class<? extends Condition>[] value();

}
```

可以看到该注解需要一个`Condition`类型的数组

```java
@FunctionalInterface
public interface Condition {

   /**
    * Determine if the condition matches.
    * @param context the condition context
    * @param metadata metadata of the {@link org.springframework.core.type.AnnotationMetadata class}
    * or {@link org.springframework.core.type.MethodMetadata method} being checked
    * @return {@code true} if the condition matches and the component can be registered,
    * or {@code false} to veto the annotated component's registration
    */
   boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata);

}
```

## @Import

### 1.导入@Configuration类

### 2.导入ImportSelector类

该接口的实现类需要实现`selectImports`方法，该方法返回一个字符串数组，该数组的元素是需要导入到容器中的bean的全类名。

```java
public class MyImportSelector implements ImportSelector {
	@Override
	public String[] selectImports(AnnotationMetadata importingClassMetadata) {
		return new String[]{"com.hdr.learn.spring.bean.CustomManager"};
	}
}
```

### 3.导入ImportBeanDefinitionRegistrar类

该接口的实现类需要实现`registerBeanDefinitions`方法，该方法直接把Bean注册进容器。

```java
public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {

   @Override
   public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, 
                                       BeanDefinitionRegistry registry) {
      RootBeanDefinition beanDefinition = new RootBeanDefinition(CustomManager.class);
      registry.registerBeanDefinition("MyCustomManager",beanDefinition);
   }
}
```

## FactoryBean

把该接口的实现类注册为Bean，从容器中获取到的Bean，不是该Bean，而是该实现类的`getObject`方法返回的对象。

```java
public class CustomManagerFactoryBean implements FactoryBean {
   @Override
   public Object getObject() throws Exception {
      return new CustomManager();
   }

   @Override
   public Class<?> getObjectType() {
      return CustomManager.class;
   }
}
```

## @ImportResource

导入XML配置

```java
@ImportResource("classpath:/com/acme/properties-config.xml")
```

# 2.Bean的属性

## Bean的命名与描述

```java
@Configuration
public class AppConfig {
    @Bean(name = "myThing")
    public Thing thing() {
        return new Thing();
    }
    @Bean(name = { "dataSource", "subsystemA-dataSource", "subsystemB-dataSource" })
    public DataSource dataSource() {
        // instantiate, configure and return DataSource bean...
    }
    @Bean
    @Description("Provides a basic example of a bean")
    public Thing thing() {
        return new Thing();
    }
}
```

## Bean的作用域

- singleton   单例
- prototype   原型
- request      请求
- session      会话
- application  应用 
- webSocket

```java
@Bean
@Scope(SCOPE_PROTOTYPE)  // 默认singleton
// ConfigurableBeanFactory.SCOPE_PROTOTYPE, ConfigurableBeanFactory.SCOPE_SINGLETON, WebApplicationContext.SCOPE_REQUEST, WebApplicationContext.SCOPE_SESSION,
public Wheel wheel() {
   return new Wheel();
}
@RequestScope
@SessionScope
@ApplicationScope
```

## Bean的生命周期回调

### 1.initMethod与destroyMethod

```java
public class Bean {

    public void init() {
        // initialization logic
    }
    
    public void cleanup() {
        // destruction logic
    }
}

@Configuration
public class AppConfig {

    @Bean(initMethod = "init",destroyMethod = "cleanup")
    public Bean bean() {
        return new Bean();
    }

}
```

### 2.InitializingBean与DisposableBean

```java
public interface InitializingBean {
   void afterPropertiesSet() throws Exception;
}
public interface DisposableBean {
	void destroy() throws Exception;
}
```

### 3.@PostConstruct 与 @PreDestroy

在Spring中，你可以通过`InitializingBean` 和 `DisposableBean` 接口或者在配置Bean的时候指定`initMethod`和`destroyMethod`来实现Bean初始化和销毁时调用指定的回调函数。

@PostConstruct 和 @PreDestroy也具有同样的作用

```java
public class CustomerService
{
	String message;
	
	public String getMessage() {
	  return message;
	}

	public void setMessage(String message) {
	  this.message = message;
	}
	
	@PostConstruct
	public void initIt() throws Exception {
	  System.out.println("Init method after properties are set : " + message);
	}
	
	@PreDestroy
	public void cleanUp() throws Exception {
	  System.out.println("Spring Container is destroy! Customer clean up");
	}
	
}
```

### 4.BeanPostProcessor

```java
public interface BeanPostProcessor {
   // 在实例化回调之前工作
   @Nullable
   default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
      return bean;
   }
   // 在实例化回调之后工作
   @Nullable
   default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
      return bean;
   }
   // 实例化回调，就是上面的initMethod、@PostConstruct、InitializingBean
}
```

## @Lazy

懒加载，在有在需要用到这个Bean的时候，才初始化这个Bean。

# 3.Bean的组装

```java
@Bean
public Wheel wheel() {
	return new Wheel();
}

@Bean
public Car car(Wheel wheel) { // 通过方法参数的方式获取依赖,一般用于从容器中获取依赖
	Car car = new Car();
	car.setWheel(wheel);
	return car;
}	

@Bean
public Car car() {
	Car car = new Car();
    // 通过调用方法的方式获取依赖,一般是调用配置类中的其他创建Bean的方法,而且返回的还是同一个对象。
	car.setWheel(wheel());
	return car;
}
```
### lookup-method







