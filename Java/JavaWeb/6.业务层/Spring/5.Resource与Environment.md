---
title : 5.Environments
categories : 
- JavaWeb
- Spring
date : 2018-7-15
---

# Environment

Environment接口是profiles和properties的抽象.

profiles是仅在给定配置文件处于活动状态时才向容器注册的Bean定义的命名逻辑组。

properties(属性)几乎在所有应用程序中都发挥着重要作用，这些属性可能来自于：属性文件，JVM系统属性，系统环境变量，JNDI，servlet上下文参数，ad-hoc属性对象，Map对象等。 与属性相关的Environment对象的作用是为用户提供方便的服务接口，用于配置和解析属性源。

## profiles

Bean definition peofiels提供了一种机制,可以让容器根据不同环境创建不同的Bean.

最常见的用法就有dataSource的配置,一般在研发时候和正式生产时候,dataSource是不同.

```java
@Bean
public DataSource dataSource() {
    return new EmbeddedDatabaseBuilder()
        .setType(EmbeddedDatabaseType.HSQL)
        .addScript("my-schema.sql")
        .addScript("my-test-data.sql")
        .build();
}
```

```java
@Bean(destroyMethod="")
public DataSource dataSource() throws Exception {
    Context ctx = new InitialContext();
    return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
}
```

现在的问题是如何在不同环境注册不同的Bean.

### @Profile

为了解决上述问题,我们需要使用@Profile注解.

```java
@Bean
@Profile("development")
public DataSource dataSource() {
    return new EmbeddedDatabaseBuilder()
        .setType(EmbeddedDatabaseType.HSQL)
        .addScript("my-schema.sql")
        .addScript("my-test-data.sql")
        .build();
}
```

```java
@Bean
@Profile("production")
public DataSource dataSource() throws Exception {
    Context ctx = new InitialContext();
    return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
}
```

@Profile不仅可以修饰Bean,也可以修饰@Configuration类

### 激活Profile

现在我们已经配置好Profile了,那么启动的时候,我们就需要告诉Spring,需要使用哪个Profile.

```java
AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
ctx.getEnvironment().setActiveProfiles("development");
ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);
ctx.refresh();
```

### 默认 Profile

```java
@Configuration
@Profile("default")
public class DefaultDataConfig {

    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript("classpath:com/bank/config/sql/schema.sql")
            .build();
    }
}
```

## Property

Spring的Environment抽象提供了搜索配置源内容的操作.

```java
ApplicationContext ctx = new GenericApplicationContext();
Environment env = ctx.getEnvironment();
boolean containsMyProperty = env.containsProperty("my-property");
System.out.println("Does my environment contain the 'my-property' property? " + containsMyProperty);
```

上面的例子,我们问Spring我们是否定义了my-property属性.为了回答这个问题,Spring会去搜索一系列的PropertySource对象.PropertySource对象就是键值对属性源的简单抽象.Spring的`StandardEnvironment`配置了两个PropertySource对象,一个是JVM系统属性,一个是系统环境变量.

最重要的是，整个机制是可配置的。 您可能希望将自定义的属性源集成到此搜索中。 为此，请实现并实例化您自己的PropertySource，并将其添加到当前Environment的PropertySource集合中。 以下示例显示了如何执行此操作：

```java
ConfigurableApplicationContext ctx = new GenericApplicationContext();
MutablePropertySources sources = ctx.getEnvironment().getPropertySources();
sources.addFirst(new MyPropertySource());
```

### @PropertySource

@PropertySource提供了简洁明了的机制往Spring的Evironment中添加PropertySource.

```java
@Configuration
@PropertySource("classpath:/com/myco/app.properties")
// 写得多往往会分不清到底用/还是用.  路径的分割当然就是用/啦
public class AppConfig {

    @Autowired
    Environment env;

    @Bean
    public TestBean testBean() {
        TestBean testBean = new TestBean();
        testBean.setName(env.getProperty("testbean.name"));
        return testBean;
    }
}
```

@PropertySource资源位置中存在的任何$ {...}占位符将根据已针对环境注册的属性源集合进行解析，如以下示例所示：

```java
@Configuration
@PropertySource("classpath:/com/${my.placeholder:default/path}/app.properties")
// 为什么使用 ${}作为表达式? 因为Linux就是如此.
public class AppConfig {

    @Autowired
    Environment env;

    @Bean
    public TestBean testBean() {
        TestBean testBean = new TestBean();
        testBean.setName(env.getProperty("testbean.name"));
        return testBean;
    }
}
```



# Resources

Java的 java.net.URL类不好用,所以Spring团队编写了获取资源的相关代码.

## Resource接口

Spring的Resource接口旨在成为一个功能更强的接口，用于抽象对低级资源的访问。 以下清单显示了Resource接口定义：

```java
public interface Resource extends InputStreamSource {
    boolean exists(); // 判断资源是否真实存在
    boolean isOpen(); // 判断资源是否已被打开
    String getDescription(); // 返回资源的描述.
    URL getURL() throws IOException;
    File getFile() throws IOException;
    String getFilename();
    Resource createRelative(String relativePath) throws IOException;
}
```

我们可以看到Resource接口继承了InputStreamSource类

```java
public interface InputStreamSource {
    InputStream getInputStream() throws IOException;
   // 找到并打开资源，返回InputStream。 希望每次调用都会返回一个新的InputStream。 呼叫者有责任关闭流。
}
```

**Spring中获取资源的方式一共有以下四种：**

- 通过Resource接口实现类获取资源
- 通过ResourceLoader接口获取资源
- 通过ApplicationContext获取资源
- 将resource注入到bean中的方式获取资源



## Resouce接口实现类

### UrlResouce

UrlResource包装java.net.URL，可以通过URL访问对象，例如文件，HTTP目标，FTP目标等。所有URL都具有标准化的字符串表示，以便使用适当的标准化前缀来指示另一个URL类型。这包括文件：用于访问文件系统路径，http：用于通过HTTP协议访问资源，ftp：用于通过FTP访问资源，以及其他。

UrlResource由Java代码通过显式使用UrlResource构造函数创建，但通常在调用采用String参数表示路径的API方法时隐式创建。对于后一种情况，JavaBeans PropertyEditor最终决定要创建哪种类型的Resource。如果路径字符串包含众所周知的（对于它，那么）前缀（例如classpath :)，它会为该前缀创建适当的专用资源。但是，如果它无法识别前缀，则假定该字符串是标准URL字符串并创建UrlResource。

### ClassPathResource

该类表示从类路径获取的资源。 它使用线程上下文类加载器，给定的类加载器或给定的类来加载资源。

如果类路径资源驻留在文件系统中，而不是驻留在jar中且尚未（通过servlet引擎或任何环境）扩展到文件系统的类路径资源，则此Resource实现支持解析为java.io.File。为了解决这个问题，各种Resource实现始终支持作为java.net.URL的解析。

ClassPathResource是由Java代码通过显式使用ClassPathResource构造函数创建的，但通常在调用采用String参数表示路径的API方法时隐式创建。 对于后一种情况，JavaBeans PropertyEditor在字符串路径上识别特殊前缀classpath：，并在该情况下创建ClassPathResource。

### FileSystemResource

这是用来处理java.io.File的

### ServletContextResource

这是用来处理ServletContext资源的Resource实现类,用于解释相关Web应用程序根目录中的相对路径。

它始终支持流访问和URL访问，但只有在扩展Web应用程序存档且资源实际位于文件系统上时才允许java.io.File访问。 它是否在文件系统上扩展或直接从JAR或其他地方（如数据库）访问它实际上取决于Servlet容器.

### InputStreamResource

InputStreamResource是给定InputStream的Resource实现。 仅在没有适用的特定资源实现时才应使用它。 特别是，在可能的情况下，更喜欢ByteArrayResource或任何基于文件的资源实现。

与其他资源实现相比，这是已打开资源的描述符。 因此，它从isOpen（）返回true。 如果需要将资源描述符保留在某处或者需要多次读取流，请不要使用它。

### ByteArrayResource

这是给定字节数组的Resource实现。 它为给定的字节数组创建一个ByteArrayInputStream。

它对于从任何给定的字节数组加载内容非常有用，而无需使用一次性使用的InputStreamResource。

## 资源加载器 ResourceLoader

Spring框架为了更方便的获取资源，尽量弱化程序员对各个Resource接口的实现类的感知，定义了另一个ResourceLoader接口。

```java
public interface ResourceLoader {
    Resource getResource(String location);
}
```

该接口的getResource(String location)方法可以用来获取资源。它的DefaultResourceLoader实现类可以适用于所有的环境，可以返回ClassPathResource、UrlResource等。

ResourceLoader在进行加载资源时需要使用前缀来指定需要加载：

- `classpath:`表示返回ClasspathResource
- `http:和`file:`表示返回UrlResource资源
- 如果不加前缀则需要根据当前上下文来决定，

所有的ApplicationContext都实现了ResourceLoader,因此可以从中获取资源实例.

如果调用ApplicationContext的getResource()方法指定的位置路径没有特定前缀时，将返回适合该特定应用程序上下文的Resource类型。例如，假设针对ClassPathXmlApplicationContext实例执行了以下代码片段：

```java
Resource template = ctx.getResource("some/resource/path/myTemplate.txt");
```

针对ClassPathXmlApplicationContext，该代码返回ClassPathResource。 如果对FileSystemXmlApplicationContext实例执行相同的方法，它将返回FileSystemResource。 对于WebApplicationContext，它将返回ServletContextResource。

因此，您可以以适合特定应用程序上下文的方式加载资源。

另一方面，您可以通过指定特殊的classpath：前缀来强制使用ClassPathResource，而不管应用程序上下文类型如何，如下例所示：

```java
Resource template = ctx.getResource("classpath:some/resource/path/myTemplate.txt");
```

同样，您可以通过指定任何标准java.net.URL前缀来强制使用UrlResource。 以下对示例使用文件和http前缀：

```java
Resource template = ctx.getResource("file:///some/resource/path/myTemplate.txt");
```

```java
Resource template = ctx.getResource("http://myhost.com/resource/path/myTemplate.txt");
```

### ResourceLoaderAware

XXXAware接口意味着这个接口的实现类可以感知、获取到XXX，换言之也就是它能提供XXX。

由上述可知ResourceLoaderAware接口的实现类就是用来提供ResourceLoader的。

```java
public interface ResourceLoaderAware {
    void setResourceLoader(ResourceLoader resourceLoader);
}
```

当类实现ResourceLoaderAware并部署到应用程序上下文（作为Spring管理的bean）时，它被应用程序上下文识别为ResourceLoaderAware。然后，应用程序上下文调用setResourceLoader（ResourceLoader），将其自身作为参数提供（请记住，Spring中的所有应用程序上下文都实现了ResourceLoader接口）。

由于ApplicationContext是ResourceLoader，因此bean还可以实现ApplicationContextAware接口并直接使用提供的应用程序上下文来加载资源。但是，一般情况下，如果您需要，最好使用专用的ResourceLoader接口。代码只能耦合到资源加载接口（可以被认为是实用程序接口）而不是整个Spring ApplicationContext接口。

从Spring 2.5开始，您可以依赖ResourceLoader的自动装配作为实现ResourceLoaderAware接口的替代方法。 “传统”构造函数和byType自动装配模式（如自动装配协作者中所述）现在能够分别为构造函数参数或setter方法参数提供ResourceLoader类型的依赖性。为了获得更大的灵活性（包括自动装配字段和多参数方法的能力），请考虑使用基于注释的自动装配功能。在这种情况下，只要有问题的字段，构造函数或方法带有@Autowired注释，ResourceLoader就会自动装入一个字段，构造函数参数或方法参数，这些参数需要ResourceLoader类型。有关更多信息，请参阅使用@Autowired。

## 作为依赖的资源

如果bean本身将通过某种动态过程确定并提供资源路径，那么bean使用ResourceLoader接口加载资源可能是有意义的。 例如，考虑加载某种模板，其中所需的特定资源取决于用户的角色。 如果资源是静态的，那么完全消除ResourceLoader接口的使用是有意义的，让bean公开它需要的Resource属性，并期望将它们注入到它中。

然后注入这些属性变得微不足道的是，所有应用程序上下文都注册并使用特殊的JavaBeans PropertyEditor，它可以将String路径转换为Resource对象。 因此，如果myBean具有Resource类型的模板属性，则可以使用该资源的简单字符串进行配置，如以下示例所示：

```java
<bean id="myBean" class="...">
    <property name="template" value="some/resource/path/myTemplate.txt"/>
</bean>
```

请注意，资源路径没有前缀。 因此，因为应用程序上下文本身将用作ResourceLoader，所以资源本身通过ClassPathResource，FileSystemResource或ServletContextResource加载，具体取决于上下文的确切类型。

如果需要强制使用特定的资源类型，则可以使用前缀。 以下两个示例显示如何强制ClassPathResource和UrlResource（后者用于访问文件系统文件）：

```java
<property name="template" value="classpath:some/resource/path/myTemplate.txt">
<property name="template" value="file:///some/resource/path/myTemplate.txt"/>
```

## application context与resource path

本节介绍如何使用资源创建应用程序上下文，包括使用XML的快捷方式，如何使用通配符以及其他详细信息。

### 构造application context

应用程序上下文构造函数（对于特定的应用程序上下文类型）通常将字符串或字符串数组作为资源的位置路径，例如构成上下文定义的XML文件。

当这样的位置路径没有前缀时，从该路径构建并用于加载bean定义的特定资源类型取决于并且适合于特定的应用程序上下文。 例如，请考虑以下示例，该示例创建ClassPathXmlApplicationContext：

```java
ApplicationContext ctx = new ClassPathXmlApplicationContext("conf/appContext.xml");
```

```java
ApplicationContext ctx = new FileSystemXmlApplicationContext("conf/appContext.xml");
```

```java
ApplicationContext ctx = 
    new FileSystemXmlApplicationContext("classpath:conf/appContext.xml");
```

### 构造ClassPathXmlApplicationContext对象

ClassPathXmlApplicationContext提供了许多构造函数，以便于实例化。 基本思想是，您只能提供一个字符串数组，该数组只包含XML文件本身的文件名（没有前导路径信息），并且还提供一个Class。 然后，ClassPathXmlApplicationContext从提供的类派生路径信息。

考虑以下目录结构

```
com/
  foo/
    services.xml
    daos.xml
    MessengerService.class
```

以下示例显示如何实例化由名为services.xml和daos.xml（位于类路径中）的文件中定义的bean组成的ClassPathXmlApplicationContext实例：

```java
ApplicationContext ctx = new ClassPathXmlApplicationContext(
    new String[] {"services.xml", "daos.xml"}, MessengerService.class);
```

See the [`ClassPathXmlApplicationContext` Javadoc](https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/javadoc-api/org/springframework/jca/context/SpringContextResourceAdapter.html) for details on the various constructors.

### Application Context构造器资源路径通配符

应用程序上下文构造函数值中的资源路径可以是简单路径（如前所示），每个路径都与目标资源进行一对一映射，或者可以包含特殊的“classpath *：”前缀或内部Ant样式的正则表达式（使用Spring的PathMatcher实用程序进行匹配）。后者都是有效的通配符。

此机制的一个用途是在需要进行组件样式的应用程序组装时。所有组件都可以将上下文定义片段“发布”到一个众所周知的位置路径，并且当使用前缀为classpath *的相同路径创建最终应用程序上下文时，将自动拾取所有组件片段。

请注意，此通配符特定于在应用程序上下文构造函数中使用资源路径（或直接使用PathMatcher实用程序类层次结构时），并在构造时解析。它与资源类型本身无关。您不能使用classpath *：前缀来构造实际的Resource，因为资源一次只指向一个资源。

#### Ant-style Patterns

```
/WEB-INF/*-context.xml
com/mycompany/**/applicationContext.xml
file:C:/some/path/*-context.xml
classpath:com/mycompany/**/applicationContext.xml
```

当路径位置包含Ant样式模式时，解析程序遵循更复杂的过程来尝试解析通配符。 它为直到最后一个非通配符段的路径生成一个Resource，并从中获取一个URL。 如果此URL不是jar：URL或特定于容器的变体（例如，在WebLogic中为zip：，在WebSphere中为wsjar，等等），则从中获取java.io.File并用于通过遍历以解析通配符 文件系统。 对于jar URL，解析器要么从中获取java.net.JarURLConnection，要么手动解析jar URL，然后遍历jar文件的内容以解析通配符。

如果指定的路径已经是文件URL（隐式，因为基本ResourceLoader是文件系统或显式），则可以保证通配符以完全可移植的方式工作。

如果指定的路径是类路径位置，则解析程序必须通过进行Classloader.getResource（）调用来获取最后一个非通配符路径段URL。由于这只是路径的一个节点（不是最后的文件），实际上它是未定义的（在ClassLoader Javadoc中），在这种情况下确切地返回了什么类型的URL。实际上，它始终是一个java.io.File，表示目录（类路径资源解析为文件系统位置）或某种类型的jar URL（此处类路径资源解析为jar位置）。尽管如此，这种操作还是存在可移植性问题。

如果获取最后一个非通配符段的jar URL，解析器必须能够从中获取java.net.JarURLConnection或手动解析jar URL，以便能够遍历jar的内容并解析通配符。这在大多数环境中都有效，但在其他环境中无效，我们强烈建议您在依赖它之前，在特定环境中彻底测试来自jar的资源的通配符解析。

#### classpath*: 前缀

```java
ApplicationContext ctx =
    new ClassPathXmlApplicationContext("classpath*:conf/appContext.xml");
```

此特殊前缀指定必须获取与给定名称匹配的所有类路径资源（在内部，这主要通过调ClassLoader.getResources（...））然后合并以形成最终的应用程序上下文定义。

> 通配符类路径依赖于底层类加载器的getResources（）方法。 由于现在大多数应用程序服务器都提供自己的类加载器实现，因此行为可能会有所不同，尤其是在处理jar文件时。 检查classpath *是否有效的简单测试是使用类加载器从类路径中的jar中加载文件：getClass（）。getClassLoader（）。getResources（“<someFileInsideTheJar>”）。 尝试使用具有相同名称但放在两个不同位置的文件进行此测试。 如果返回了不适当的结果，请检查应用程序服务器文档以获取可能影响类加载器行为的设置。

您还可以将classpath *：前缀与位置路径的其余部分中的PathMatcher模式组合在一起（例如，classpath *：META-INF / * - beans.xml）。 在这种情况下，解析策略非常简单：在最后一个非通配符路径段上使用ClassLoader.getResources（）调用来获取类加载器层次结构中的所有匹配资源，然后从每个资源中获取相同的PathMatcher解析 前面描述的策略用于通配符子路径。

### 其他关于通配符的注意事项

请注意，`classpath*：`与Ant样式模式结合使用时，只能在模式启动前与至少一个根目录一起可靠地工作，除非实际目标文件驻留在文件系统中。 这意味着类路径`*：*` xml等模式可能无法从jar文件的根目录中检索文件，而只能从扩展目录的根目录中检索文件。

Spring检索类路径条目的能力来自JDK的ClassLoader.getResources（）方法，该方法仅返回空字符串的文件系统位置（指示搜索的潜在根）。 Spring也会评估URLClassLoader运行时配置和jar文件中的java.class.path清单，但这不能保证导致可移植行为。

如果要搜索的根包在多个类路径位置中可用，则不保证具有类路径的Ant样式模式：资源可以找到匹配的资源。 请考虑以下资源位置示例：

```
com/mycompany/package1/service-context.xml
```

```
classpath:com/mycompany/**/service-context.xml
```

这样的资源可能只在一个位置，但是当使用前面例子之类的路径来尝试解析它时，解析器会处理getResource（“com / mycompany”）;返回的（第一个）URL。 如果此基本包节点存在于多个类加载器位置中，则实际的最终资源可能不存在。 因此，在这种情况下，您应该更喜欢使用`classpath*：`使用相同的Ant样式模式，该模式搜索包含根包的所有类路径位置。

### FileSystemResource注意事项

没有附加到FileSystemApplicationContext的FileSystemResource（即，当FileSystemApplicationContext不是实际的ResourceLoader时）会按预期处理绝对路径和相对路径。 相对路径相对于当前工作目录，而绝对路径相对于文件系统的根目录。

但是，出于向后兼容性（历史）的原因，当FileSystemApplicationContext是ResourceLoader时，这会发生变化。 FileSystemApplicationContext强制所有附加的FileSystemResource实例将所有位置路径视为相对路径，无论它们是否以前导斜杠开头。 实际上，这意味着以下示例是等效的：

```java
ApplicationContext ctx =
    new FileSystemXmlApplicationContext("conf/context.xml");
```

```java
ApplicationContext ctx =
    new FileSystemXmlApplicationContext("/conf/context.xml");
```

以下示例也是等效的（即使它们有所不同，因为一个案例是相对的而另一个是绝对的）：

```java
FileSystemXmlApplicationContext ctx = ...;
ctx.getResource("some/resource/path/myTemplate.txt");
```

```java
FileSystemXmlApplicationContext ctx = ...;
ctx.getResource("/some/resource/path/myTemplate.txt");
```

实际上，如果需要真正的绝对文件系统路径，则应避免对FileSystemResource或FileSystemXmlApplicationContext使用绝对路径，并使用file：URL前缀强制使用UrlResource。 以下示例显示了如何执行此操作：

```java
// actual context type doesn't matter, the Resource will always be UrlResource
ctx.getResource("file:///some/resource/path/myTemplate.txt");
```

```java
// force this FileSystemXmlApplicationContext to load its definition via a UrlResource
ApplicationContext ctx =
    new FileSystemXmlApplicationContext("file:///conf/context.xml");
```

## 通配符

### classpath:与classpath*:

classpath:与classpath*:的区别在于，前者只会从第一个classpath中加载，而后者会从所有的classpath中加载

如果要加载的资源，不在当前ClassLoader的路径里，那么用classpath:前缀是找不到的，这种情况下就需要使用classpath*:前缀

另一种情况下，在多个classpath中存在同名资源，都需要加载，那么用classpath:只会加载第一个，这种情况下也需要用classpath*:前缀

可想而知，用classpath*:需要遍历所有的classpath，所以加载速度是很慢的，因此，在规划的时候，应该尽可能规划好资源文件所在的路径，尽量避免使用classpath*

**ResourcePatternResolver**

```java
ResourcePatternResolver resolver = ResourcePatternUtils.getResourcePatternResolver(null);
try {
   Resource[] resources = resolver.getResources("classpath:/**/**DAO.xml");
} catch (IOException e) {
   e.printStackTrace();
}
```