---
title : SpringMVC配置
categories : 
- JavaWeb
- SpringMVC
date : 2018-8-10
---

# Spring MVC配置

## 1.SpringMVC初始化配置

### 1.1编写配置类

**Java配置**

```java
@Configuration
@EnableWebMvc // 导入DelegatingWebMvcConfiguration配置类
@ComponentScan(basePackages ="com.hdr.webstore")
public class WebAppConfig implements WebMvcConfigurer {
}
```

#### @EnableWebMvc  

**使用该注解修饰Configuration类可从WebMvcConfigurationSupport导入Spring MVC配置**

```java
@Retention(value=RUNTIME)
@Target(value=TYPE)
@Documented
@Import(value=DelegatingWebMvcConfiguration.class)
public @interface EnableWebMvc
```

**如果想修改导入的配置，实现WebMvcConfigurer接口并覆盖单个方法**

```java
@Configuration
@EnableWebMvc
@ComponentScan(basePackageClasses = MyConfiguration.class)
public class MyConfiguration implements WebMvcConfigurer {
    @Override
    public void addFormatters(FormatterRegistry formatterRegistry) {
        formatterRegistry.addConverter(new MyConverter());
    }

    @Override
    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
        converters.add(new MyHttpMessageConverter());
    }
}
```

注意：

只有一个`@Configuration`类可以使用`@EnableWebMvc`注解修饰，不过`WebMvcConfigurer`可以被多个配置类实现

#### DelegatingWebMvcConfiguration

WebMvcConfigurationSupport的子类，通过检测和委派`WebMvcConfigurer`类型的Bean来修改WebMvcConfigurationSupport提供的配置。

#### WebMvcConfigurationSupport

这是MVC提供Java配置的主要类

#### WebMvcConfigurer

通过使用`@EnableWebMvc`修饰`@Configuration`类,从而引入了`DelegatingWebMvcConfiguration`配置类

`DelegatingWebMvcConfiguration`继承了`WebMvcConfigurationSupport`

如果要对继承的方法进行重写,那就要@EnableWebMvc修饰的@Configuration类继承WebMvcConfigurer接口,然后重写接口方法.

**XML配置**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">
    <!--告诉Spring MVC 我们需要用到它提供的注解-->
    <mvc:annotation-driven/>
    <!--告诉Spring MVC 大概在哪里会找到使用了@Controller注解的Java类-->
    <context:component-scan base-package="com.packt.webstore"/>
</beans>
```

### 1.2注册DispathcerServlet

**Java配置**

```java
public class WebAppInitializer 
    extends AbstractAnnotationConfigDispatcherServletInitializer {
    
    @Override
    protected Class<?>[] getRootConfigClasses() {
        return null;
    }

    @Override
    protected Class<?>[] getServletConfigClasses() {
        return new Class[]{WebAppConfig.class};
    }

    @Override
    protected String[] getServletMappings() {
        return new String[]{"/"};
    }
}
```

#### SpringServletContainerInitializer

SpringServletContainerInitializer通过使用WebApplicationInitializer这个SPI来提供基于代码的方式来配置servlet容器

**工作原理**

**Servlet容器的启动原理**

在容器启动阶段，如果在类路径发现了`spring-web`模块，那么容器会加载、实例化这个类，然后再调用它的`onStartup`方法。 

#### WebApplicationInitializer

`WebApplicationInitializer`是个SPI（Service Provider Interface 服务提供接口）目的是提供接口，让第三方（服务厂商或扩展框架开发者）提供自定义实现的服务功能。

该接口的实现类提供以编程的方式配置ServletContext

Servlet 3.0容器启动`SpringServletContainerInitializer`类，通过`SpringServletContainerInitializer`类检测`WebApplicationInitializer`接口的实现类，然后配置`ServletContext`

WebApplicationInitializer接口的实现类

- AbstractContextLoaderInitializer

  在servlet context中注册`ContextLoaderListener`

  子类只需要实现`createRootApplicationContext()`

- AbstractDispatcherServletInitializer

  在servlet context中注册`DispatcherServlet`，推荐使用下面那个实现类

- AbstractAnnotationConfigDispatcherServletInitializer

  注册`DispatcherServlet`以及使用基于Java的Spring配置

  子类需要实现`getRootConfigClasses() `和`getServletConfigClasses()`

**XML配置**

```xml
 <servlet>
   <servlet-name>dispatcher</servlet-name>
   <servlet-class>
       org.springframework.web.servlet.DispatcherServlet
   </servlet-class>
   <init-param>
     <param-name>contextConfigLocation</param-name>
     <param-value>/WEB-INF/spring/dispatcher-config.xml</param-value>
   </init-param>
   <load-on-startup>1</load-on-startup>
 </servlet>

 <servlet-mapping>
   <servlet-name>dispatcher</servlet-name>
   <url-pattern>/</url-pattern>
 </servlet-mapping>
```

## 2.模型

据我目前的理解，SpringMVC有两种工作方式。

一种是接收请求，然后直接把处理后的数据，返回给请求方，例如常见的返回json数据。

另一种就是接收请求，然后把处理后的数据，交给视图使用，最后返回渲染好的页面给请求方。

模型（Model）负责携带要被视图使用的数据。

在SpirngMVC中有两个类与模型有关，一个是`ModelAndView`，一个是`Model`，

前者不仅携带数据，还说明了数据交由哪个视图处理。后者仅携带数据。

```java
// 使用ModelAndView
@GetMapping
public ModelAndView Welcome(ModelAndView mv) {
   mv.addObject("name", "hdr");
   mv.setViewName("welcome");
   return mv;
}
```

```java
// 使用Model
@GetMapping
public String Welcome(Model model) {
   model.addAttribute("name","hdr");
   return "welcome";
}
```

### 2.1@ModelAttribute

`@ModelAttribute`有以下用途

- 应用在普通方法上
- 应用在`@RequestMapping`方法上
- 应用在方法参数上

#### 2.1.1应用在普通方法上

`@ModelAttribute`修饰的方法会在执行`@RequestMapping`方法前调用。

```java
@ModelAttribute
public void modelOne(@RequestParam(required=false)String name, Model model){
    model.addAttribute("name",name);
}

@PostMapping("/login")
public String login(){
    return "login";
    // 这里会传递上面那个model对象给视图
}
// -----------------------------------------------------------------
@ModelAttribute("name")
public String modelOne(@RequestParam(required=false)String name){
    return name;
}
```

#### 2.1.2应用在方法参数上

```java
@PostMapping("/login")
public String login(@ModelAttribute("name") String name){
    // 获取属性
    return "login";
}
```

#### 2.1.3应用在`@RequestMapping`方法上

```java
@PostMapping("/login")
@ModelAttribute("name")
public String login(){
    return "hdr";
}
// 标志该方法的返回值是model属性
// 这有什么卵用？？？？？？？？？
```

## 3.视图解析器与视图

视图解析器（view resolver）、视图（view）

视图是渲染数据模型展示给用户的用户的组件，在SpringMVC中分了逻辑视图和非逻辑视图两种。

逻辑视图需要使用视图解析器进行进一步的定位，例如上面的例子，我们只是返回了一个字符串，就能找到对应的jsp文件，这是视图解析器起的作用。

**工作流程**

1. 请求来到dispatcher servlet，dispatcher servlet把请求发送给相应的Controller进行处理。
2. Controller对Model中的对象进行更新，然后返回view的名称给dispatcher servlet。
3. dispatcher servlet使用view resolver找出view的实际路径，然后把model传递给view。
4. view使用Model提供的数据进行渲染，然后把页面传递给dispatcher servlet
5. dispatcher servlet 把页面返回给用户。

**具体原理还有待学习**

### 3.1JSP

```java
@Bean
public InternalResourceViewResolver getInternalResourceViewResolver(){
    InternalResourceViewResolver resolver = new InternalResourceViewResolver();
    resolver.setViewClass(JstlView.class);
    resolver.setPrefix("/WEB-INF/jsp/");
    resolver.setSuffix(".jsp");
    return resolver;
}
```
### 3.2ThymeLeaf

由于Servlet默认提供了对JSP文件进行渲染的功能，所以使用JSP我们只需要注册JSP视图解析器即可。

但是对于ThymeLeaf，我们不仅要注册视图解析器，还要注册模板引擎和模板解析器。

```java
@Autowired
private ApplicationContext applicationContext;

@Bean
public SpringResourceTemplateResolver templateResolver(){
   SpringResourceTemplateResolver templateResolver = new SpringResourceTemplateResolver();
   templateResolver.setApplicationContext(this.applicationContext);
   templateResolver.setPrefix("/WEB-INF/templates/");
   templateResolver.setSuffix(".html");
   templateResolver.setCharacterEncoding("utf-8");
   templateResolver.setTemplateMode(TemplateMode.HTML);
   templateResolver.setCacheable(true);
   return templateResolver;
}

@Bean
public SpringTemplateEngine templateEngine(){
   SpringTemplateEngine templateEngine = new SpringTemplateEngine();
   templateEngine.setTemplateResolver(templateResolver());
   templateEngine.setEnableSpringELCompiler(true);
   return templateEngine;
}
// 注册视图解析器
@Bean
public ThymeleafViewResolver viewResolver(){
   ThymeleafViewResolver viewResolver = new ThymeleafViewResolver();
   viewResolver.setTemplateEngine(templateEngine());
   viewResolver.setCharacterEncoding("utf-8");
   return viewResolver;
}
```

### 3.3JSON

**导入依赖**

```xml
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.9.6</version>
</dependency>
```

**使用**

```java
// 返回Json数据
@GetMapping
@ResponseBody
public User getUser(){
   User user = new User();
   user.setName("黄大仁");
   user.setEmail("13143754797@163.com");
   return user;
}

// 获取Json数据
@PostMapping
@ResponseBody
public User getUser(@RequestBody User user){
	return user;
}
```

**JsonView**

## 4.DataBinder

`DataBinder`（数据绑定器），用于给目标对象设值，同时还支持validation和绑定结果分析。

在`@Controller`和`@ControllerAdvice`类中声明`@InitBinder`方法，可以创建`WebDataBinder`对象。

该对象有以下功能：

- 绑定请求参数到model对象
- 把String类型的请求值转换成合适的类型
- Format model object values as `String` values when rendering HTML forms.

具体内容看这个[简解Spring的BeanWrapper、DataBinder、ConversionService、Formatter](https://segmentfault.com/a/1190000008938863)

`WebDataBinder`,用来从HttpServletRequest对象中提取相关的数据,然后组装到相应的对象中,并进行验证.

```java
@InitBinder
public void initialiseBinder(WebDataBinder binder) {
    binder.setAllowedFields("productId","name","unitPrice","description",
                            "manufacturer","category","unitsInStock",
                            "condition");
}
```

```java
public String
processAddNewProductForm(@ModelAttribute("newProduct")Product productToBeAdded, 
                         BindingResult result){
    // 添加 BindingResult
    String[] suppressedFields = result.getSuppressedFields();
    if (suppressedFields.length > 0) {
    	throw new RuntimeException("Attempting to bind disallowed fields:"+                                   StringUtils.arrayToCommaDelimitedString(suppressedFields));
    }
    // 更多详情请查看@InitBinder 和 BindingResult
}
```



## 5.过滤器与拦截器

- filter（过滤器）
- interceptor（拦截器）

### 5.1过滤器



### 5.2拦截器

`HandlerInterceptor`接口负责拦截功能,它具有以下三个方法

- preHandle: 在请求到达Controller之前调用
- postHandle: Controller方法执行完毕后调用
- afterCompletion:整个请求流程走完后再调用

#### 5.2.1拦截器的设置

所有的拦截器都要实现HandlerInterceptor接口，该接口具有三个方法

```java
default boolean preHandle(HttpServletRequest request, HttpServletResponse response, 
                          Object handler)throws Exception {
   return true;// 返回true则，则把请求交给处理器处理，否则结束所有流程
}
// 处理器处理后，视图处理前
default void postHandle(HttpServletRequest request, HttpServletResponse response, 
                        Object handler,@Nullable ModelAndView modelAndView) 
    throws Exception {
}
// 视图处理后
default void afterCompletion(HttpServletRequest request, HttpServletResponse response, 
                             Object handler, @Nullable Exception ex) throws Exception {
}
```

#### 5.2.2注册拦截器

```java
@Override
public void addInterceptors(InterceptorRegistry registry) {
   registry
         .addInterceptor(new CheckLogin())
         .addPathPatterns("/category");
}
```

#### 5.2.3多个拦截器的顺序

先注册的，先被执行

## 5.文件上传

### 5.1SpringMVC对文件上传的支持

首先，DispatchServlet使用适配器模式，将HttpServletRequest接口对象转换成MultipartHttpServletRequest对象。

MultipartHttpServletRequest接口扩展了HttpServletRequest接口，定义了一些操作文件的方法，我们通过这些方法实现对上传文件的操作。

### 5.2MultipartResolver

MultipartResolver接口用于把HttpServletRequest转换成MultipartHttpServletRequest。

MultipartResolver接口具有两个实现类，分别是StandardServletMultipartResolver和CommonsMultipartResolver，Spring推荐使用前者，因为那是Servlet API提供的包。

```java
// 在配置类添加multipartResolver Bean
@Bean
public StandardServletMultipartResolver multipartResolver(){
   return new StandardServletMultipartResolver();
}
```

```java
@Override
protected Filter[] getServletFilters() {
   CharacterEncodingFilter cef = new CharacterEncodingFilter();
   cef.setEncoding("UTF-8");
   cef.setForceEncoding(true);
   return new Filter[]{new HiddenHttpMethodFilter(), cef};
   // 注意：这个HiddenHttpMethodFilter是必须的
}
```

```java
@Controller
@RequestMapping("/")
public class UploadController {

   @PostMapping
   @ResponseBody
   public void upload(@RequestParam(value = "file") Part file) throws IOException {
      String path = "/home/hdr/Desktop/";
      String fileName = "beauty.jpg";
      file.write(path + fileName);
   }
}
```



## 6.静态资源的访问

一般我们使用SpringMVC，都会把DispatcherServlet请求映射配置为”/”，那么Web容器会把所有请求都交给Spring MVC的DispatchServlet处理，那么就会有这么一个问题，在请求静态资源的时候，Spring MVC会将它们当成一个普通请求处理，因此找不到对应处理器将导致错误。如何在DispatcherServlet请求映射配置为”/”的情况下，让Spring框架能够捕获所有URL的请求，同时又将静态资源的请求转由Web容器处理呢？有两种方法

### 默认Servlet

启动DefaultServletHttpRequestHandler，设置默认Servlet的URL映射为/ **，并且相对于其他URL映射具有最低优先级，也就是把DispatchServlet处理不了的请求，转发给容器的默认Servlet处理。

```java
@Override
public void configureDefaultServletHandling(
    DefaultServletHandlerConfigurer configurer) {
    configurer.enable();
}
// 层层匹配,真不知性能如何
```

对应XML配置

```xml
<mvc:default-servlet-handler/>
```

### 资源处理器

```java
// 在配置类重写该方法
@Override
public void addResourceHandlers(ResourceHandlerRegistry registry) {
    registry
        .addResourceHandler("/img_in_res/**")
    	.addResourceLocations("classpath:/img_in_res/");
    registry
        .addResourceHandler("/img_in_web/**")
    	.addResourceLocations("/img_in_web/");
    registry
        .addResourceHandler("/img_in_web_inf/**")
    	.addResourceLocations("/WEB-INF/img_in_web_inf/");
}
```

**注意**：理解项目打包后的结构关系非常重要。

## 7.异常处理

Spring 统一异常处理有 3 种方式，分别为：

1. 使用 @ ExceptionHandler 注解
2. 实现 HandlerExceptionResolver 接口
3. 使用 @controlleradvice 注解

### 7.1@ExceptionHandler 

```java
@ExceptionHandler
@ResponseBody
public String exceptionHandler(IOException ex){
   return ex.getMessage();
}
// 这种方式最大的缺陷就是不能全局控制异常,进行异常处理的方法必须与出错的方法在同一个Controller里面。
```

### 7.2@ControllerAdvice + @ ExceptionHandler

```java
@ControllerAdvice
@ResponseBody
public class WebExceptionHandle {
   /**
    * 400 - Bad Request
    */
   @ResponseStatus(HttpStatus.BAD_REQUEST)
   @ExceptionHandler(HttpMessageNotReadableException.class)
   public ValueObject handleHttpMessageNotReadableException(
       HttpMessageNotReadableException e) {
      return new ValueObject("could_not_read_json");
   }

   /**
    * 405 - Method Not Allowed
    */
   @ResponseStatus(HttpStatus.METHOD_NOT_ALLOWED)
   @ExceptionHandler(HttpRequestMethodNotSupportedException.class)
   public ValueObject handleHttpRequestMethodNotSupportedException(HttpRequestMethodNotSupportedException e) {
      return new ValueObject("request_method_not_supported");
   }

   /**
    * 415 - Unsupported Media Type
    */
   @ResponseStatus(HttpStatus.UNSUPPORTED_MEDIA_TYPE)
   @ExceptionHandler(HttpMediaTypeNotSupportedException.class)
   public ValueObject handleHttpMediaTypeNotSupportedException(Exception e) {
      return new ValueObject("content_type_not_supported");
   }

   /**
    * 500 - Internal Server Error
    */
   @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
   @ExceptionHandler(Exception.class)
   public ValueObject handleException(Exception e) {
      if (e instanceof IOException) {
         return new ValueObject("IOException:" + e.getMessage());
      }

      e.printStackTrace();
      return new ValueObject("server_error");
   }
}
```

### 7.3HandlerExceptionResolver

HandlerExceptionResolver接口的实现类可以解析控制器映射和执行过程中抛出的异常.

```java
@Component  
public class GlobalExceptionHandler implements HandlerExceptionResolver{  

    public ModelAndView resolveException(HttpServletRequest request, 
                                         HttpServletResponse response, 
                                         Object handler,  
                                         Exception ex) {  
        System.out.println("This is exception handler method!");  
        return null;  
    }  
}
```

Spring MVC 为了我们提供了HandlerExceptionResolver接口的两个实现类,

- `ResponseStatusExceptionResolver` 
- `ExceptionHandlerExceptionResolver`

```java
@ResponseStatus(value=HttpStatus.NOT_FOUND, 
                reason="Products no found")
public class ProductNotFoundException extends RuntimeException{
    private static final long serialVersionUID = -694354952032299587L;
    private String productId;
    
    public ProductNotFoundException(String productId) {
    	this.productId = productId;
	}
    
	public String getProductId() {
        return productId;
    }
}
```

在@controller类添加

```java
@ExceptionHandler(ProductNotFoundException.class)
public ModelAndView handleError(HttpServletRequest req,
                                ProductNotFoundException exception) {
    ModelAndView mav = new ModelAndView();
    mav.addObject("invalidProductId",exception.getProductId());
    mav.addObject("exception", exception);
    mav.addObject("url",req.getRequestURL()+"?"+req.getQueryString());
    mav.setViewName("productNotFound");
    return mav;
}
```

**优先级排序**

`@ExceptionHandler`>`@ControllerAdvice + @ ExceptionHandler`>`HandlerExceptionResolver `



## 8.SpringMVC乱码问题

- **页面的几种编码属性**

    ```
    pageEncoding="UTF-8" jsp页面编码，jsp文件本身的编码
    contentType="text/html; charset=UTF-8" web页面显示的编码，jsp页面输出流在浏览器中显示的编码
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"> web界面的输入编码，就是输入框中输入的字体编码。
    ```

- **get提交方式乱码处理（一般是由于tomcat引起的，所以需要设置tomcat的编码）**

    改tomcat中server.xml中的port=“8080”，加上一个 URIEncoding="utf-8"

- **post提交方式乱码处理/返回中文乱码（在web.xml中设置编码过滤器）**

    ```xml
    
    <!-- 解决工程编码过滤器 -->
    <filter>
    	<filter-name>characterEncodingFilter</filter-name>
        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
            <init-param>
                <param-name>encoding</param-name>
                <param-value>UTF-8</param-value>
            </init-param>
            <init-param>
                <param-name>forceEncoding</param-name>
                <param-value>true</param-value>
            </init-param>
    </filter>
    
    <filter-mapping>
    	<filter-name>characterEncodingFilter</filter-name>
    	<url-pattern>/*</url-pattern>
    </filter-mapping>
    ```

```java
@Override
protected Filter[] getServletFilters() {
   CharacterEncodingFilter characterEncodingFilter = new CharacterEncodingFilter();
   characterEncodingFilter.setEncoding("UTF-8");
   characterEncodingFilter.setForceEncoding(true);
   return new Filter[]{characterEncodingFilter};
}
```

## 9.View Resolvers 和 View Controller

### 9.1View Resolvers

```java
@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        // 把model中的属性转换成JSON形式然后返回（鸡肋）
        registry.enableContentNegotiation(new MappingJackson2JsonView());
        registry.jsp();
    }
}
```

### 9.2View Controller

如果一些请求不需要进行逻辑处理，只需要直接返回视图，可以使用`View Controller`

```java
@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        registry.addViewController("/").setViewName("home");
    }
}
```

## 提取外部信息

```java
@Bean
public MessageSource messageSource() {
    ResourceBundleMessageSource resource = new ResourceBundleMessageSource();
    resource.setBasename("messages");
    return resource;
} 
```

## 11.内容协商

ContentNegotiating(内容协商),提供了一种机制,可以采用不同的表现形式来表现同一种资源.

- ContentNegotiationConfigurer 
    - 创建ContentNegotiationManager并为它提供ContentNegotiationStrategy实例
- ContentNegotiationStrategy：函数式接口，用于解析请求媒体类型（media type）
- ContentNegotiationManager
    - 提供用于确定请求的媒体类型的方法（通过ContentNegotiationStrategy）
    - 提供查找媒体类型对应的文件扩展名的方法（通过MediaTypeFileExtensionResolver）
- ContentNegotiatingViewResolver
    - 解析请求的文件名或Accept的内容找出合适的View
    - 它本身不会进行解析工作，而是调用其它`view resolver`进行解析

ContentNegotiationConfigurer：配置从哪里读取信息，然后判断以什么样的形式返回数据

ContentNegotiatingViewResolver：根据返回数据的形式找到合适的view

请求方有三种方式告诉SpringMVC返回的资源应该采用何种表现形式（例如Json、XML等等）。

- URL后缀

    ```
    http://myserver/myapp/accounts/list.html
    http://myserver/myapp/accounts/list.xls
    ```

- URL参数

    ```
    http://myserver/myapp/accounts/list?format=html
    http://myserver/myapp/accounts/list?format=xls
    ```

- 请求头的Accept

    ```
    Accept: text/html,application/xhtml+xml,application/xml;
    ```

### 11.1URL后缀

默认情况下，Spring框架可以通过检测URL后缀来去确定响应消息体的内容类型的。

接下来通过Java和XML文件配置两种方法来对这种以后缀作为内容协商方法的策略进行设置。

```java
@Override
public void configureContentNegotiation(final ContentNegotiationConfigurer configurer) {
  configurer
    .favorPathExtension(true) // 使用后缀方式进行内容协商
    .favorParameter(false) // 禁用使用URL查询方式进行内容协商
    .ignoreAcceptHeader(true) // 忽略请求头部的Accept字段
    .defaultContentType(MediaType.APPLICATION_JSON); // 设置默认响应消息体内容类型为JSON
}
```

```xml
<bean id="contentNegotiationManager"
  class="org.springframework.web.accept.ContentNegotiationManagerFactoryBean">
    <property name="favorPathExtension" value="true" />
    <property name="favorParameter" value="false"/>
    <property name="ignoreAcceptHeader" value="true" />
    <property name="defaultContentType" value="application/json" />
    <property name="useJaf" value="false" />
</bean>
```

### 11.2方法查询

```java
public void configureContentNegotiation(final ContentNegotiationConfigurer configurer) {
  configurer
    .favorPathExtension(false)
    .favorParameter(true)
    .parameterName("format") // 内容类型查询参数为format
    .ignoreAcceptHeader(true)
    .useJaf(false)
    .defaultContentType(MediaType.APPLICATION_JSON)
    .mediaType("xml", MediaType.APPLICATION_XML)    // 设定不同参数值所对应的内容类型
    .mediaType("json", MediaType.APPLICATION_JSON); // 设定不同参数值所对应的内容类型
}
```

```xml
<bean id="contentNegotiationManager"
  class="org.springframework.web.accept.ContentNegotiationManagerFactoryBean">
    <property name="favorPathExtension" value="false" />
    <property name="favorParameter" value="true"/>
    <property name="parameterName" value="format"/>
    <property name="ignoreAcceptHeader" value="true" />
    <property name="defaultContentType" value="application/json" />
    <property name="useJaf" value="false" />

    <property name="mediaTypes">
        <map>
            <entry key="json" value="application/json" />
            <entry key="xml" value="application/xml" />
        </map>
    </property>
</bean>
```

### 11.3头部Accept字段

```java
@Override
public void configureContentNegotiation(final ContentNegotiationConfigurer configurer) {
  configurer
    .favorPathExtension(false)
    .favorParameter(false)
    .ignoreAcceptHeader(false)
    .defaultContentType(MediaType.APPLICATION_JSON);
}
```

```xml
<bean id="contentNegotiationManager"
  class="org.springframework.web.accept.ContentNegotiationManagerFactoryBean">
    <property name="favorPathExtension" value="false" />
    <property name="favorParameter" value="false"/>
    <property name="ignoreAcceptHeader" value="false" />
    <property name="defaultContentType" value="application/json" />
    <property name="useJaf" value="false" />
</bean>
```

**如果三者都用则先检查URL后缀，再检查URL参数，最后检查Accept**



**注册Bean**

```java
@Bean
public MappingJackson2JsonView jsonView() {
    MappingJackson2JsonView jsonView = new MappingJackson2JsonView();
    jsonView.setPrettyPrint(true);
    return jsonView;
}

@Bean
public MarshallingView xmlView() {
    Jaxb2Marshaller marshaller = new Jaxb2Marshaller();
    marshaller.setClassesToBeBound(Product.class);
    MarshallingView xmlView = new MarshallingView(marshaller);
    return xmlView;
}



@Bean
public ViewResolver contentNegotiatingViewResolver(ContentNegotiationManager manager) {
    ContentNegotiatingViewResolver resolver = new ContentNegotiatingViewResolver();
    resolver.setContentNegotiationManager(manager);
    ArrayList<View> views = new ArrayList<>();
    views.add(jsonView());
    views.add(xmlView());
    resolver.setDefaultViews(views);
    return resolver;
}
```



## 国际化

```java
@Bean
public LocaleResolver localeResolver(){
    SessionLocaleResolver resolver = new SessionLocaleResolver();
    resolver.setDefaultLocale(new Locale("en"));
    return resolver;
}
```

```java
@Override
public void addInterceptors(InterceptorRegistry registry) {
    LocaleChangeInterceptor localeChangeInterceptor = new LocaleChangeInterceptor();
    localeChangeInterceptor.setParamName("language");
    registry.addInterceptor(localeChangeInterceptor);
}
```
