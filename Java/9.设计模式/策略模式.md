# 简介

在企业开发中，常常会有一些对象需要使用多种算法实现一些业务逻辑。例如支持多种排序算法的排序工具类，支持多种加密方式的加密类。

```java
public class Encryptor {
    private String algorithmName;
    private String plainText;
    public Encryptor(String algorithmName){
       this.algorithmName=algorithmName;
   }
    public void encrypt(){
        if (algorithmName.equals("Aes")){
            System.out.println("Encrypting data using AES algorithm");
            // 想象这里有大量的代码
        }
       else if (algorithmName.equals("Blowfish")){
            System.out.println("Encrypting data using Blowfish algorithm");
            // 想象这里有大量的代码
        }
        // 想象这里还有大量的分支
    }
   /*Getter and setter methods for plainText*/  
}
```

这时候可以采用策略模式，编写一个策略接口，该接口有多种实现，利用多态的特性，客户端只需要持有策略接口，然后根据传递进来的策略实现，执行相应的操作。

```java
// 策略接口
public interface EncryptionStrategy {
    void encryptData(String plainText);
}
// 策略实现
public class AesEncryptionStrategy implements EncryptionStrategy{
   @Override
    public void encryptData(String plaintext) {
       System.out.println("-------Encrypting data using AES algorithm-------");
       try {
           KeyGenerator keyGenerator = KeyGenerator.getInstance("AES");
           keyGenerator.init(128);
           SecretKey secretKey = keyGenerator.generateKey();
           byte[] plaintTextByteArray = plaintext.getBytes("UTF8");
 
           Cipher cipher = Cipher.getInstance("AES");
           cipher.init(Cipher.ENCRYPT_MODE, secretKey);
           byte[] cipherText = cipher.doFinal(plaintTextByteArray);
 
           System.out.println("Original data: " + plaintext);
           System.out.println("Encrypted data:");
           for (int i = 0; i < cipherText.length; i++) {
               System.out.print(cipherText[i] + " ");
           }
       }
           catch(Exception ex){
               ex.printStackTrace();
           }
       }
   }
// 策略实现
public class BlowfishEncryptionStrategy implements EncryptionStrategy{
    @Override
    public void encryptData(String plaintext) {
        System.out.println("\n-------Encrypting data using Blowfish algorithm-------");
        try {
            KeyGenerator keyGenerator = KeyGenerator.getInstance("Blowfish");
            keyGenerator.init(128);
            SecretKey secretKey = keyGenerator.generateKey();
            byte[] plaintTextByteArray = plaintext.getBytes("UTF8");
 
            Cipher cipher = Cipher.getInstance("Blowfish");
            cipher.init(Cipher.ENCRYPT_MODE, secretKey);
            byte[] cipherText = cipher.doFinal(plaintTextByteArray);
 
            System.out.println("Original data: " + plaintext);
            System.out.println("Encrypted data:");
            for (int i = 0; i < cipherText.length; i++) {
                System.out.print(cipherText[i] + " ");
            }
        }
        catch(Exception ex){
            ex.printStackTrace();
        }
    }
}
```



```java
public class Encryptor {
    private EncryptionStrategy strategy;
    private String plainText;
    public Encryptor(EncryptionStrategy strategy){
        this.strategy=strategy;
    }
    public void encrypt(){
        strategy.encryptData(plainText);
    }
		// getter setter 
}
```

**测试**

```java
public class EncryptorTest {
 
    @Test
    public void testEncrypt() throws Exception {
      EncryptionStrategy aesStrategy=new AesEncryptionStrategy();
      Encryptor aesEncryptor=new Encryptor(aesStrategy);
      aesEncryptor.setPlainText("This is plain text");
      aesEncryptor.encrypt();
 
       EncryptionStrategy blowfishStrategy=new BlowfishEncryptionStrategy();
       Encryptor blowfishEncryptor=new Encryptor(blowfishStrategy);
       blowfishEncryptor.setPlainText("This is plain text");
       blowfishEncryptor.encrypt();
    }
}
```

