# 1.类和对象

类是对象的模版,对象是类的实例.

类里面可以有:

![Classçåé¨.png](https://github.com/HuangYiCheng1997/create-picture-url/blob/master/java/CrazyJava/Class%E7%9A%84%E5%86%85%E9%83%A8.png?raw=true) 

## 定义类

```java
[public/abstract/final] class 类名{
    零到多个构造器;
    零到多个成员变量;
    零到多个方法;
}
```

**注意:**

1. public修饰的类,类名必须跟文件名一样.
2. static修饰的成员,不能直接访问没有static修饰的成员.
3. 构造器是类创建对象的根本途径,如果类没有构造器,系统会自动提供一个默认的构造器.

## 初始化块

### 类初始化块

```java
static{
    
}
// 初始化块可以有多个,先定义的先执行
// 先执行父类的类初始化块,然后再执行本类的初始化块
```

### 实例初始化块

```java
{
    
}
// 先实例初始化,然后再执行构造器
// 其实实例初始化块是假的,它会被系统"还原"到每个构造器中
```

## 定义构造器

```java
[public/protected/private] 类名(args){  // 构造器名跟类名相同
    // to do
}
```

## 定义成员变量

```java
[ [public/protected/private] [static] [final/abstract] ]  dataType name;
```

## 定义成员方法

```java
[[public/protected/private] [static] [final/abstract]] returnType name(args){
    // to do
}
```

**补充: **

**1. this关键字:代表调用该方法的对象**

**2.方法重载: 方法名相同,方法参数不同**

**3.构造器重载:名字相同,方法参数不同**

## Java中变量的分类

![](https://github.com/HuangYiCheng1997/create-picture-url/blob/master/java/Java%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B.png?raw=true)

---



# 2.继承

## 1.什么是继承

继承是面向对象三大特性之一，继承允许我们基于已经存在的类来构造新的类，从而实现类的复用和扩展。

## 2.继承的基本语法

```java
public class Manager extends Employee{
    // ...............
}
```

通过extends关键字说明Manager类继承了Employee类，这时候Manager类是Employee类的子类，相对的，Employee类就是Manager类的父类。

**不同情况下，子类继承父类的东西会有所不同**

- 两个类位于同一个包时，子类继承父类public、protected、默认访问级别的成员变量和成员方法。
- 两个类不在同一个包时，子类只能继承父类pulibc、protectd访问级别的成员变量和成员方法。

## 3.方法重载与方法重写

### 方法重载（Overload）

有时候，类的同一种功能有多种实现方式，到底采用那种方式，取决于调用者给定的参数。

例如唱歌，有独唱，有合唱。

```java
public void singAlone(){
    // 独唱.....
}
```

```java
public void chorus(){
    // 合唱
}
```

如果每一种唱法都要写一个新的方法来实现，那么无论是想方法名，还是记方法名都是很难受的。

这时候我们就可以通过方法重载来解决这个难题.

```java
public void sing(){
    // 独唱
}

public void sing(String chorus){
    // 合唱
}
```

看上面的，**在同一个类中，方法名相同，但是方法参数列表不同，这就是方法重载。**

#### 注意:

- 方法重载与修饰符、返回类型无关。
- 方法签名：方法名+参数列表。

### 方法重写（Overwrite）

正如上面所述，子类会继承父类的方法，有些时候父类的方法并不能满足我们的需求，那么我们可以对父类的方法进行重写。

```java
public class Parent{
    public void sayHello(){
        System.out.println("Hello,I am parent");
    }
}

public class Son extends Parent{
    @Override
    public void sayHello(){
        System.out.println("Hello,I am son");
    }
}
```

方法重写：子类中的某个方法，其方法名、参数列表、返回类型都与父类中某个方法相对应。

#### 注意:

- 方法重写最好使用@Override注解修饰，这样不仅代码直观，还会帮你检查返回参数，方法名，参数列表，是否跟父类方法相同。
- 子类不能缩小父类方法的访问权限。
- 子类方法不能抛出比父类方法更多的异常。
- 因为子类无法继承父类的私有方法，自然，子类也就无法重写父类的私有方法。

## 4.this与super

this代表的是当前类，super代表的是当前类的父类。

this() 调用当前类的构造方法, super()调用当前类的父类的构造方法。

this.var 获取当前类的实例变量。super.var 获取父类的实例变量



## 5.Object类

Object类是所有类的始祖，所有类都是源自于它。

因此我们很有必要了解这个类所提供的服务。

这里我们挑几个重中之重来讲，剩余的自己看文档去。

### equals方法

equlas方法用于检测一个对象是否等于另外一个对象。

说道equals就必须讲一讲 == 了。

**==**

对于基本数据类型，==比较的是他们的值

对于引用类型，==比较的是他们在内存中存放的地址

基本数据类型用==比较，引用类型用equals比较。

让我们看看Object类中equlas方法的源码。

```java
public boolean equals(Object obj) {
	return (this == obj);
}
```

可知它这个方法就是在判断着两个对象是否具有相同引用，如果有相同引用，这两个对象必然是相等的，但是在实际开发中，这种判断并没有什么意义。

**也就是说！我们需要学会自己写equlas方法**

java规范要求equlas方法具有以下特性

- 自反性  当x != null   x.equlas(x) 要返回true；
- 对称性   x.qeuals(y)与 y.equals(x) 结果要相同;
- 传递性   如果x.qeuals(y)和x.qeuals(z)都为true，则y.quals(z)也为true；
- 一致性   如果x和y的引用对象没有发生变化，那么x.qeuals(y)的结果也不会变；
- 当x != null   x.equlas(null) 要返回false；

equals方法在同一个类的两个对象间的比较还是容易理解的。但是如果是子类与父类混合比较，那么情况就不太简单了。

**编写一个完美的equals方法**

```java
	@Override
	public boolean equals(Object otherObject){
		if (this==otherObject) return true;
		if (otherObject==null) return false;
		// 比较this与otherObject是否属于同一个类。
		// 如果子类对于判断equlas，具有自己的标准，那就要使用getClass  
		if (getClass()!=otherObject.getClass()) return false;
		// 如果子类对于判断equlas，是跟随超类的，那就使用instanceOf检测
        if (!otherObject instanceOf ClassName) return false;
        // 暂时还不能理解，还是选用getClass吧。
		// ClassName是当前类的类型
		ClassName other = (ClassName) otherObject;
		return field1 == other.field1 && .......
	}
```

### hashCode方法

hash code（散列码）是由对象导出的一个整型值。它是没有规律的。如果x和y是两个不同的对象，那么它们的hash code基本不会相同。

如果两个对象相等（equals方法返回真）但是他们的hashcode却不一样，这会使HashSet无法正常工作。相等的对象hashcode必须相等，不等的对象，hashcode是否相等不做要求。

**标准的hashCode方法**

```java
@Override
public int hashCode() {
    int hash = 7;
    hash = 31 * hash + (int) id;
    hash = 31 * hash + (name == null ? 0 : name.hashCode());
    hash = 31 * hash + (email == null ? 0 : email.hashCode());
    return hash;
}
// 使用两个私有成员，减少重复的可能性。
```

这个方法一般也不用我们自己写，直接用IDE生成就可以了。

**不过equals方法倒是真的要好好记住。**

### toString方法

## 6.final修饰符

final具有“不可改变”的含义，它可以修饰非抽象类、非抽象方法、变量。

- 用final修饰的类的不能被继承；
- 用final修饰的方法不能被子类重写；
- 用final修饰的变量只能赋值一次；

## 7.封装

封装也是面向对象的三大特性之一。

封装指的是将对象的状态信息隐藏在对象内部,不允许外部程序直接访问对象内部信息,而是通过该类提供的方法来实现对内部信息的操作和访问.

**封装的目的:**

1. 隐藏类的实现细节
2. 让使用者只能通过特定的方法来访问数据,从而保证数据的安全合理
3. 便于修改,提高代码可维护性

**封装的实现:**

面向对象的编程语言主要是通过访问控制机制来进行封装的。

Java提供了四种访问控制符,灵活运用它们就能有效控制对象的封装程度。

|                | private | default | protected | public |
| :------------- | :-----: | :-----: | :-------: | :----: |
| **同一个类中** |  **√**  |  **√**  |   **√**   | **√**  |
| **同一个包中** |         |  **√**  |   **√**   | **√**  |
| **子类中**     |         |         |   **√**   | **√**  |
| **全局范围内** |         |         |           | **√**  |

## 8.多态

面向对象的三大特性：封装、继承、多态。

多态性允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。

**以后再补充**

## 9.继承的利弊和使用原则

## 10.比较组合与继承





# 3.抽象类与接口

## 抽象类

**定义：**在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。

**作用：**在某些情况下，类会无法确定其方法的实现方式，
例如图形类，它要计算周长，但是不同的图形有不同的周长公式，
那就导致图形类无法确定计算周长这个方法的实现方式。
这个时候使用抽象类就是个不错的解决方法。

抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。

abstract修饰符可以修饰类和方法。被abstract修饰符修饰的类叫做抽象类。被abstract修饰符修饰的方法叫做抽象方法。

**注意：**

- 抽象类不能被实例化。

- 抽象类可以有非抽象方法。

- 抽象类可以没有抽象方法，但是定义了抽象方法的类必须要抽象类。

- 抽象方法没方法体。（看下面的例子）

  ```java
  public abstract void absMethod();
  // 方法体就是{}和它里面的东西。
  ```

## 接口

在java中，接口有两种意思。

- 一是概念性的接口，指系统对外提供的所有服务。类的所有能被外部使用者访问的方法构成了类的接口。
- 二是指用interface关键字定义的实实在在的接口，也称为接口类型。

我们这里要讲的是接口类型，它表面上与抽象类有点相似，都是不能被实例化。

类实现接口的关键字是implements

```java
public class MyDate implements Comparable{
    
}
```

**注意：**

- 接口中的成员变量默认都是public static final修饰的，必须被显示初始化。

  ```java
  public interface A{
      int var1; // 报错 没有赋值
      protected int var2=2; // 报错 只能用public修饰
      int var3 = 3; // 可以
  }
  ```

- 接口中的方法默认是public、abstract修饰的。

- JDK8之前，接口只能包含抽象方法。JDK8之后，允许在接口中定义默认方法和静态方法。

  ```java
  public interface MyInterface{
      default void defMethod(){
          System.out.println("默认方法要用default来修饰");
      }
      
      static void staMethod(){
          System.out.println("我们是接口中的静态方法");
      }
  }
  ```

- 接口不能实现另一个接口，但是可以继承多个其他接口

  ```java
  public interface MyInterface extends A,B{
  }
  ```

## 比较接口和抽象类

1）抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，继承是一个 "是不是"的关系，而 接口 实现则是 "有没有"的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。

2）设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。

# 4.枚举类



# 5.内部类

**定义在另一个类中的类称为内部类。**

使用内部类的原因：

- 内部类是外部类的成员，因此内部类可以使用外部类的所有数据和方法，包括private修饰的。
- 内部类可以对同一个包中的其他类隐藏起来。
- 当想要定义一个回调函数且不想编写大量代码时，使用匿名内部类比较便捷。

**内部类的分类**

- 成员内部类
  - 实例内部类
  - 静态内部类
- 局部内部类（没有使用意义）

## 实例内部类

- 当外部类实例存在的时候，才能创建内部类

  ```java
  Outer.Inner inner = new Outer().new Inner();
  // 或者
  Outer outer = new Outer();
  Outer.Inner inner = outer.new Inner();
  ```

- 在内部类中，可以直接访问外部类的所有成员，包括成员方法和成员变量

- 在外部类中不能直接访问内部类的成员，必须通过内部类的实例去访问

- 在实例内部类中不能定义静态成员，只能定义实例成员

- 如果实例内部类B与外部类A包含同名的成员，那么在类B中this.var表示类B的成员，A.this.var表示类A的成员

## 静态内部类

- 静态内部类不会自动持有外部类的特定实例的引用，在创建静态内部类的实例时，不必创建外部类的实例
- 静态内部类可以直接访问外部类的静态成员，如果访问外部类的实例成员，要通过外部类的实例去访问
- 静态内部类中可以定义静态成员和实例成员

## 局部内部类

- 局部内部类不能包含静态成员

## 匿名内部类

匿名内部类存在的意义：有些实现类或子类我们只需要使用一次，没必要特意编写这个类，这时候我们就可以使用匿名内部类。匿名内部类仅能被使用一次，创建匿名内部类时它会立即创建一个该类的实例，该类的定义会立即消失，所以匿名内部类是不能够被重复使用。

**创建匿名内部类**

```
new 父类构造器（参数列表）|实现接口（）  
    {  
     //匿名内部类的类体部分  
    }
```

在这里我们看到使用匿名内部类我们必须要继承一个父类或者实现一个接口，当然也仅能只继承一个父类或者实现一个接口。同时它也是没有class关键字，这是因为匿名内部类是直接使用new来生成一个对象的引用。

**注意事项**

- 1、使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。

- 2、匿名内部类中是不能定义构造函数的。

- 3、匿名内部类中不能存在任何的静态成员变量和静态方法。

- 4、匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。

- 5、匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。

- 6、给匿名内部类传递参数的时候，若该形参在内部类中需要被使用，那么该形参必须要为final

  ```java
  public class OuterClass {
      public void display(final String name,String age){
          class InnerClass{
              void display(){
                  System.out.println(name);
              }
          }
      }
  }
  ```

**匿名内部类初始化**

我们一般都是利用构造器来完成某个实例的初始化工作的，但是匿名内部类是没有构造器的，我们需要使用构造代码块来初始化匿名内部类。

```java
return new InnerClass() {
            int age_ ;
            String name_;
            //构造代码块完成初始化工作
            {
                if(0 < age && age < 200){
                    age_ = age;
                    name_ = name;
                }
            }
            public String getName() {
                return name_;
            }
            
            public int getAge() {
                return age_;
            }
        };
```

## 继承内部类

## 子类与父类中的内部类同名

# 6.lambd表达式

为什么引入lambda表达式？

