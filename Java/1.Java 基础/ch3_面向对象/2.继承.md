---
title : 2.继承
categories : 
- JavaSE
- ch3面向对象
date : 2018-5-7
---

# 继承

## 1.什么是继承

继承是面向对象三大特性之一，继承允许我们基于已经存在的类来构造新的类，从而实现类的复用和扩展。

## 2.继承的基本语法

```java
public class Manager extends Employee{
    // ...............
}
```

通过extends关键字说明Manager类继承了Employee类，这时候Manager类是Employee类的子类，相对的，Employee类就是Manager类的父类。

不同情况下，子类继承父类的东西会有所不同

- 两个类位于同一个包时，子类继承父类public、protected、默认访问级别的成员变量和成员方法。
- 两个类不在同一个包时，子类只能继承父类pulibc、protectd访问级别的成员变量和成员方法。

## 3.方法重载与方法重写

### 方法重载（Overload）

有时候，类的同一种功能有多种实现方式，到底采用那种方式，取决于调用者给定的参数。

例如唱歌，有独唱，有合唱。

```java
public void singAlone(){
    // 独唱.....
}
```

```java
public void chorus(){
    // 合唱
}
```

如果每一种唱法都要写一个新的方法来实现，那么无论是想方法名，还是记方法名都是很难受的。

这时候我们就可以通过方法重载来解决这个难题.

```java
public void sing(){
    // 独唱
}

public void sing(String chorus){
    // 合唱
}
```

看上面的，**在同一个类中，方法名相同，但是方法参数列表不同，这就是方法重载。**

#### 注意:

- 方法重载与修饰符、返回类型无关。
- 方法签名：方法名+参数列表。

### 方法重写（Overwrite）

正如上面所述，子类会继承父类的方法，有些时候父类的方法并不能满足我们的需求，那么我们可以对父类的方法进行重写。

```java
public class Parent{
    public void sayHello(){
        System.out.println("Hello,I am parent");
    }
}

public class Son extends Parent{
    @Override
    public void sayHello(){
        System.out.println("Hello,I am son");
    }
}
```

方法重写：子类中的某个方法，其方法名、参数列表、返回类型都与父类中某个方法相对应。

#### 注意:

- 方法重写最好使用@Override注解修饰，这样不仅代码直观，还会帮你检查返回参数，方法名，参数列表，是否跟父类方法相同。
- 子类不能缩小父类方法的访问权限。
- 子类方法不能抛出比父类方法更多的异常。
- 因为子类无法继承父类的私有方法，自然，子类也就无法重写父类的私有方法。

## 4.this与super

this代表的是当前类，super代表的是当前类的父类。

例如
this() 调用当前类的构造方法, super()调用当前类的父类的构造方法。

this.var 获取当前类的实例变量。super.var 获取父类的实例变量



## 5.Object类

Object类是所有类的始祖，所有类都是源自于它。

因此我们很有必要了解这个类所提供的服务。

这里我们挑几个重中之重来讲，剩余的自己看文档去。

### equals方法

equlas方法用于检测一个对象是否等于另外一个对象。

说道equals就必须讲一讲 == 了。

**==**

对于基本数据类型，==比较的是他们的值

对于引用类型，==比较的是他们在内存中存放的地址

基本数据类型用==比较，引用类型用equals比较。

让我们看看Object类中equlas方法的源码。

```java
public boolean equals(Object obj) {
	return (this == obj);
}
```

可知它这个方法就是在判断着两个对象是否具有相同引用，如果有相同引用，这两个对象必然是相等的，但是在实际开发中，这种判断并没有什么意义。

**也就是说！我们需要学会自己写equlas方法**

java规范要求equlas方法具有以下特性

- 自反性  当x != null   x.equlas(x) 要返回true；
- 对称性   x.qeuals(y)与 y.equals(x) 结果要相同;
- 传递性   如果x.qeuals(y)和x.qeuals(z)都为true，则y.quals(z)也为true；
- 一致性   如果x和y的引用对象没有发生变化，那么x.qeuals(y)的结果也不会变；
- 当x != null   x.equlas(null) 要返回false；

equals方法在同一个类的两个对象间的比较还是容易理解的。但是如果是子类与父类混合比较，那么情况就不太简单了。

**编写一个完美的equals方法**

```java
	@Override
	public boolean equals(Object otherObject){
		if (this==otherObject) return true;
		if (otherObject==null) return false;
		// 比较this与otherObject是否属于同一个类。
		// 如果子类对于判断equlas，具有自己的标准，那就要使用getClass  
		if (getClass()!=otherObject.getClass()) return false;
		// 如果子类对于判断equlas，是跟随超类的，那就使用instanceOf检测
        if (!otherObject instanceOf ClassName) return false;
        // 暂时还不能理解，还是选用getClass吧。
		// ClassName是当前类的类型
		ClassName other = (ClassName) otherObject;
		return field1 == other.field1 && .......
	}
```

### hashCode方法

hash code（散列码）是由对象导出的一个整型值。它是没有规律的。如果x和y是两个不同的对象，那么它们的hash code基本不会相同。

如果两个对象相等（equals方法返回真）但是他们的hashcode却不一样，这会使HashSet无法正常工作。相等的对象hashcode必须相等，不等的对象，hashcode是否相等不做要求。

**标准的hashCode方法**

```java
@Override
public int hashCode() {
    int hash = 7;
    hash = 31 * hash + (int) id;
    hash = 31 * hash + (name == null ? 0 : name.hashCode());
    hash = 31 * hash + (email == null ? 0 : email.hashCode());
    return hash;
}
// 使用两个私有成员，减少重复的可能性。
```

这个方法一般也不用我们自己写，直接用IDE生成就可以了。

**不过equals方法倒是真的要好好记住。**



### toString方法

## 6.final修饰符

final具有“不可改变”的含义，它可以修饰非抽象类、非抽象方法、变量。

- 用final修饰的类的不能被继承；
- 用final修饰的方法不能被子类重写；
- 用final修饰的变量只能赋值一次；

## 7.封装

封装也是面向对象的三大特性之一。

封装指的是将对象的状态信息隐藏在对象内部,不允许外部程序直接访问对象内部信息,而是通过该类提供的方法来实现对内部信息的操作和访问.

**封装的目的:**

1. 隐藏类的实现细节
2. 让使用者只能通过特定的方法来访问数据,从而保证数据的安全合理
3. 便于修改,提高代码可维护性

**封装的实现:**

面向对象的编程语言主要是通过访问控制机制来进行封装的。

Java提供了四种访问控制符,灵活运用它们就能有效控制对象的封装程度。

|                | private | default | protected | public |
| :------------- | :-----: | :-----: | :-------: | :----: |
| **同一个类中** |  **√**  |  **√**  |   **√**   | **√**  |
| **同一个包中** |         |  **√**  |   **√**   | **√**  |
| **子类中**     |         |         |   **√**   | **√**  |
| **全局范围内** |         |         |           | **√**  |

## 8.多态

面向对象的三大特性：封装、继承、多态。

多态性允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。

**以后再补充**

## 9.继承的利弊和使用原则

## 10.比较组合与继承

