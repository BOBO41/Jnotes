# 反射



## 什么是反射?

反射(Reflection),它使我们可以在运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。 

**Java反射框架主要提供以下功能:** 

- 在运行时判断任意一个对象所属的类。
- 在运行时构造任意一个类的对象。
- 在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法） 。
- 在运行时调用任意一个对象的方法。

## Class类

因为类都有构造器、成员变量、方法等等,所以可以对类进行抽象.

Class类就是类的抽象,Class类的实例代表某个类.

### 获取Class类实例

① 通过对象的getClass()方法

② 通过类.class

③ 通过Class.forName()

```java
		// 通过对象的getClass方法
        Dog dog = new Dog("叉烧",2,"White");
        Class<? extends Dog> aClass = dog.getClass();

        // 通过类.class
        Class<Dog> dogClass = Dog.class;

        //  通过Class.forName方法
        try { 
            Class.forName("ch17_Reflection.Dog");
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
```

### 获取包信息

```java
Class<Dog> dogClass = Dog.class;
Package aPackage = dogClass.getPackage();
String packageName = aPackage.getName();
System.out.println(packageName);
```

### 获取构造器

**调用无参数构造器实例化对象**

```java
Class<Dog> dogClass = Dog.class;
        try {
            // 通过Class对象实例化对象
            Dog dog = (Dog) dogClass.newInstance();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }
```

**获取所有构造器**

```java
Class<Dog> dogClass = Dog.class;
        // 获取dogClass的所有构造器
        Constructor<?>[] constructors = dogClass.getConstructors();
        for (int i = 0; i < constructors.length; i++) {
            System.out.println(constructors[i].getName());
            System.out.println(constructors[i].getParameterCount());
            
            // 获取构造器所需要的参数的类型
            Class<?>[] parameterTypes = constructors[i].getParameterTypes();
            for(int j =0; j<parameterTypes.length;j++) {
                System.out.println(parameterTypes[j].toString());
            }
        }
```

**使用指定构造器实例化对象**

```java
Class<Dog> dogClass = Dog.class;
        try {
            // 获取指定的构造器
            Constructor<Dog> constructor = dogClass.getConstructor(String.class, int.class, String.class);
            // 使用构造器实例化对象
            Dog dog = constructor.newInstance("cookie", 2, "yellow");
            dog.sayHello();
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        }
```



### 获取字段

```java
Class<Dog> dogClass = Dog.class;

        // 获取非private修饰的fields
        Field[] fields = dogClass.getFields();

        // 获取所有fields
        Field[] declaredFields = dogClass.getDeclaredFields();
        for (int i = 0; i < declaredFields.length; i++) {
            // 获取field的修饰符
            String modifier = Modifier.toString(declaredFields[i].getModifiers());
            // 获取field的类型
            String type = declaredFields[i].getType().getName();
            // 获取field的名字
            String name = declaredFields[i].getName();
            System.out.println(modifier + " " + type + " " + name);
        }
```



### 获取类方法

```java
Dog dog = new Dog("flash",2,"white");
        Class<Dog> dogClass = Dog.class;
        // 获取所有非private方法,包括父类的
        Method[] methods = dogClass.getMethods();
        for (int i = 0; i < methods.length; i++) {
            //调用toString方法
            if(methods[i].getName().equals("toString"))
            {
                try {
                    String s = (String) methods[i].invoke(dog);
                    System.out.println(s);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                } catch (InvocationTargetException e) {
                    e.printStackTrace();
                }
            }
        }
```

```java
Dog dog = new Dog("cookie",2,"white");
        Class<Dog> dogClass = Dog.class;
        //获取该类的所有方法,不包括父类的
        Method[] declaredMethods = dogClass.getDeclaredMethods();
        for (int i = 0; i < declaredMethods.length; i++) {
            //System.out.println(declaredMethods[i].getName());
            if(declaredMethods[i].getName().equals("sayHello"))
            {
                // 让其它类可以调用该private修饰的方法
                declaredMethods[i].setAccessible(true);
                try {
                    declaredMethods[i].invoke(dog);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                } catch (InvocationTargetException e) {
                    e.printStackTrace();
                }
            }
        }
```

### 调用类方法

```java
public Object invoke(Object obj, Object... args)
// obj 调用该方法的对象 后面是参数
```

### 获取注解信息



# 注解

## 注解的意义

如果说注释是写给人看的，那么注解就是写给程序看的。它更像一个标签，贴在一个类、一个方法或者字段上。它的目的是为当前读取该注解的程序提供判断依据。比如程序只要读到加了@Test的方法，就知道该方法是待测试方法，又比如@Before注解，程序看到这个注解，就知道该方法要放在@Test方法之前执行。

## 注解的分类

注解大致分为三类：自定义注解、JDK内置注解、还有第三方框架提供的注解。

自定义注解就是我们自己写的注解。JDK内置注解，比如@Override检验方法重载，@Deprecated标识方法过期等。第三方框架定义的注解比如SpringMVC的@Controller等。

## 定义一个注解

```java
// 格式
public @interface 注解名称{
    方法；
}
```

```java
// 可以把注解看做特殊的接口
public @interface MyAnnotation{
    // 定义一个方法，该方法默认返回值是“hdr”
    String name() default "hdr";
    // 方法的返回类型可以是
    // - String
	// - Class
	// - 基本类型
	// - 枚举类型
	// - 注解类型
	// - 以及上述类型的数组
}
```

## 用于注解类的注解

JDK提供了一些作用于注解类型的注解，方便我们对自定义的注解类进行更加灵活的配置

### @Target

指出该注解类适用于哪些位置

```java
@Target({ElementType.TYPE,ElementType.METHOD})
public @interface MyAnnotation {

	String value() default "默认构造方法";

	Class type() default void.class;

}
```

| 选项            | 描述                                         |
| --------------- | -------------------------------------------- |
| ANNOTATION_TYPE | 注解类型                                     |
| TYPE            | 各种Java类型，包括类、接口、枚举类、注解类型 |
| CONSTRUCTOR     | 构造方法                                     |
| FIELD           | 成员变量                                     |
| METHOD          | 成员方法                                     |
| PARAMETER       | 方法参数                                     |
| LOCAL_VARIABLE  | 局部变量                                     |
| PACKAGE         | 包                                           |

### @Retention

指定当前注解的有效范围

| 选项    | 描述                                                      |
| ------- | --------------------------------------------------------- |
| SOURCE  | 仅保存在源码中，不会引入到编译后的class文件中             |
| CLASS   | 会把程序中对注解类型的引用编译到类文件中                  |
| RUNTIME | 包含以上CLASS的范围，并且还能在运行时把注解加载到虚拟机中 |

### @Document

标识型注解。表示注解类型包含的信息会被加入到`JavaDoc`文档中。

### @Inherited

表示该注解类可被继承

## 获取注解信息

只要用到注解，必然有三角关系：定义注解，使用注解，读取注解。仅仅完成前两步，是没什么卵用的。就好比你写了一本武林秘籍却没人去学，那么这门武功还不如一把菜刀。那么我们怎么获取注解信息呢？

