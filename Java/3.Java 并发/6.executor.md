# Executor框架

程序其实就是要完成一项工作（work），一项工作由多个任务（task）组成，多线程让任务可以同时执行，从而提高了程序效率。

Executor框架，对任务执行这个过程进行了抽象，基于生产者消费者模式，把任务提交和任务的执行进行了解耦，提交任务的为生产者，执行任务的线程为消费者。

```java
public interface Executor {
    void execute(Runnable command);
}
```

## 线程池

Executor框架还提供了对线程池的实现，线程池管理一组工作线程，这些工作线程会被复用，从而减少了不断创建和销毁线程而造成的资源浪费。

Executor框架提供了5种线程池的实现，我们可以通过Executors的静态工厂来创建它们。

- `newFixedThreadPool` 固定大小的线程池，每当有新任务提交就创建一个线程，直到线程数量达到指定的最大值，然后保持线程池的大小，如果有线程死亡了，就重新创建一个新的。
- `newCachedThreadPool` 根据实际情况创建和回收线程，不限制线程的创建数量。
- `newSingleThreadExecutor` 创建一个工作线程来执行任务，如果该线程死亡，就创建一个新的。
- `newScheduledThreadPool` 一个固定大小的线程池，支持任务的延迟和定时执行。

后面我们会讲如何自定义创建线程池。

## Executor生命周期管理

`ExecutorService`是`Executor`的扩展，它添加了对`Executor`的生命周期进行管理的功能（当然还有一些方便提交任务的方法）。

`Executo`r的生命周期分为三阶段，正在运行、正在关闭、已终止。

```java
// Executor与生命周期管理相关的方法
public interface ExecutorService extends Executor {
	// 关闭Executor，不再接受新任务，等待已提交的任务执行完毕。
    void shutdown();
    // 强制关闭关闭Executor，不再接受新任务，尝试终止正在执行的任务，不执行已提交但在等待执行的任务
    List<Runnable> shutdownNow();
    
    // Executor关闭以后提交的任务都由RejectedExecutionHandler进行处理，可能会销毁任务或抛出异常，具体后面再讲。
	
    // 判断Executor是否处于正在关闭状态
    boolean isShutdown();
    
    // 判断Executor是否处于已终止状态
    boolean isTerminated();
    
    // 当任务都执行完毕后，Executor就会进入已终止状态，调用该方法可以等待Executor进入已终止状态
    boolean awaitTermination(long timeout, TimeUnit unit)
        throws InterruptedException;
}
```

## Callable与Future

`Runnable`是一个非常有限的抽象，它不能返回任务执行后的结果，如果需要任务执行后返回结果，我们可以使用`Callable`。

Future代表任务的生命周期，它可以取消任务、获取任务结果、查看任务是否已执行完毕，是否已被取消。

```java
@FunctionalInterface
public interface Callable<V> {
    V call() throws Exception;
}
```

```java
public interface Future<V> {
    boolean cancel(boolean mayInterruptIfRunning);
    boolean isCancelled();
    boolean isDone();
    V get() throws InterruptedException, ExecutionException;
    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
```

有以下方法可以获取`Future`对象

- 调用`ExecutorService`中的`submit`方法，提供一个`Runnable`或`Callable`
- 创建`FutureTask`对象，`FutureTask`实现了`Runnable`接口，你可以把它提交给`ExecutorService`，也可以直接调用它的`run`方法。



## CompletionService

当你有一批任务需要执行，并且需要在它们执行完毕后获取它们的结果，这时候你就可以使用`CompletionService`。

`CompletionService`使用了`Executor`和`BlockingQueue`，前者用来执行任务，后者用来获取存储执行完的`Future`对象。



