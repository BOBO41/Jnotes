# 1.并行、并发、高并发、线程安全性

**并行、并发、高并发**

**并行**：如果某个系统支持两个或以上个动作**同时存在**，那么这个系统就是一个**并发系统**。
**并发**：如果某个系统支持两个或以上个动作**同时执行**，那么这个系统就是一个**并行系统**。

并发系统与并行系统这两个定义之间的关键差异在于**“执行”**这个词。
在并发程序中可以同时拥有两个或以上个线程。这意味着，如果程序在单核处理器上运行，那么这些线程将交替的执行。这些线程是同时“存在”的——每个线程都处于执行过程中的某个状态。
如果程序能够并行执行，那么就一定是运行在多核处理器上。此时，程序中的每个线程都将分配到一个独立的处理器核上，因此可以同时运行。

**高并发**：通常是指，通过设计保证系统能够**同时并行处理**很多请求。

**线程安全性**：一个类无论被多少个线程访问，该类始终能表现出正确的行为，那么就称这个类是线程安全的。

# 2.并发编程的问题

在并发编程中，我们会遇到某些问题，例如原子性问题、可见性问题、有序性问题等等。

解决问题，我们要有方法论以及具体实现。在Java并发编程中，这个方法论就是Java内存模型，而具体实现就是Java提供的一系列和并发处理相关的关键字，比如`volatile`、`synchronized`、`final`以及`concurrent`包等等。

我们先来学习其中的方法论，再来学习具体实现。

Java内存模型，顾名思义就是一种内存模型，那么我们有必要先了解一下什么是内存模型。

## 2.1内存模型

**内存模型的作用是定义共享内存的正确性。具体的做法就是内存模型提供了一些关于内存读写的规则。通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。**

### 2.1CPU缓存一致性

**背景知识：CPU的高速缓存**

总所周知，CPU和内存并不是直接交换数据的，它们之间还隔着一个高速缓存。高速缓存是对程序员透明的，这意味在编程的时候是感知不到CPU的缓存的存在的。一般情况下确实如此，但在，在某些特殊的情形下（多核多线程），就不能忽略缓存的存在了。这其实是和缓存的设计有关系，一般多处理器下的每个CPU都有一个自己的缓存，存储在这个缓存的数据是其它CPU是无法查看的。

**引入问题1：缓存一致性**

问题来了，由于缓存是每个CPU私有的，那么在多线程环境下，某个CPU修改了变量x后保存在本地缓存，对于其它CPU，何时才能发现变量x被修改呢？如何保证其它CPU的缓存中持有的x的值是最新的呢？这就是缓存一致性问题。

缓存一致性问题是由于引入缓存而导致的，所以，这是很多CPU厂商必须解决的问题。为了解决前面提到的缓存数据不一致的问题，人们提出过很多方案，通常来说有以下2种方案：

- 通过在总线加`LOCK#`锁的方式。
- 通过缓存一致性协议（Cache Coherence Protocol）。

**LOCK#**

在早期的CPU当中，是通过在总线上加`LOCK#`锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加`LOCK#`锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。在总线上发出了`LCOK#`锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从其内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。但是由于在锁住总线期间，其他CPU无法访问内存，会导致效率低下。因此出现了第二种解决方案，通过缓存一致性协议来解决缓存一致性问题。

**缓存一致性协议**

缓存一致性协议（Cache Coherence Protocol），最出名的就是Intel 的MESI协议，MESI协议的作用就是保证每个缓存中使用的共享变量的副本是一致的。MESI的核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。

在MESI协议中，每个缓存可能有有4个状态，它们分别是：

- M(Modified)：这行数据有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。
- E(Exclusive)：这行数据有效，数据和内存中的数据一致，数据只存在于本Cache中。
- S(Shared)：这行数据有效，数据和内存中的数据一致，数据存在于很多Cache中。
- I(Invalid)：这行数据无效。

关于MESI的更多细节这里就不详细介绍了，我们只要知道，MESI是一种比较常用的缓存一致性协议，他可以用来解决缓存之间的数据一致性问题就可以了。

通过缓存一致性协议之后，内存可见性问题似乎是得以解决了。但是，这里面还隐藏着另外一个问题：乱序执行！

### 2.1.2乱序执行

乱序，指的是程序指令实际上执行的顺序，和我们书写的指令的顺序不一致。乱序分两种，分别是编译器的指令重排和CPU的乱序执行。本意上乱序是为了优化指令执行的速度而产生的。并且为了维护程序原来的语义，编译器和CPU不会对两个有数据依赖的指令重排（reorder）。这种保护在单线程的环境下是可以工作的，但是到了多线程，就可能出问题了。

举个例子，CPU-0将要执行两条指令，分别是：

```
1. STORE x
2. LOAD y
```

当CPU-0执行指令1的时候，发现这个变量x的当前状态为Shared，这意味着其它CPU也持有了x，因此根据缓存一致性协议，CPU-0在修改x之前必须通知其它CPU，直到收到来自其它CPU的ack才会执行真正的修改x。但是，事情没有这么简单。现代CPU缓存通常都有一个Store Buffer，其存在的目的是，先将要Store的变量记下来，注意此时并不真的执行Store操作，然后待时机合适的时候再执行实际的Store。有了这个Store Buffer，CPU-0在向其它CPU发出disable消息之后并不是干等着，而是转而执行指令2（由于指令1和指令2在CPU-0看来并不存在数据依赖）。这样做效率是有了，但是也带来了问题。虽然我们在写程序的时候，是先STORE x再执行LOAD y，但是实际上CPU却是先LOAD y再STORE x，这个便是CPU乱序执行（reorder）的一种情况！

当你的程序要求指令1、2有逻辑上的先后顺序时，CPU这样的优化就是有问题的。但是，CPU并不知道指令之间蕴含着什么样的逻辑顺序，在你告诉它之前，它只是假设指令之间都没有逻辑关联，并且尽最大的努力优化执行速度。因此我们需要一种机制能告诉CPU：这段指令执行的顺序是不可被重排的！做这种事的就是内存屏障（memory barrier）！

```
STORE x
WMB (Write memory barrier)
LOAD y
```

例如，通过在STORE x之后加上这个写内存屏障，就能保证在之后LOAD y指令不会被重排到STORE x之前了。

### 2.1.3总结

前面讲了那么多，那么内存模型是什么呢？由于每个CPU设计都是不同的，每个CPU对指令乱序的程度也是不一样的。比较保守的如x86仅会对Store Load乱序，但是一些优化激进的CPU（PS的Power）会允许更多情况的乱序产生。如果目标是写一个跨平台多线程的程序，那么势必要了解每一个CPU的细节，来插入确切的、足够的内存屏障来保证程序的正确性。这是多么的不科学啊！科学的做法应该是，编写一套抽象的程序，然后在不同的平台下让编程语言、编译器来生成合适的内存屏障以及处理缓存一致性问题。因此，我们有了内存模型的概念。我们只需要根据这个抽象的内存模型来编写程序即可。



## 2.2原子性、可见性、有序性

- **可见性**：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
- **原子性**：指在一个操作中cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。
- **有序性**：程序执行的顺序按照代码的先后顺序执行。

有没有发现，**缓存一致性问题**其实就是**可见性问题**。**CPU乱序执行**就是**原子性问题**，**编译器指令重排**就是**有序性问题**。所以说Java内存模型是解决这些问题的方法论。

# 3.Java内存模型

## 3.1什么是Java内存模型

**Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。**

提到Java内存模型，一般指的是JDK 5 开始使用的新的内存模型，主要由[JSR-133: JavaTM Memory Model and Thread Specification](http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf) 描述。

Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存保存了主内存中该线程使用到的变量的副本，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。

## 3.2Java内存模型的实现

在Java中提供了一系列和并发处理相关的关键字，比如`volatile`、`synchronized`、`final`等等。其实这些就是Java内存模型封装了底层的实现后提供给程序员使用的一些关键字。

在开发多线程的代码的时候，我们可以直接使用`synchronized`等关键字来控制并发，从来就不需要关心底层的编译器优化、缓存一致性等问题。所以，**Java内存模型，除了定义了一套规范，还提供了一系列原语，封装了底层实现后，供开发者直接使用。**

下面我们看看在Java中分别使用什么方式解决原子性、有序性和一致性等问题。

### 3.2.1原子性问题

- 原子变量类
- synchronized

在Java中，为了保证原子性，提供了两个高级的字节码指令`monitorenter`和`monitorexit`。在[synchronized的实现原理](http://www.hollischuang.com/archives/1883)文章中，介绍过，这两个字节码，在Java中对应的关键字就是`synchronized`。因此，在Java中可以使用`synchronized`来保证方法和代码块内的操作是原子性的。

### 3.2.2可见性问题

Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种依赖主内存作为传递媒介的方式来实现的。Java中的`volatile`关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用`volatile`来保证多线程操作时变量的可见性。除了`volatile`，Java中的`synchronized`和`final`两个关键字也可以实现可见性。只不过实现方式不同，这里不再展开了。

### 3.2.3有序性问题

在Java中，可以使用`synchronized`和`volatile`来保证多线程之间操作的有序性。实现方式有所区别：

`volatile`关键字会禁止指令重排。

`synchronized`关键字保证同一时刻只允许一条线程操作。进出锁住的代码块是串行的，因为只能有一个线程拿到锁，这就使得使用同一个锁的两个执行过程A和B之间，A看B的操作是有序的，B看A的操作也是有序的，是因为执行过程内部无论会不会指令重排序，结果都是一致的。但是锁的内部代码依然会指令重排序。

