# 并发问题

## 1.并发编程的基本知识

**并行**：如果某个系统支持两个或以上个动作**同时存在**，那么这个系统就是一个**并发系统**。
**并发**：如果某个系统支持两个或以上个动作**同时执行**，那么这个系统就是一个**并行系统**。

并发系统与并行系统这两个定义之间的关键差异在于**“执行”**这个词。
在并发程序中可以同时拥有两个或以上个线程。这意味着，如果程序在单核处理器上运行，那么这些线程将交替的执行。这些线程是同时“存在”的——每个线程都处于执行过程中的某个状态。
如果程序能够并行执行，那么就一定是运行在多核处理器上。此时，程序中的每个线程都将分配到一个独立的处理器核上，因此可以同时运行。

**高并发**：通常是指，通过设计保证系统能够**同时并行处理**很多请求。



## 2.并发问题

Java中的多线程编程属于并发编程的一种。并发编程能有效提高程序运行的效率，但同时也容易出现一些问题，下面我们来了解这些问题，只有把这些问题了解了，才能写出好的并发程序。

### 2.1可见性问题

**可见性**：一个线程对共享变量值的修改，能够及时的被其它线程看到。

**共享变量**：如果一个变量在多个线程的工作内存中存在副本，那么这个变量就是这几个线程的共享变量。

知道了什么是可见性，那么顾名思义，可见性问题就是一个线程对共享变量值的修改，没有及时的被其它线程看到。

**为什么会出现这种情况？**

1.  线程的交叉执行
2.  共享变量更新后的值没有及时在工作内存和主内存中更新

网上有很多关于可见性问题的文章，都会说什么Java内存模型、CPU多级缓存等等，但是个人觉得都说的不太清楚，本人觉得如果要想真正的了解这个问题的本质，需要对JVM以及计算机组成原理，特别是内存和CPU相关的知识有一定的认识才可以。本人暂时没有这个能力，暂时就不讲这个了。

**解决方案**

要实现共享变量的可见性，必须保证两点：

-   线程修改后的共享变量能够及时从工作内存刷新到主内存中
-   其他线程能及时把共享变量的最新值从主内存中更新到自己的工作内存中

Java解决可见性问题的方式包括

-   synchronized
-   volatile
-   Lock

#### synchronized

JMM关于synchronized的两条规定

-   线程解锁前，必须把共享变量的最新值刷新到主内存中
-   线程加锁时，将清空工作内存中共享变量的值，从而在使用共享变量时，需要从主内存中重新读取最新的值

#### volatile

通过内存屏障和禁止重排序优化来保证可见性。

要在多线程中安全的使用volatile变量，必须同时满足

-   对变量的写入操作不依赖其当前值
-   该变量没有包含在具有其他变量的不变式中



### 2.2原子性问题

**原子性操作**：一般我们认为原子是不可再分的，在编程领域中，原子性操作指的是一组操作是不可再分的，这组操作是一个统一的整体，这组操作在执行的过程中不会其它因素干扰，例如执行过程中被中断、或者执行过程中所用到的值被偷偷修改了。在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作。例如

```java
x = 10;
y = x;
```

**注意**：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。

```java
x += 1；
x = x + 1;
// 上面这种就不是原子性操作了，
```

**原子性问题**：我想不到、也找不到一个正式的定义，只能通过例子来讲。

例如 `x = x + 1;`这个操作。
假设当前`x = 9`，然后有两个线程同时执行上面这条语句。
由于两个线程都读到x的值为9，然后都执行递增操作，最后x的值变为10， 而不是预期的11。
这种问题就是原子性问题。

#### 产生的原因

有些操作在被多个线程同时执行的时候，无法保证当前使用的数据的有效性。

#### 解决方案

- 原子类

- synchronized
- Lock



### 2.3有序性问题

**有序性问题**：程序执行的顺序与编写代码的先后顺序不一致。

#### 产生的原因

- 编译器指令重排

    编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。 

- CPU乱序执行

    现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器 可以改变语句对应机器指令的执行顺序。 

- 内存系统的重排序

    由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

#### 解决方案

在Java中，可以使用`synchronized`和`volatile`来保证多线程之间操作的有序性。实现方式有所区别：

`volatile`关键字会禁止指令重排。

`synchronized`关键字保证同一时刻只允许一条线程操作。进出锁住的代码块是串行的，因为只能有一个线程拿到锁，这就使得使用同一个锁的两个执行过程A和B之间，A看B的操作是有序的，B看A的操作也是有序的，是因为执行过程内部无论会不会指令重排序，结果都是一致的。但是锁的内部代码依然会指令重排序。



