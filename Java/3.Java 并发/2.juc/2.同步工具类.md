阻塞队列是一种特殊的集合类，它不仅拥有容器的作用，还能协调生产者和消费者线程的控制流程。

那些可以通过自身状态来协调线程的的控制流程的对象，叫做同步者（Synchronizers）。

阻塞队列可以算是一种同步者，除此之外，JDK还提供了一些其它的同步者，分别是Latch、Semaphore、Barrier。

## Latch

Latch：**a device for keeping a door or gate closed, consisting of a metalbar that fits into a hole and is lifted by pushing down on another bar.**

门栓、闭锁

![](../images/java concurrency latch example.jpeg)

**什么是闭锁？**

闭锁作为一种同步工具类，它的作用相当于有一扇门，在闭锁打开之前，这扇门是无法打开的，因此任何线程都无法通过这扇门，当条件允许时，闭锁就会被打开，大门将永远保持打开。

**闭锁的作用？**

闭锁可以用来确保某些活动会在另一些活动完成之后才进行。例如：

- 确保某个计算它所需要的资源，在计算之前就已经被准备好
- 确保某个服务在进行之前，它所依赖的其它服务已经准备好了

### CountDownLatch

闭锁的实现就是`CountDownLatch`。

CountDownLatch在创建的时候需要传递一个正整数用作计时。

CountDownLatch有两个重要方法，一个是`countDown` 使计时器减1，一个是`await` 阻塞当前线程直到计时器为0。

```java
public class CountDownLatch {
    /**
     * Synchronization control For CountDownLatch.
     * Uses AQS state to represent count.
     */
    private static final class Sync extends AbstractQueuedSynchronizer {//...}
    private final Sync sync;
    public CountDownLatch(int count) {...}
    public void await() throws InterruptedException {...}
    public boolean await(long timeout, TimeUnit unit)
        throws InterruptedException {...}

    public void countDown() {...}
    public long getCount() {...}
    public String toString() {...}
}
```



## Barrier

屏障、栅栏

栅栏的作用是等待一组线程，等到这组线程全部都到达栅栏，才让他们通过。

### CyclicBarrier

栅栏的实现就是`CyclicBarrier`。

`CyclicBarrier`可以使一定数量的参加者反复地在栅栏出集合，当线程到达栅栏位置时，它调用await方法，这个方法会阻塞，直到有所线程都到达栅栏位置。如果线程都达到了，栅栏将会打开。如果await调用超时或者await阻塞的线程被打断，那么栅栏就认为是被打破了，所有阻塞的await调用都会被终止并且抛出`BrokenBarrierException`。 

## Exchanger

Exchanger是另一种形式的栅栏，用于线程间的数据交换，等到双方都到达各自的栅栏时，这两个线程可以进行数据交换。

## Semaphore

In computer science, a semaphore is a variable or abstract data type used to control access to a common resource by multiple processes in a concurrent system such as a multitasking operating system. 

信号量、信号灯

**什么是信号量？**

信号量管理着一组虚拟的许可，许可的数量通过构造函数来指定。操作前获取许可，操作后释放许可，如果没有许可，获取操作就会阻塞，直到有许可为止。

**信号量的作用？**

信号量可以用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。



# CountDownLatch

一个同步辅助工具，允许一个或多个线程处于等待直到其它线程中执行的一组操作完成。

构造CountDownLatch的时候需要给定一个计数量（count），每次调用countDown()方法就会减少一次，当计量数为0的时候，唤醒所有等待中的线程。

|           | 方法和描述                                                   |
| --------- | ------------------------------------------------------------ |
| `void`    | `await()`Causes the current thread to wait until the latch has counted down to zero, unless the thread is [interrupted](https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#interrupt--). |
| `boolean` | `await(long timeout, TimeUnit unit)`Causes the current thread to wait until the latch has counted down to zero, unless the thread is [interrupted](https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#interrupt--), or the specified waiting time elapses. |
| `void`    | `countDown()`Decrements the count of the latch, releasing all waiting threads if the count reaches zero. |
| `long`    | `getCount()`Returns the current count.                       |
| `String`  | `toString()`Returns a string identifying this latch, as well as its state. |

例子

```java
class Driver { // ...
   void main() throws InterruptedException {
     CountDownLatch doneSignal = new CountDownLatch(N);
     Executor e = ...

     for (int i = 0; i < N; ++i) // create and start threads
       e.execute(new WorkerRunnable(doneSignal, i));

     doneSignal.await();           // wait for all to finish
   }
 }

 class WorkerRunnable implements Runnable {
   private final CountDownLatch doneSignal;
   private final int i;
   WorkerRunnable(CountDownLatch doneSignal, int i) {
     this.doneSignal = doneSignal;
     this.i = i;
   }
   public void run() {
     try {
       doWork(i);
       doneSignal.countDown();
     } catch (InterruptedException ex) {} // return;
   }

   void doWork() { ... }
 }
```

# CyclicBarrier

允许一组线程全部等待彼此到达共同的障碍点。

CyclicBarrier支持可选的Runnable命令，该命令在每个障碍点运行一次，在聚会中的最后一个线程到达之后，但在释放任何线程之前。

|           | 方法和描述                                                   |
| --------- | ------------------------------------------------------------ |
| `int`     | `await()`Waits until all [parties](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CyclicBarrier.html#getParties--) have invoked `await` on this barrier. |
| `int`     | `await(long timeout, TimeUnit unit)`Waits until all [parties](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CyclicBarrier.html#getParties--) have invoked `await` on this barrier, or the specified waiting time elapses. |
| `int`     | `getNumberWaiting()`Returns the number of parties currently waiting at the barrier. |
| `int`     | `getParties()`Returns the number of parties required to trip this barrier. |
| `boolean` | `isBroken()`Queries if this barrier is in a broken state.    |
| `void`    | `reset()`Resets the barrier to its initial state.            |

# Semaphore

Semaphore是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。Semaphore可以用来构建一些对象池，资源池之类的，比如数据库连接池，我们也可以创建计数为1的Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量，表示两种互斥状态。

```java
 class Pool {
   private static final int MAX_AVAILABLE = 100;
   private final Semaphore available = new Semaphore(MAX_AVAILABLE, true);

   public Object getItem() throws InterruptedException {
     available.acquire();
     return getNextAvailableItem();
   }

   public void putItem(Object x) {
     if (markAsUnused(x))
       available.release();
   }

   // Not a particularly efficient data structure; just for demo

   protected Object[] items = ... whatever kinds of items being managed
   protected boolean[] used = new boolean[MAX_AVAILABLE];

   protected synchronized Object getNextAvailableItem() {
     for (int i = 0; i < MAX_AVAILABLE; ++i) {
       if (!used[i]) {
          used[i] = true;
          return items[i];
       }
     }
     return null; // not reached
   }

   protected synchronized boolean markAsUnused(Object item) {
     for (int i = 0; i < MAX_AVAILABLE; ++i) {
       if (item == items[i]) {
          if (used[i]) {
            used[i] = false;
            return true;
          } else
            return false;
       }
     }
     return false;
   }
 }
```



