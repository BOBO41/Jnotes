# Executor框架

程序的使命就是要完成一项工作（work），一项工作由多个任务（task）组成，多线程让任务可以并发执行，从而提高了程序运行效率。在Java中，线程是很宝贵的资源，不合理的创建和销毁线程会影响程序的运行效率，为此Java提供了Executor框架。Executor顾名思义就是执行器，用来执行任务的。它使用了线程池设计模式，用线程池中的线程来执行用户提交的任务。

Executor框架的作用：

- 对任务提交和任务的执行进行了解耦
- 线程的复用

```java
public interface Executor {
    // 提供任务
    void execute(Runnable command);
}
```

## 线程池

线程池管理一组工作线程，这些工作线程会被复用，从而减少了不断创建和销毁线程而造成的资源浪费。

Executor框架提供了5种线程池的实现，我们可以通过Executors的静态工厂来创建它们。

- `newFixedThreadPool` 固定大小的线程池，每当有新任务提交就创建一个线程，直到线程数量达到指定的最大值，然后保持线程池的大小，如果有线程死亡了，就重新创建一个新的。
- `newCachedThreadPool` 根据实际情况创建和回收线程，不限制线程的创建数量。
- `newSingleThreadExecutor` 创建一个工作线程来执行任务，如果该线程死亡，就创建一个新的。
- `newScheduledThreadPool` 一个固定大小的线程池，支持任务的延迟和定时执行。

### 自定义线程池

通过`ThreadPoolExEcutor`我们可以自定义创建线程池。

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
	// .............
}
```

- `corePoolSize` ：线程池中线程的基本数量，除非设置了`allowCoreThreadTimeOut`，否则，就算里面的线程是闲置的，也不会进行回收。

  ```java
  // 默认为false，就算线程是闲置的也不会被回收。
  // 如果设置为true，闲置的线程可以存活keepAliveTime设置的时间
  private volatile boolean allowCoreThreadTimeOut;
  ```

- `maximumPoolSize` ：线程池中允许存在的最大线程数。

- `keepAliveTime` ： 空闲线程存活的时间

- `unit` ：时间单元

- `workQueue` ： 用来存放任务的队列

- `threadFactory` ：用来创建线程的工厂

- `handler` ： 用来处理无法执行的任务，例如任务队列已经满了，或者任务提交到一个已经被关闭的Executor。



## Executor生命周期管理

`ExecutorService`是`Executor`的扩展，它添加了对`Executor`的生命周期进行管理的功能（当然还有一些方便提交任务的方法）。

`Executo`r的生命周期分为三阶段，正在运行、正在关闭、已终止。

```java
// Executor与生命周期管理相关的方法
public interface ExecutorService extends Executor {
	// 关闭Executor，不再接受新任务，等待已提交的任务执行完毕。
    void shutdown();
    // 强制关闭关闭Executor，不再接受新任务，尝试终止正在执行的任务，不执行已提交但在等待执行的任务
    List<Runnable> shutdownNow();
    
    // Executor关闭以后提交的任务都由RejectedExecutionHandler进行处理。
	
    // 判断Executor是否处于正在关闭状态
    boolean isShutdown();
    
    // 判断Executor是否处于已终止状态
    boolean isTerminated();
    
    // 当任务都执行完毕后，Executor就会进入已终止状态，调用该方法可以等待Executor进入已终止状态
    boolean awaitTermination(long timeout, TimeUnit unit)
        throws InterruptedException;
}
```

## Callable与Future

`Runnable`是一个非常有限的抽象，它不能返回任务执行后的结果，如果需要任务执行后返回结果，我们可以使用`Callable`。

Future代表任务的生命周期，它可以取消任务、获取任务结果、查看任务是否已执行完毕，是否已被取消。

```java
@FunctionalInterface
public interface Callable<V> {
    V call() throws Exception;
}
```

```java
public interface Future<V> {
    boolean cancel(boolean mayInterruptIfRunning);
    boolean isCancelled();
    boolean isDone();
    V get() throws InterruptedException, ExecutionException;
    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
```

有以下方法可以获取`Future`对象

- 调用`ExecutorService`中的`submit`方法，提供一个`Runnable`或`Callable`
- 创建`FutureTask`对象，`FutureTask`实现了`Runnable`接口，你可以把它提交给`ExecutorService`，也可以直接调用它的`run`方法。

## CompletionService

当你有一批任务需要执行，并且需要在它们执行完毕后获取它们的结果，这时候你就可以使用`CompletionService`。

`CompletionService`使用了`Executor`和`BlockingQueue`，前者用来执行任务，后者用来获取存储执行完的`Future`对象。

# 取消与关闭

在大部分情况下，我们会让线程运行直到结束，然而有些时候，我们希望能提前结束线程。

## 取消标记

Java没有安全的抢占式方式来结束线程。

**取消标志**，任务定时查看该标志，决定是否要提供结束该任务。

```java
// 生成素数任务
public class PrimeGenerator implements Runnable {

   private final List<BigInteger> primes = new ArrayList<>();

   private volatile boolean cancelled;

   @Override
   public void run() {
      BigInteger p = BigInteger.ONE;
      while (!cancelled) {
         p = p.nextProbablePrime();
         synchronized (this) {
            primes.add(p);
         }
      }
   }

   public void cancel() {
      cancelled = true;
   }

   public synchronized List<BigInteger> getPrimes() {
      return primes;
   }

   public static void main(String[] args) {
      PrimeGenerator generator = new PrimeGenerator();
      new Thread(generator).start();
      try {
         SECONDS.sleep(1);
      } catch (InterruptedException e) {
         e.printStackTrace();
      }finally {
         generator.cancel();
      }
      System.out.println(generator.getPrimes());
   }

}
```

取消标志这种协作机制有一个问题，那就是任务有可能被阻塞，导致无法对取消标志进行判断。

## 线程中断

每个线程都有一个`boolean`类型的变量用来表示该线程是否处于中断状态。`Thread`中提供了中断线程以及查询线程中断状态的方法。

```java
public class Thread{
    public void interrupt(){}
    // 判断是否处于中断状态
    public boolean isInterrupt(){}
    // 清除当前线程的中断状态，并返回它之前的值，这是清除中断状态的唯一方法
    public static boolean interrupted(){}
}
```

中断通常是实现取消的最合理方式。

```java
@Log
public class Demo {

   public static void main(String[] args) {

      PrimeProducer producer = new PrimeProducer(new ArrayBlockingQueue<>(10));
      producer.start();
      try {
         SECONDS.sleep(1);
      } catch (InterruptedException e) {
         e.printStackTrace();
      }
      producer.cancel();
   }

   private static class PrimeProducer extends Thread {
      private final BlockingQueue<BigInteger> queue;

      public PrimeProducer(BlockingQueue<BigInteger> queue) {
         this.queue = queue;
      }

      @Override
      public void run() {
         try {

            BigInteger p = BigInteger.ONE;
            while (!Thread.currentThread().isInterrupted()) {
               queue.put(p = p.nextProbablePrime());
               log.log(Level.INFO, "成功添加一个素数!");
            }
         } catch (InterruptedException exception) {
            log.log(Level.INFO, "the prime producer is interrupted !");
         }
      }

      public void cancel() {
         interrupt();
      }
   }

}
```

## Future

Future具有一个cancel方法。

```java
// 尝试取消执行该任务。
// 如果任务已经完成，那么取消失败。
// 如果任务由于某些原因不可取消，取消失败
// 如果任务还没开始，那么该任务不会被执行
// 如果任务已经开始，将由mayInterruptIfRunning参数决定是否需要通过中断线程的方式来取消该任务
// mayInterruptIfRunning 如果为true，中断执行该任务的线程。
boolean cancel(boolean mayInterruptIfRunning);
```

## 处理非正常的线程终止



## JVM关闭

