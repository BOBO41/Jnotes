## Condition

Condition接口可以让线程暂停执行，直到给定的条件（Condition）为真。

Lock用来代替synchronized，Condition用来代替Object的监控方法（wait, notify and notifyAll）。

|           | 方法和描述                                                   |
| --------- | ------------------------------------------------------------ |
| `void`    | `await()`线程进入等待状态直到接收到信号或者被打断            |
| `boolean` | `await(long time, TimeUnit unit)`Causes the current thread to wait until it is signalled or interrupted, or the specified waiting time elapses. |
| `long`    | `awaitNanos(long nanosTimeout)`Causes the current thread to wait until it is signalled or interrupted, or the specified waiting time elapses. |
| `void`    | `awaitUninterruptibly()`线程进入等待状态直到接收到信号       |
| `boolean` | `awaitUntil(Date deadline)`Causes the current thread to wait until it is signalled or interrupted, or the specified deadline elapses. |
| `void`    | `signal()`Wakes up one waiting thread.                       |
| `void`    | `signalAll()`Wakes up all waiting threads.                   |

例子

```java
 class BoundedBuffer {
   final Lock lock = new ReentrantLock();
   final Condition notFull  = lock.newCondition(); 
   final Condition notEmpty = lock.newCondition(); 

   final Object[] items = new Object[100];
   int putptr, takeptr, count;

   public void put(Object x) throws InterruptedException {
     lock.lock();
     try {
       while (count == items.length) notFull.await();
       items[putptr] = x;
       if (++putptr == items.length) putptr = 0;
       ++count;
       notEmpty.signal();
     } finally {
       lock.unlock();
     }
   }

   public Object take() throws InterruptedException {
     lock.lock();
     try {
       while (count == 0)
         notEmpty.await();
       Object x = items[takeptr];
       if (++takeptr == items.length) takeptr = 0;
       --count;
       notFull.signal();
       return x;
     } finally {
       lock.unlock();
     }
   }
 }
```



