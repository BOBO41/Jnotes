# 类的生命周期

一个类从被加载、连接和初始化开始，到被使用，最后被卸载，这整个过程成为类的生命周期。

类加载机制：虚拟机把Class文件中的数据加载进内存，然后对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。

## 1.类加载机制

类加载机制：虚拟机把Class文件中的数据加载进内存，然后对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。

类加载的全过程由加载、连接、初始化三部分所组成。其中连接又由验证、准备、解析三部分组成。

**注意：这些过程不是按部就班的执行的，有可能在执行一个过程的途中，执行另一个过程。**

![1540873591543](https://github.com/huangdaren1997/pictures/blob/master/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%9E%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96.png?raw=true)

### 1.1加载

**注意：加载是类加载过程的一个阶段，别混淆了。**

在加载阶段，虚拟机需要完成以下三个任务：

- 通过类的全限定名来获取定义此类的二进制字节流。

- 把类的数据结构存放在方法区中

- 在内存里创建一个`java.lang.Class`对象，作为在方法区中的这个类的各种数据结构的访问入口。

    （一般来说对象都是存放在Java堆里面，但是Class对象有点特殊，有些虚拟机的实现会把它放到方法区中）

![1540878379661](https://github.com/huangdaren1997/pictures/blob/master/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD.png?raw=true)

**注意：加载阶段和连接阶段的部分内容其实是交叉进行的，例如一部分字节码文件格式的验证。**

Java虚拟机能够从多种来源加载类的二进制数据

- 从本地文件系统加载类的.class文件
- 通过网络下载类的.class文件
- 从ZIP、JAR或其他归档文件中提取.class文件
- 从一个专有数据库中提取.class文件
- 把一个java源文件动态编译为.class文件

### 1.2连接

#### 1.2.1类的验证

验证的目的是确保Class文件的字节流中信息符合虚拟机的要求,不会危害虚拟机安全.

大致完成以下四个校验动作:

- 文件格式验证
- 源数据验证
- 字节码验证
- 符号引用验证

#### 1.2.2类的准备

在方法区中为类变量分配内存，并设置默认初始值；

```java
public static int value = 123；
// 这时候value的值为0，类初始化以后value才为123
public static final int value = 123；
// 被final修饰的类变量会在准备阶段进行正确的赋值，所以这里的value是123
```

#### 1.2.3类的解析

解析阶段是虚拟机把常量池内的符号引用替换为直接引用的过程。

**符号引用**：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。

```java
public void gotoWrok(){
    car.run(); // 这个car.run()就是符号引用，在解析阶段，会被替换成这个方法在内存位置的指针。
}
```

### 1.3初始化

在初始化阶段才是真正开始执行类中定义的Java程序代码（或者说是字节码）。

在初始化阶段，Java虚拟机执行类的初始化语句，为类的静态变量赋予初始值。

#### 1.3.1类的初始化时机

前面讲过，Java虚拟机只有在程序首次主动使用一个类或接口时才会初始化它，下面行为属于主动使用

- 创建类的实例，例如new、反射、克隆、反序列化
- 调用类的静态方法
- 访问或操作某个类或接口的静态变量
- 启动Java虚拟机时，指定运行的类 例如 `java Sample`

**注意**

对于final类型的静态变量，如果在编译时就能计算出变量的取值，那么这个变量会被看做是编译时常量，访问它不会导致类的初始化。

## 2.类加载器

**作用**：通过一个类的全限定名来获取描述此类的二进制字节流。

**分类**：

- Java虚拟机自带的加载器
- 用户自定义的类加载器

注意：类加载器可以在预料某个类将要被使用时就预先加载它，如果在预先加载过程，遇到.class文件缺失或存在错误，类加载器必须等到程序首次主动使用该类时才报告错误。如果该类没有被程序主动使用，则不报错。

类的加载过程采用双亲委派模型，除了Java虚拟机自带的启动类加载器以外，其余的类加载器都有且只有一个父加载器。

例如Java程序请求加载器A加载Sample类，加载器A会先委托自己的父类去加载Sample类，如果父类无法加载，那么才由加载器A来加载Sample类。

### 2.1类加载器的双亲委派模型

​	双亲委派模型是一种组织类加载器之间关系的一种规范,他的工作原理是:如果一个类加载器收到了类加载的请求,它不会自己去尝试加载这个类,而是把这个请求委派给父类加载器去完成,这样层层递进,最终所有的加载请求都被传到最顶层的启动类加载器中,只有当父类加载器无法完成这个加载请求(它的搜索范围内没有找到所需的类)时,才会交给子类加载器去尝试加载.

​	这样的好处是:Java类随着它的类加载器一起具备了带有优先级的层次关系.这是十分必要的,比如`java.langObject`,它存放在`/jre/lib/rt.jar`中,它是所有Java类的父类,因此无论哪个类加载都要加载这个类,最终所有的加载请求都汇总到顶层的启动类加载器中,因此`Object`类会由启动类加载器来加载,所以加载的都是同一个类,如果不使用双亲委派模型,由各个类加载器自行去加载的话,系统中就会出现不止一个`Object`类,应用程序就会全乱了.

### 2.2Java虚拟机自带类加载器

- 启动类加载器：没有父类加载器，负责加载核心类库，例如java.lang.*等
- 扩展类加载器：启动类加载器是它的父加载器，它从java.ext.dirs系统属性所指定的目录下加载类库，或者从JDK的安装目录的jre\lib\ext子目录下加载。它是java.lang.ClassLoader类的子类。
- 应用程序类加载器：扩展类加载器是它的父加载器，它从classpath环境变量或者系统属性java.class.path所指定的目录中加载类。它是java.lang.ClassLoader类的子类。是ClassLoader中的getSystemClassLoader方法的返回值。

### 2.3自定义类加载器

要创建自己的类加载器，只需要继承`java.lang.ClassLoader`类，重写`findClass`方法即可。

### 2.4Class.forname()与ClassLoader.loadClass()

Class.forname():是一个静态方法,最常用的是Class.forname(String className);根据传入的类的全限定名返回一个Class对象.该方法在将Class文件加载到内存的同时,会执行类的初始化.

ClassLoader.loadClass():这是一个实例方法,需要一个ClassLoader对象来调用该方法,该方法将Class文件加载到内存时,并不会执行类的初始化,直到这个类第一次使用时才进行初始化.该方法因为需要得到一个ClassLoader对象,所以可以根据需要指定使用哪个类加载器.

## 3.类的卸载

Java虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载。也就是用户自定义的类加载器所加载的类才会被卸载



