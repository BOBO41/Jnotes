---
title : 3.对象的生命周期
categories : 
- JavaSE
- ch5类与对象的生命周期
date : 2018-10-31
---

# 对象的生命周期

对象的生命周期就是对象从创建到销毁这一个过程。

## 1.对象的创建方式与过程

**1.1有4种显式地创建对象的方式：**

- new
- 反射
- 对象的clone方法
- 反序列化手段

**1.2对象的创建过程**

1. 给对象分配内存
2. 将对象的实例变量自动初始化为其变量类型的默认值
3. 初始化对象，主要负责给实例变量赋予正确的初始值

对于第3步，不同方法创建对象其初始化不一样

- clone方法创建的，那就把被克隆对象的实例变量的值复制到新对象中
- 如果对象是通过反序列化方式创建了，那就从输入流中读入数据来初始化

## 2.对象的销毁：垃圾回收

当对象被创建后，就会在Java虚拟机的堆区中拥有一块内存，如果对象没用了，那么就Java虚拟机的垃圾回收器就会回收对象。

### 2.1对象的触及状性

- 可触及状态：对象被创建后，有引用变量引用它。
- 可复活状态：对象没有被任何引用变量引用。在这个状态下，垃圾回收器会准备释放它占用的内存，在释放之前会调用它及其其它该状态下的对象的`finalize`方法，这些方法有可能使对象转为可触及状态。
- 不可触及状态：对象执行了`finalize`方法后没有恢复成可触及状态，就会变成不可触及状态，这时候垃圾回收器才会真正的收回它占用的内存。

### 2.2finalize方法

`finalize`方法定义在Object类

```java
protected void finalize() throws Throwable { }
```

## 3.深入垃圾回收

### 3.1无用对象的判定

**引用计数算法**

给对象添加一个引用计数器，没当有一个地方引用它，引用次数加1。

缺点：难以解决相互循环引用问题。

**可达性分析算法**

通过一系列称为`GC Roots`的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到`GC Roots`之间没有那么的引用链，则说明该对象不可用。

**关于GC Root**：GC Root不是垃圾回收目标区域的对象，譬如你要回收年轻代，那年老代必然是Root之一。

### 3.2垃圾收集算法

#### 3.2.1标记-清除算法

原理：标记出需要回收的对象，然后统一回收所有被标记的对象。

缺点：效率不高、而且清除后产生大量不连续的内存碎片。

#### 3.2.2复制算法

原理：把内存分为两部分，当其中一块内存用完，就把该内存中存活的对象复制到另一块内存中。

#### 3.2.3标记-整理-清除算法

原理：标记出需要回收的对象，让所有存活的对象往一端移动，然后直接清除掉端边界以外的内存。

#### 3.2.4分代收集算法

原理：根据对象存活周期的不同将内存划分为几块。一般分为新生代和老年代，然后根据各个年代的特点采用合适的收集算法。新生代死得快，所以采用复制算法，老年代则采用标记-整理算法。

关于新生代、老年代请看[新生代、老年代、永久代](https://www.cnblogs.com/snowwhite/p/9532311.html)。

