---
title : 1.JVM运行时数据区
categories : 
- JavaSE
- ch5类与对象的生命周期
date : 2018-10-30
---

# JVM运行时数据区

Java虚拟机在执行Java程序的时候，会把它所管理的内存划分为若干个不同的数据区域。

![](https://github.com/huangdaren1997/pictures/blob/master/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png?raw=true)

## 程序计数器（program counter）

Java虚拟机支持多线程，每个线程都具有自己的程序计数器。

在执行方法的时候，如果该方法不是本地方法（Native Method），程序计数器会记录当前正在执行的指令的地址。

如果执行的是本地方法，那么程序计数器的值为`undefined`

- 可以看作是当前线程所执行字节码的行号指示器
- 字节码解释器工作时就是通过改变这个计数器的值来获取下一条需要执行的字节码指令

我们学过多线程，有两个线程，其中一个线程可以暂停使用，让其他线程运行，然后等自己获得cpu资源时，又能从暂停的地方开始运行，那么为什么能够记住暂停的位置的，这就依靠了程序计数器， 通过这个例子，大概了解一下程序计数器的功能。

## 虚拟机栈

虚拟机内每个线程都具有自己虚拟机栈，用来存放栈帧。

每个方法在执行的同时都会创建一个**栈帧**用来存放存储局部变量表、操作数表、动态连接、方法出口等信息，每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。比如执行一个类(类中有main方法)时，执行到main方法，就会把为main方法创建一个栈帧，然后在加到虚拟机栈中，栈帧中会存放这main方法中的各种局部变量，对象引用等东西。我们常常听说的栈存储局部变量，说的就是这个。

在某些情况下虚拟机栈会出现以下异常：

- 线程请求的虚拟机栈大小超出了虚拟机的许可，出现栈溢出（`StackOverflowError`）
- 虚拟机栈的大小可以动态扩展，但是已经没有内容可以给它使用了，出现`OutOfMemoryError`

### 帧

- 帧用来存储数据和部分结果，同时也执行动态链接，返回方法结果，分发异常。
- 每次方法调用创建一个帧，方法执行完毕摧毁帧。 帧具有自己的局部变量和操作数栈，以及当前方法的类的运行时常量池的引用。
- 局部变量数组和操作数栈的大小在编译时期确定好

### 局部变量

帧具有的一组变量叫做本地变量。

### 操作数栈

每个帧包含一个后进先出（LIFO）堆栈，称为其操作数堆栈。

### 动态连接

### 内存模型

虚拟机栈描述的是Java方法执行的内存模型。什么是内存模型？ 有兴趣的可以看看着两篇文章

- [什么是内存模型？](https://www.cnblogs.com/adinosaur/p/6243605.html)
- [终于有人把Java内存模型说清楚了](http://developer.51cto.com/art/201807/579744.htm)

## 本地方法栈

本地方法栈与虚拟机栈所发挥的作用是非常相似的，只不过一个是为Java方法服务，一个是为Native方法服务。

## Java堆

**栈：后进先出**

**堆：先进先出**

Java堆是所有线程共享的一块内存区域，在虚拟机启动时创建。

它存储的对象由垃圾回收器进行回收。对象永远不会被显式释放。

堆的大小可以是固定的，也可以动态扩展，具体看它的实现。

Java堆也有`OutOfMemoryError`

## 方法区

方法区域类似于传统语言的编译代码的存储区域或类似于操作系统进程中的“文本”段。

- 各个线程共享的内存区域
- 存储类结构：例如运行时常量池、字段、方法数据、方法、构造器、类和实例和接口初始化使用的特殊方法（`special methods`）
- `OutOfMemoryError`

虽然方法区域在逻辑上是堆的一部分，但是简单的实现可能选择不垃圾收集或压缩它。

### 运行时常量池

- 运行时常量池是方法区的一部分。
- 运行时常量池用于存放编译期生成的各种字面量和符号引用。
- 符号引用：用一组符号来描述所引用的目标，符号可以是任意形式的字面量，只要使用时能无歧义的定位到目标即可。
- 运行时常量池包含几种常量，从编译时已知的数字文字到必须在运行时解析的方法和字段引用。
