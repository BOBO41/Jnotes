1. 并发编程会出现什么问题？这些问题的定义是什么？
2. 产生这些问题的原因是什么？
3. 如何解决这些问题？
4. 其它专业术语

# 1.并发的三个问题

并发问题的本质是同步问题，我们又把同步问题细分为下面三种类型。

## 1.1原子性问题

**原子性操作**：一般我们认为原子是不可再分的，在编程领域中，原子性操作指的是一组操作是不可再分的，这组操作是一个统一的整体，这组操作在执行的过程中不会其它因素干扰，例如执行过程中被中断、或者执行过程中所用到的值被偷偷修改了。在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作。例如

```java
x = 10;
y = x;
```

**注意**：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。

```java
x += 1；
x = x + 1;
// 上面这种就不是原子性操作了，
```

**原子性问题**：我想不到、也找不到一个正式的定义，只能通过例子来讲。

例如 `x = x + 1;`这个操作。
假设当前`x = 9`，然后有两个线程同时执行上面这条语句。
由于两个线程都读到x的值为9，然后都执行递增操作，最后x的值变为10， 而不是预期的11。
这种问题就是原子性问题。

### 产生的原因

有些操作在被多个线程同时执行的时候，无法保证当前使用的数据的有效性。

### 解决方案

- 原子类

    Java提供的原子类，底层通过CAS机制保证原子性

- synchronized

## 1.2可见性问题

**可见性问题**：当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程没有立即看得到修改的值，而是继续使用失效的值，最终导致结果出现问题。

### 产生的原因

缓存一致性问题

### 解决方案

Java中的`volatile`关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用`volatile`来保证多线程操作时变量的可见性。除了`volatile`，Java中的`synchronized`和`final`两个关键字也可以实现可见性。只不过实现方式不同，这里不再展开了。

## 1.3有序性问题

**有序性问题**：程序执行的顺序与编写代码的先后顺序不一致。

### 产生的原因

- 编译器指令重排

    编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。 

- CPU乱序执行

    现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器 可以改变语句对应机器指令的执行顺序。 

- 内存系统的重排序

    由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

### 解决方案

在Java中，可以使用`synchronized`和`volatile`来保证多线程之间操作的有序性。实现方式有所区别：

`volatile`关键字会禁止指令重排。

`synchronized`关键字保证同一时刻只允许一条线程操作。进出锁住的代码块是串行的，因为只能有一个线程拿到锁，这就使得使用同一个锁的两个执行过程A和B之间，A看B的操作是有序的，B看A的操作也是有序的，是因为执行过程内部无论会不会指令重排序，结果都是一致的。但是锁的内部代码依然会指令重排序。



