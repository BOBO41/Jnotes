# InnoDB中的锁和事务模型

要实现大规模，繁忙或高度可靠的数据库应用程序，从不同的数据库系统移植大量代码，或调整MySQL性能，我们需要了解InnoDB的锁和事务模型。

## 1.InnoDB中的锁

### 1.1共享锁和独占锁

InnoDB实现了两种类型的行锁，分别是共享锁和独占锁。

共享锁允许持有该锁的事务读取行。

独占锁允许持有该锁的事务更新和删除行。

如果事务T1持有行r的共享锁，那么另一个事务T2只能获取该行的共享锁，也就是只能读取行数据。

如果事务T1持有行r的独占锁，那么另一个事务T2将什么锁都无法获取。

### 1.2Intention Locks

InnoDB支持多种粒度锁，允许行锁和表锁共存。例如语句`LOCK TABLES ... WRITE`会获取指定表的独占锁。为了实现多个粒度级别的锁定，InnoDB使用Intention Locks（意向锁）。意向锁是表级锁，指示事务稍后对表中的行所需的锁定类型（共享或独占）。意向锁有两种类型：

-   **意向共享锁（IS）**表示事务打算在表中的某几行上设置共享锁。
-   **意向排他锁（IX）**表示事务打算在表中的某几行上设置独占锁。

例如，`SELECT ... LOCK IN SHARE MODE`设置IS锁定，`SELECT ... FOR UPDATE`设置IX锁定。

意向锁协议如下：

-   在事务可以获取表中某一行的共享锁之前，它必须首先在表上获取IS锁或更高级别的IX锁。
-   在事务可以获取表中某一行的独占锁之前，它必须首先获取表上的IX锁。

### 1.3记录锁

记录锁（record locks）用于索引记录上。例如`SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE`；防止其它事务对 `t.c1` is `10`的行进行增删改。

### 1.4Gap Locks

Gap Lock是锁定索引记录之间的间隙，或锁定在第一个或最后一个索引记录之前的间隙。例如`SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE`

## 2.InnoDB事务模型

### 2.1事务的隔离级别

事务的隔离级别（Transaction Isolation Levels）