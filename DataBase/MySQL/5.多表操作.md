---
title : 5.多表操作
categories : 
- DataBase
- MySQL
date : 2018-5-5
---
# 多表操作

## 多表检索

### 1.使用连接实现多表检索

连接（join）

#### 内连接

一个表的的所有行与另一个表的所有行，排列组合。

我们可以通过ON子句来添加排列组合的规则,从而减少排列组合的结果数

```sql
SELECT * FROM t1 INNER JOIN t2 ON t1.i1 = t2.i2
```

#### 左（外）连接和右（外）连接

内连接只会显示在连个表里都匹配上的行。外连接除了显示同样的结果，还可以把其中一个表在另一个表没有匹配的行也显示出来。左连接就是把左表里没有匹配的内容也显示出来。

```sql
SELECT *
FROM t1
       LEFT JOIN t2 on t1.i1 = t2.i2
ORDER BY t1.i1 ASC;
```

### 2.使用子查询实现多表检索

子查询：用括号括起来，并嵌入另一条语句里的那条SELECT语句。

```sql
SELECT * FROM socre WHERE event_id IN (SELECT event_id FROM grade_event WHERE category = 'T');
```

子查询可以返回各种不同类型的信息

- 标量子查询：返回一个值
- 列子查询：返回一个由一个值或多个值构成的列
- 行子查询：返回一个由一个值或多个值构成的行
- 表子查询：返回一个由一个行或多个行组成的表

#### IN 和 NOT IN 子查询

```sql
# 查询逃课学生
SELECT * FROM student WHERE student_id IN (SELECT student_id FROM absence);
# 查询全勤学生
SELECT * FROM student WHERE student_id NOT IN (SELECT student_id FROM absence);
```

#### ALL、ANY和SOME子查询

```sql
# 外查询找出比子查询的到的生日都要小的生日
SELECT last_name ,first_name birth FORM persident WHERE birth <= ALL (SELECT birth FROM president);

SELECT last_name ,first_name birth FORM persident WHERE birth <= ANY (SELECT birth FROM president);

SELECT last_name ,first_name , state , city FORM persident WHERE (state,city) = ANY (SELECT state , city FORM persident WHERE last_name = 'Roosevelt');
```

#### EXISTS 和 NOT EXISTS 子查询

这两个运算符只会测试某个子查询是否返回了行。如果有返回，EXISTS结果为真。

#### FORM子句里的子查询

```sql
SELECT * FROM (SELECT 1,2) AS t1 INNER JOIN (SELECT 3,4) AS t2;
```

### 3.使用UNION实现多表检索

如果想把多个查询的结果合并成一个结果集，那么需要使用`UNION`语句。

```sql
SELECT i FROM t1 UNION SELECT j FROM t2 UNION  SELECT k FROM t3;
```

#### UNION的特性

- 列名和数据类型

    `UNION`结果集里的列名来自第一个SELECT里的列名。UNION选取的列数，必须跟第一个SELECT选取的列数相同。各列不需要名字相同，甚至数据结构也不需要相同，MySQL会进行必要的类型转换。

- 重复行处理

    默认情况下，UNION会将结果集里的重复行剔除掉

    如果想保留重复的行，则需要把UNION 改为 UNION ALL

- ORDER BY 和 LIMIT处理

    如果想对UNION结果作为一个整天进行排序，那么需要用括号把每个SELECT语句括起来，并在最后加上ORDER BY子句。ORDER BY子句必须引用第一个SELECT语句选中的列名。

    ```sql
    (SELECT i FROM t1) UNION ALL (SELECT j FROM t2) UNION ALL (SELECT k FROM t3) 
    ORDER BY i;
    ```

## 多表删除

在编写涉及多表的DELETE语句时，需要把所有涉及的表全部列在FROM子句里，并把用来匹配表中各行的检索条件写在WHERE子句里。

```sql
DELETE t1 FROM t1 INNDER JOIN t2 ON t1.id=t2.id;
DELETE t1,t2 FROM t1 INNER JOIN t2 ON t1.id = t2.id;
DELETE t1 FROM t1 LEAF JOIN t2 ON t1.id = t2.id WHERE t2.id IS NULL;

DELETE FROM t1 USING t1 INNDER JOIN t2 ON t1.id = t2.id;
DELETE FROM t1,t2 USING t1 INNDER JOIN t2 ON t1.id = t2.id;
DELETE FROM t1 USING t1 LEFT JOIN t2 ON t1.id = t2.id WHERE t2.id IS NULL;
```



## 多表更新

```sql
UPDATE score, grade_event SET score.score = score.score + 1
WHERE score.event_id = grade_event.event_id
AND grade_event.date = '2012-09-23' AND grade_event.category = 'Q';

UPDATE t1, t2 SET t2.a = t1.a WHERE t2.id = t1.id;
```



