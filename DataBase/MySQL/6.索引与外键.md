

# 索引

所谓索引就是为特定的数据表字段进行一些特定的算法排序,比如二叉树的算法和哈希算法,哈希算法是通过建立特征值,然后根据特征值来快速查找,而用的最多,并且是`MySQL`默认的就是二叉树算法 `BTREE`,通过`BTREE`算法建立索引的字段,比如扫描20行就能得到未使用`BTREE`前扫描了2^20行的结果。

## 1.索引的类型

**UNIQUE唯一索引**

不可以出现相同的值,可以有NULL值

**INDEX普通索引**

允许出现相同的索引内容

**PRIMARY KEY主键索引**

不允许出现相同的值,且不能为NULL值,一个表只能有一个主键索引

**FULLTEXT INDEX 全文索引**

上述三种索引都是针对列的值发挥作用,但全文索引,可以针对值中的某个单词,比如一篇文章中的某个词

**然而并没有什么卵用,因为只有myisam以及英文支持,并且效率让人不敢恭维,可以用coreseek和xunsearch等第三方应用来完成这个需求**

## 2.索引的CURD

### 2.1创建索引

```sql
ALTER TABLE table_name ADD INDEX index_name (index_columns)；
ALTER TABLE table_name ADD UNIQUE index_name (index_columns)；
ALTER TABLE table_name ADD PRIMARY KEY index_name (index_columns)；
ALTER TABLE table_name ADD FULLTEXT index_name (index_columns)；

CREATE TABLE `test1` (
  `id` smallint(5) UNSIGNED AUTO_INCREMENT NOT NULL, -- 注意,下面创建了主键索引,这里就不用创建了
  `username` varchar(64) NOT NULL COMMENT '用户名',
  `nickname` varchar(50) NOT NULL COMMENT '昵称/姓名',
  `intro` text,
  PRIMARY KEY (`id`), 
  UNIQUE KEY `unique1` (`username`), -- 索引名称,可要可不要,不要就是和列名一样
  KEY `index1` (`nickname`),
  FULLTEXT KEY `intro` (`intro`)
) ENGINE=MyISAM AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 COMMENT='后台用户表';
```

### 2.2查看索引

```sql
show index FROM tablename；
```

### 2.3删除索引

```SQL
ALTER TABLE table_name DROP INDEX index_name;
```

## 3.创建索引的技巧

1. 维度高的列创建索引

    数据列中**不重复值**的个数越多,维度就越高，如数据表中存在8行数据a ,b ,c,d,a,b,c,d这个表的维度为4。
    要为维度高的列创建索引,如性别和年龄,那年龄的维度就高于性别，性别这样的列不适合创建索引,因为维度过低。

2. 对 **where,on,group by,order by** 中出现的列使用索引

3. 对较小的数据列使用索引,这样会使索引文件更小,同时内存中也可以装载更多的索引键

4. 为较长的字符串使用**前缀索引**

5. 不要过多创建索引,除了增加额外的磁盘空间外,对于`DML`操作的速度影响很大,因为其每增删改一次就得从新建立索引

6. 使用**组合索引**,可以减少文件索引大小,在使用时速度要优于多个单列索引

### 3.1组合索引与前缀索引

**注意,这两种称呼是对建立索引技巧的一种称呼,并非索引的类型。**

#### 3.1.1组合索引

MySQL单列索引和组合索引究竟有何区别呢？

为了形象地对比两者,先建一个表：

```sql
CREATE TABLE `myIndex` (
  `i_testID` INT NOT NULL AUTO_INCREMENT, 
  `vc_Name` VARCHAR(50) NOT NULL, 
  `vc_City` VARCHAR(50) NOT NULL, 
  `i_Age` INT NOT NULL, 
  `i_SchoolID` INT NOT NULL, 
  PRIMARY KEY (`i_testID`) 
);
```

假设表内已有1000条数据,在这 10000 条记录里面分布了 5 条` vc_Name="erquan"` 的记录,只不过 city,age,school 的组合各不相同。
来看这条 T-SQL：

```sql
SELECT `i_testID` FROM `myIndex` WHERE `vc_Name`='erquan' AND `vc_City`='郑州' AND `i_Age`=25; -- 关联搜索;
```

**首先考虑建MySQL单列索引：**

在 `vc_Name` 列上建立了索引。执行 `T-SQL` 时,`MYSQL` 很快将目标锁定在了 `vc_Name=erquan` 的 5 条记录上,取出来放到一中间结果集。在这个结果集里,先排除掉 `vc_City` 不等于"郑州"的记录,再排除 `i_Age` 不等于 25 的记录,最后筛选出唯一的符合条件的记录。
虽然在 `vc_Name` 上建立了索引,查询时`MYSQL`不用扫描整张表,效率有所提高,但离我们的要求还有一定的距离。同样的,在 `vc_City` 和`i_Age`分别建立的MySQL单列索引的效率相似。

为了进一步榨取 MySQL 的效率,就要考虑建立组合索引。就是将`vc_Name,vc_City,i_Age`建到一个索引里：

```sql
 ALTER TABLE `myIndex` ADD INDEX `name_city_age` (vc_Name(10),vc_City,i_Age);
```

建表时,vc_Name 长度为 50,这里为什么用 10 呢？这就是下文要说到的前缀索引,因为一般情况下名字的长度不会超过 10,这样会加速索引查询速度,还会减少索引文件的大小,提高 INSERT 的更新速度。

执行 T-SQL 时,MySQL 无须扫描任何记录就到找到唯一的记录！！

如果分别在 vc_Name,vc_City,i_Age 上建立单列索引,让该表有 3 个单列索引,查询时和上述的组合索引效率一样吗？答案是大不一样,远远低于我们的组合索引。虽然此时有了三个索引,**但 MySQL 只能用到其中的那个它认为似乎是最有效率的单列索引,另外两个是用不到的**。

建立这样的组合索引,其实是相当于分别建立了

```
vc_Name,vc_City,i_Age
vc_Name,vc_City
vc_Name
```

这样的三个组合索引！为什么没有 vc_City,i_Age 等这样的组合索引呢？这是因为 mysql 组合索引**"最左前缀"**的结果。简单的理解就是只从最左面的开始组合。并不是只要包含这三列的查询都会用到该组合索引,下面的几个 T-SQL 会用到：

```
SELECT * FROM myIndex WHREE vc_Name="erquan" AND vc_City="郑州"
SELECT * FROM myIndex WHREE vc_Name="erquan"
```

而下面几个则不会用到：

```
SELECT * FROM myIndex WHREE i_Age=20 AND vc_City="郑州"
SELECT * FROM myIndex WHREE vc_City="郑州"
```

**也就是,name_city_age (vc_Name(10),vc_City,i_Age) 从左到右进行索引,如果没有左前索引Mysql不执行索引查询**

#### 3.1.2前缀索引

如果索引列长度过长,这种列索引时将会产生很大的索引文件,不便于操作,可以使用前缀索引方式进行索引
前缀索引应该控制在一个合适的点,控制在0.31黄金值即可(大于这个值就可以创建)

```sql
SELECT COUNT(DISTINCT(LEFT(`title`,10)))/COUNT(*) FROM Arctic; 
-- 这个值大于0.31就可以创建前缀索引,Distinct去重复

ALTER TABLE `user` ADD INDEX `uname`(title(10)); 
-- 增加前缀索引SQL,将人名的索引建立在10,这样可以减少索引文件大小,加快索引查询速度
```

### 3.2不用索引的SQL

要尽量避免这些不走索引的SQL

```sql
SELECT `sname` FROM `stu` WHERE `age`+10=30;
-- 不会使用索引,因为所有索引列参与了计算

SELECT `sname` FROM `stu` WHERE LEFT(`date`,4) <1990; 
-- 不会使用索引,因为使用了函数运算,原理与上面相同

SELECT * FROM `houdunwang` WHERE `uname` LIKE'后盾%' -- 走索引
SELECT * FROM `houdunwang` WHERE `uname` LIKE "%后盾%" -- 不走索引
-- 正则表达式不使用索引,这应该很好理解,所以为什么在SQL中很难看到regexp关键字的原因

-- 字符串与数字比较不使用索引;
CREATE TABLE `a` (`a` char(10));
EXPLAIN SELECT * FROM `a` WHERE `a`="1" -- 走索引
EXPLAIN SELECT * FROM `a` WHERE `a`=1 -- 不走索引

select * from dept where dname='xxx' or loc='xx' or deptno=45 
--如果条件中有or,即使其中有条件带索引也不会使用。
--换言之,就是要求使用的所有字段,都必须建立索引, 我们建议大家尽量避免使用or关键字

-- 如果mysql估计使用全表扫描要比使用索引快,则不使用索引
```

### 3.3索引的弊端

不要盲目的创建索引,只为查询操作频繁的列创建索引,创建索引会使查询操作变得更加快速,但是会降低增加、删除、更新操作的速度,因为执行这些操作的同时会对索引文件进行重新排序或更新;

但是,在互联网应用中,查询的语句远远大于DML的语句,甚至可以占到80%~90%,所以也不要太在意,只是在大数据导入时,可以先删除索引,再批量插入数据,最后再添加索引;

## X.Explain优化查询检测

EXPLAIN可以帮助开发人员分析`SQL`问题,EXPLAIN显示了`MySQL`如何使用索引来处理`SELECT`语句以及连接表,可以帮助选择更好的索引和写出更优化的查询语句.

# 外键

