## 遍历二叉树

### 前序遍历

```java
public List<Integer> preorderTraversal(TreeNode root) {
	LinkedList<Integer> resList = new LinkedList<>();
	Deque<TreeNode> rights = new LinkedList<>();
	TreeNode cur = root;
    
	while(cur != null || !rights.isEmpty()){
		resList.add(cur.val);
        
		if(cur.right != null){
			rights.offerFirst(cur.right);
		}
    // 没有元素的时候pollFirst能返回null这个很关键
		cur = cur.left == null ? rights.pollFirst() : cur.left;
	}
	return resList;
}
```
### 后序遍历

```java
public List<Integer> postorderTraversal(TreeNode root) {
    
	LinkedList<Integer> resList = new LinkedList<>();
	Deque<TreeNode> lefts = new LinkedList<>();
	TreeNode cur = root;
    
	while(cur != null || !lefts.isEmpty()){
		resList.offerFirst(cur.val);
        
		if(cur.left != null){
			lefts.offerFirst(cur.left);
		}
        
		cur = cur.right == null ? lefts.pollFirst() : cur.right;
	}
	return resList;
}
```
### 中序遍历

```java
    public List<Integer> inorderTraversal(TreeNode root) {
		List<Integer> resList = new ArrayList<>();
		Deque<TreeNode> nodes = new LinkedList<>();

		TreeNode cur = root;
		while(cur != null || !nodes.isEmpty()){

			while(cur != null){
				nodes.offerFirst(cur);
				cur = cur.left;
			}

			cur = nodes.pollFirst();
			resList.add(cur.val);
			cur = cur.right;
		}
		return resList;
    }
```

### 层级遍历

```java
public List<List<Integer>> levelOrder(TreeNode root) {
	List<List<Integer>> resList = new ArrayList<>();
	Queue<TreeNode> queue = new LinkedList<>();

	if (root == null) {
		return resList;
	}

	queue.offer(root);
	TreeNode cur;
	while (!queue.isEmpty()) {
		
		int levelNodes = queue.size();
		List<Integer> subList = new ArrayList<>();
		
		for (int i = 0; i < levelNodes; i++) {
			cur = queue.poll();
			if (cur.left != null) queue.offer(cur.left);
			if (cur.right != null) queue.offer(cur.right);
			subList.add(cur.val);
		}
		resList.add(subList);
	}
	return resList;
}
```
## 二叉树的最大深度

```java
    public int maxDepth(TreeNode root) {
        return (root == null)? 0 : Math.max(maxDepth(root.left), maxDepth(root.right))+1;
    }
```

## 对称树

```java
public boolean isSymmetric(TreeNode root) {
  if(root == null) return true;
  return isSymmetric(root.left, root.right);
}

private boolean isSymmetric(TreeNode left, TreeNode right){
    if(left==null || right==null)
        return left==right;
    if(left.val!=right.val)
        return false;
    return isSymmetricHelp(left.left, right.right) && isSymmetricHelp(left.right, right.left);
}
```

## 路径和

```java
public class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if(root == null) return false;
    
        if(root.left == null && root.right == null && sum - root.val == 0) return true;
    
        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
    }
}
```