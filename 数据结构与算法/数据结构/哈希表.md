# 哈希表

## 简介

哈希表其实就是由哈希函数加数组所组成的一种数据结构。

如果有所的键都是小正数，那么我们可以使用一个数组来实现无序的符号表。将键作为数组的索引，索引所对应的位置存放键对应的值。

但是在实际使用中，所有键都是小正数的情况还是比较少见的。这时候我们需要一个哈希函数，可以把键转化为数组的索引。

哈希表的查找算法主要分为两步，第一步是使用哈希函数将被查找的键转化为数组的一个索引。第二步就是处理哈希冲突，因为不同的键通过同一个哈希函数，可能会产生相同的索引，解决哈希冲突的常见方法有**拉链法**和**线性探测法**。

## 哈希函数

哈希函数与键的数据类型有关，严格来说，对于每种类型的键我们都需要一个与之对应的哈希函数。

如果键是一个数，我们可以直接使用这个数，如果键是一个字符串，我们就需要将这个字符串转换成一个数。等等。

其实Java已经为我们提供了哈希函数的默认实现，在Object类中就有一个hashCode方法，它返回一个int类型的整数，我们可以通过重写该方法，轻松为自己的抽象类型实现一个哈希函数。

不过了解多一点知识，总是没有坏的，接下来我们来看看一些典型的哈希函数。

### 正整数

作用于整数的哈希函数的最常用的实现方法就是**余数法**。假设数组大小为M，对于任意正整数K，计算K除以M的余数，从而得到一个索引位置。

### 浮点数

如果键是0到1之间的实数，我们可以将它乘以M然后四舍五入，那么就可以得到一个0~（M-1）之间的索引值。

如果是大于1的，那么就直接四舍五入，然后用余数法。

### 字符串

Java中的charAt方法能返回一个char值，它是一个非负16位整数。

### 重写hashCode方法



## 基于拉链法的哈希表

拉链法是解决哈希冲突的一种方法，本质就是将数组中的每个元素都指向一条链条，使用该链表来存储数据。

## 基于线性探测发的哈希表

解决哈希冲突的另一种方式是用大小M的数组保存N个键值对，其中M>N。我们依靠数组中的空位解决碰撞冲突。基于这种策略的所有方法统称为**开发地址哈希表**。其中最简单的方法叫做线性探测法。

插入元素时，当对应位置已存有元素，则查看下一个位置（索引+1），直到找到空闲位置。

## 调整数组大小

创建新的哈希表，遍历旧的哈希表把元素重新插入新的哈希表。

# HashMap源码解析

基于jdk8的HashMap源码解析。

## 简介

HashMap是基于哈希表的Map接口实现。它能接受null，无论是key还是value。

HashMap有四个容易让人迷糊的参数。分别是

- size 记录了Map中KV对的个数
- capacity 哈希表数组大小
- loadFactor 负载因子，用来衡量HashMap满的程度，loadFactor=size/capacity
- threshold 临界值，当实际KV个数超过临界值时，HashMap将被扩容，threshold=capacity*loadFactor

在看源码之前，需要有点位运算的知识。[可能是最通俗易懂的位运算讲解](https://blog.csdn.net/briblue/article/details/70296326)。

## Put函数的实现

1.HashMap底层使用`Node<K,V>[]`

```java
transient Node<K,V>[] table; // 用transient关键字标记的成员变量不参与序列化过程
static class Node<K,V> implements Map.Entry<K,V> {
    final int hash;
    final K key;
    V value;
    Node<K,V> next;

    Node(int hash, K key, V value, Node<K,V> next) {
        this.hash = hash;
        this.key = key;
        this.value = value;
        this.next = next;
    }
	
    // getter、setter
    public final K getKey()        { return key; }
    public final V getValue()      { return value; }
    
	public final V setValue(V newValue) {
        V oldValue = value;
        value = newValue;
        return oldValue;
    }
    
    // 重写toString
    public final String toString() { return key + "=" + value; }

    // 重写equals和hashCode
    public final int hashCode() {
        return Objects.hashCode(key) ^ Objects.hashCode(value);
    }

    public final boolean equals(Object o) {
        if (o == this)
            return true;
        if (o instanceof Map.Entry) {
            Map.Entry<?,?> e = (Map.Entry<?,?>)o;
            if (Objects.equals(key, e.getKey()) &&
                Objects.equals(value, e.getValue()))
                return true;
        }
        return false;
    }
}
```

2.对key进行hash运算，key的hashCode低16位与高16位异或。

```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

3.根据hash值计算出索引

```java
i = (n - 1) & hash // n是哈希表的容量
```

4.根据索引从哈希表中查找元素

- 如果元素不存在，则直接插入哈希表

  ```java
  if ((p = tab[i = (n - 1) & hash]) == null)
      tab[i] = newNode(hash, key, value, null);
  ```

- 如果元素存在

  - 判断key是否相同，相同则修改value。
  - 判断是否是红黑树（TreeNode），从红黑树找出节点，如果没有则创建，然后写入value。
  - 剩余就是链表了，遍历链表，如果不存在节点，则直接插入，然后判断是否需要转换成红黑树，如果存在则修改value。

```java
public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}
```

```java
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
    Node<K,V>[] tab; 
    Node<K,V> p; 
    int n; // 当前哈希表容量
    int i; // 该元素对应哈希表中的索引
    
    // 如果哈希表还没初始化或者哈希表容量为0
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
   /*
   	 i = (n - 1) & hash hash值与索引的关系
   */
    if ((p = tab[i = (n - 1) & hash]) == null) // 索引所对应的位置没有元素
        tab[i] = newNode(hash, key, value, null);
    else { // 哈希冲突
        Node<K,V> e; 
        K k;
        if (p.hash == hash &&
            ((k = p.key) == key || (key != null && key.equals(k))))
            // key相等，更新元素
            e = p;
        else if (p instanceof TreeNode)
            // 判断是否已经由链表转化为红黑树
            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
        else { // 遍历链表
            for (int binCount = 0; ; ++binCount) {
                if ((e = p.next) == null) { // 链表最后插入新元素
                    p.next = newNode(hash, key, value, null);
                    if (binCount >= TREEIFY_THRESHOLD - 1) // 链表太长、转化为红黑树
                        treeifyBin(tab, hash);
                    break;
                }
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    break;
                p = e;
            }
        }
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;
    if (++size > threshold)
        resize();
    afterNodeInsertion(evict);
    return null;
}
```

## GET函数的实现

```java
public V get(Object key) {
    Node<K,V> e;
    return (e = getNode(hash(key), key)) == null ? null : e.value;
}
```

```java
final Node<K,V> getNode(int hash, Object key) {
    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;
    if ((tab = table) != null && (n = tab.length) > 0 &&
        (first = tab[(n - 1) & hash]) != null) {
        if (first.hash == hash && // always check first node
            ((k = first.key) == key || (key != null && key.equals(k))))
            return first;
        if ((e = first.next) != null) {
            if (first instanceof TreeNode)
                return ((TreeNode<K,V>)first).getTreeNode(hash, key);
            do {
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    return e;
            } while ((e = e.next) != null);
        }
    }
    return null;
}
```

其它自己看。。。。。。

## 并发操作HashMap造成死锁

在1.7中，当数据put进HashMap的时候，都会比较和`thredhold`的大小，当超过临界值的时候，就会进行扩容操作，就会调用`resize()`方法。而`resize()`中调用了`transfer`方法。下面简单的看看`transfer`方法。

```java
void transfer(Entry[] newTable, boolean rehash) {
    int newCapacity = newTable.length;
    for (Entry<K,V> e : table) {
        while(null != e) {
            Entry<K,V> next = e.next;
            if (rehash) {
                e.hash = null == e.key ? 0 : hash(e.key);
            }
            int i = indexFor(e.hash, newCapacity);
            // -----------------------------------------------------
            e.next = newTable[i]; 
            newTable[i] = e; 
            // 转移的时候是逆序的。假如转移前链表顺序是1->2->3，那么转移后就会变成3->2->1。
            // ------------------------------------------------------
            e = next;
        }
    }
}
```

假设两个线程进入了`transfer`方法。旧表中索引为X的地方存储了一个1->2->3的链表。

线程1在新表中索引为X的地方已经存储了2->1的链表,然后该线程被切换了。

线程2在对旧表中索引为X的地方进行操作，它目前操作的是1，它把1插入到了新表中索引为X的地方

现在新表中索引为X的地方存储的是1->2->1，形成了一个循环引用。

在1.8中，`resize`方法没有使用`transfer`方法，不会因为多线程`put`导致死循环，但是依然有其他的弊端，比如数据丢失等。因此多线程情况下还是建议使用`ConcurrentHashMap`,

## 

