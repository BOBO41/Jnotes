## 题目描述

**题目：4.两个有序数组的中间数**

![1549164081522](/home/hdr/.config/Typora/typora-user-images/1549164081522.png)

给你两个int数组，数组里面的元素都是有序的，找出两个数组之间的中间数。

## 解题思路

参考归并排序里面的归并

## 代码实现

```java
public double findMedianSortedArrays(int[] nums1, int[] nums2) {
	int len = nums1.length + nums2.length;
	int m = 0, n = 0;
    
	int before = 0;
	while (m + n <= (len / 2) - 1) {
		if (m >= nums1.length) before = nums2[n++];
		else if (n >= nums2.length) before = nums1[m++];
		else if (nums1[m] < nums2[n]) before = nums1[m++];
		else before = nums2[n++];
	}

	int mid;
	if (m >= nums1.length) mid = nums2[n++];
	else if (n >= nums2.length) mid = nums1[m++];
	else if (nums1[m] < nums2[n]) mid = nums1[m++];
	else mid = nums2[n++];

	if ((len & 1) == 0) { // 
		return (before + mid) / 2.0;
	} else {
		return mid;
	}
}
```

## 题目描述

**题目：7.整数反转**

![1549164288107](/home/hdr/.config/Typora/typora-user-images/1549164288107.png)

## 解题思路

## 代码实现

```java
public int reverse(int x) {
  int result = 0;
	while (x != 0) {
		int tail = x % 10;
		int newResult = result * 10 + tail;
		// 防止翻转后数字超过Interge.MAX_VALUE；
		if((newResult-tail)/10!=result) return 0;
		result = newResult;
		x = x / 10;
	}
	return result;
}
```

## 题目描述

**题目：9.对称数**

![1549290995107](/home/hdr/.config/Typora/typora-user-images/1549290995107.png)

给你一个整数，判断它是否是一个对称数。

## 解题思路

其实就是上一道题目，整数反转的简化版本（因为不用考虑溢出问题）。

## 代码实现

```java
public boolean isPalindrome(int x) {
   if (x < 0) return false;
   int result = 0;
   int orig = x;
   while (x != 0) {
      result = result * 10 + x % 10;
      x = x / 10;
   }
   return result == orig;
}
```

