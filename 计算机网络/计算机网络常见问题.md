---
title : 计算机网络基础 
categories : 
- 计算机网络
date : 2018-11-25
---

# HTTP相关

## HTTP的长连接和短连接

HTTP的长连接和短连接本质上是TCP长连接和短连接。

**短连接** :浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。

**长连接** :当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。

## HTTP和HTTPS的区别

Http协议运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份；

Https是添加了加密和认证机制的HTTP，运行于SSL上，SSL运行于TCP之上，。

二者之间存在如下不同：

-   端口不同：Http与Http使用不同的连接方式，用的端口也不一样，前者是80，后者是443；
-   资源消耗：和HTTP通信相比，Https通信会由于加解密处理消耗更多的CPU和内存资源；
-   证书：Https通信需要证书，而证书一般需要向认证机构购买； 

## 对称加密与非对称加密

对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是如何保证秘钥安全的发送给对方。

非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。

虽然非对称加密很安全，但是它很慢，所以我们通过非对称加密来传递对称加密的秘钥，然后用非对称加密进行通信。

## HTTPS工作原理

**通信发生之前**

1.  服务器生成公钥(SPK,server public key)和密钥(SSK,server secret key)
2.  服务器把公钥发送给证书颁发机构
3.  证书颁发机构通过SPK和服务器网址等信息生成一个证书签名
4.  证书颁发机构再对证书签名使用密钥加密，然后把结果返回给服务器

**开始通信**

1.  浏览器请求通信
2.  服务端把证书颁发机构给它的加密后的证书签名发给浏览器
3.  因为浏览器拥有所有证书颁发结构的公钥，浏览器利用公钥对内容进行解密，得到证书签名
4.  浏览器根据同样的规则，生成一个证书签名，对比两个证书签名是否一致
5.  浏览器生成对称加密的密钥，浏览器利用SPK对密钥进行加密，把结果返回给服务器
6.  服务器利用SSK解密，得到对称加密的密钥，从此服务器和浏览器过上了用对称加密通信的日子

## Get和Post的区别

GET与POST是我们常用的两种请求方法。从功能上讲，GET一般用来从服务器上获取资源，POST一般用来更新服务器上的资源；相对来说POST的安全性要比GET的安全性高，因为GET请求提交的数据将明文出现在URL上，而且POST请求参数可以被包装到请求体中，相对更安全。

# TCP UDP相关

## TCP与UDP的区别

TCP (Transmission Control Protocol)和UDP(User Datagram Protocol)协议属于传输层协议，它们之间的区别包括：

-   TCP是可靠的面向连接、面向字节流的，UDP是不可靠的无连接、面向报文的；
-   TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式；
-   TCP有拥塞控制机制，UDP没有拥塞控制；
-   TCP首部开销比UDP的要大(20:8个)；

**拥塞**：计算机网络中的带宽、交换结点中的缓存及处理机等都是网络的资源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏，这种情况就叫做拥塞。

**拥塞控制**：防止过多的数据注入网络中，使网络中的路由器或链路不致过载。

## TCP协议如何保证传输的可靠性

TCP提供一种面向连接的、可靠的字节流服务。在交换数据之前双发必须建立TCP连接。

**数据包校验：**目标是检测在传输过程中任何变化，若校验出包有错，则丢弃报文段并不给响应，这时TCP发送数据段超时后会重发数据。

**超时重发：**当TCP发送一个报文段后，它将启动一个定时器，等待目的端确认收到这个报文段。如果不能即使收到一个确认，将重发这个报文段。

**丢弃重复数据：**对于重复数据，能够丢弃重复数据

**对失序数据包重排序：**既然TCP报文段作为IP数据报来传输，而IP数据报可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重排序，然后才交给应用层。 

**应答机制：**当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送的，通常将推迟几分之一秒

**流量控制：**TCP连接的每一方都有缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区能接纳的数据，者可以防止较快主机致使慢主机的缓冲区溢出，这就是流量控制，TCP使用的流量控制协议是可变大小的滑动窗口协议。

### TCP三次握手

三次握手(我要和你建立连接，你真的要和我建立连接吗，我真的要和你建立连接，成功)

SYN：同步序列编号（**Synchronize Sequence Numbers**）

ACK：确认字符 (**Acknowledgement**）

seq： 发送序号

-   第一次握手：Client将标志位SYN设置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。

-   第二次握手：Server收到数据包后根据SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。

-   第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。

![](https://github.com/huangdaren1997/Pictures/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png?raw=true)

### 为什么TCP连接不能是两次握手？

为了防止 **已失效的连接请求报文突然又传送到了服务端**，因而产生错误。

第一次握手，客户端发出的连接请求并未丢失，而是在某个网络节点长时间滞留了，等到客户端连接已经释放以后才到达服务端。客户端接收到这个连接请求，然后返回确认数据包。如果是二次手握，那么这时候连接就已经建立起来了，但是客户端认为自己没有发送连接请求，自然也就不会与客户端通信，那么服务端这个连接就是浪费了。

### TCP四次挥手

四次挥手(我要和你断开连接；好的，断吧。我也要和你断开连接；好的，断吧)：

-   第一次挥手：Client发送一个FIN，**用来关闭Client到Server的数据传送**，Client进入FIN_WAIT_1状态。
-   第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。此时TCP链接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。
-   第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。
-   第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。

