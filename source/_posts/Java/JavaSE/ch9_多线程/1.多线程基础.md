---
title : 1.多线程基础
categories : 
- JavaSE
- ch8多线程
date : 2018-5-20
---

# 多线程基础

## 1.线程与进程

很多同学都听说过，现代操作系统比如Mac OS X，UNIX，Linux，Windows等，都是支持“多任务”的操作系统。

什么叫“多任务”呢？简单地说，就是操作系统可以同时运行多个任务。打个比方，你一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有3个任务正在运行。还有很多任务悄悄地在后台同时运行着，只是桌面上没有显示而已。

现在，多核CPU已经非常普及了，但是，即使过去的单核CPU，也可以执行多任务。由于CPU执行代码都是顺序执行的，那么，单核CPU是怎么执行多任务的呢？

答案就是操作系统轮流让各个任务交替执行，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3，执行0.01秒……这样反复执行下去。表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。

真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。

对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。

有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。

由于每个进程至少要干一件事，所以，一个进程至少有一个线程。当然，像Word这种复杂的进程可以有多个线程，多个线程可以同时执行，多线程的执行方式和多进程是一样的，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。当然，真正地同时执行多线程需要多核CPU才可能实现。



## 2.线程的创建和启动

Java中有两种途径创建线程。

### 2.1继承Thread类

Thread类代表线程类，它的最主要的两个方法是：

- run()：包含线程运行时要执行的代码
- start()：用于启动线程

```java
class MyThread extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            System.out.println(Thread.currentThread().getName() +"--"+ i);
        }
    }
    // 启动线程
    public static void main(Strig[] args){
        MyThread thread = new MyThread();
		thread.start();
    }
}
```

### 2.2实现Runnable接口

由于Java不支持多继承，也就是说如果我们继承了Thread类，就不能继承其他类。

为了解决这个问题，Java提供了Runnable接口。

```java
class MyRunnable implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            System.out.println(Thread.currentThread().getName() +"--"+ i);
        }
    }
    // 启动线程
    public static void main(String[] args) {
		Runnable runnable = new MyThread();
		Thread thread = new Thread(runnable);
		thread.start();
	}
}
```

## 3.线程的状态

线程在它的生命周期中会处于各种不同的状态

### 3.1新建状态

用new语句创建的线程对象处于新建状态。

### 3.2就绪状态

调用了线程的start()方法，线程就处于就绪状态

### 3.3运行状态

正在占用cpu，执行程序代码的线程处于运行状态

### 3.4阻塞状态

阻塞状态是指线程因为某些原因放弃CPU，暂时停止运行。当线程处于阻塞状态时，Java虚拟机不会给该线程分配CPU，直到线程重新进入就绪状态，它才有机会转到运行状态。

**阻塞状态可分为3种**

1. 位于对象等待池的阻塞状态：当线程处于运行状态时，如果执行了某个对象的wait()方法，Java虚拟机会把线程放到这个对象的等待池中。
2. 位于对象锁池中的阻塞状态：当线程处于运行状态，视图获取某个对象的同步锁时，如果该对象的同步锁已经被其他线程占用，Java虚拟机会把这个线程放到这个对象的锁池中。
3. 其他阻塞状态：当前线程执行了sleep()方法，或者调用了其他线程的join()方法，或者发出了IO请求，就会进入这个状态。

### 3.5死亡状态

当线程执行完run方法，或者在执行过程中出现了异常，那么该线程就会退出，然后进入死亡状态

## 4.获取当前线程的引用

Thread类的currentThread静态方法返回当前线程对象的引用。

## 5.线程的调度

一个CPU在任意时刻只能执行一条机器指令，每个线程只有获得CPU的使用权才能执行指令。

在可运行池中，会有多个处于就绪的状态的线程在等待CPU的使用权，java虚拟机的一项任务就是负责线程的调度。

线程的调度是指按照特定的机制为多个线程分配cpu的使用权，有两种调度模型：分时调度模型和抢占式调度模型。

分时调度模型是让所有线程轮流获得CPU的使用权，并且平均分配每个线程占用CPU的时间片。

Java虚拟机采用抢占式调度模型，它是指优先让可运行池中的优先级高的线程占用CPU，如果可运行池中线程的优先级相同，那么就随机地选择一个线程，使其占用CPU。

### 5.1调整各个线程的优先级

Thread类提供了getPriority(int)和getPripority()方法设置和读取优先级。优先级的取值范围是1~10，越大有越优先，默认优先级为5。Thread类提供了3个静态变量，分别用来对应三个优先级，分别是

- MAX_PRIORITY:10 
- NORM_PRIORITY:5
- MIN_PRIPROTY:1

虽然说是分了10个优先级，但不是所有操作系统的支持的，所以一般推荐使用上面三个静态变量。

### 5.2线程的睡眠与让步与等待

**睡眠**：调用线程的静态sleep方法，它就会放弃CPU，转到阻塞状态。

**让步**：调用线程的静态yield方法，如果此时具有相同优先级的其他线程处于就绪状态，该方法就会把当前运行的线程放到可运行池中，并运行那个线程。

**等待**：当前运行的线程可以调用另外一个线程的join()方法，当前运行的线程将阻塞直到零一个线程运行结束，它才会恢复运行。

## 6.守护线程

Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程)

用户线程即运行在前台的线程，而守护线程是运行在后台的线程。 守护线程作用是为其他前台线程的运行提供便利服务，而且仅在普通、非守护线程仍然运行时才需要，比如垃圾回收线程就是一个守护线程。当VM检测仅剩一个守护线程，而用户线程都已经退出运行时，VM就会退出。如果有非守护线程仍然存活，VM就不会退出。

守护线程并非只有虚拟机内部提供，用户在编写程序时也可以自己设置守护线程。用户可以用Thread的setDaemon（true）方法设置当前线程为守护线程。

虽然守护线程可能非常有用，但必须小心确保其他所有非守护线程消亡时，不会由于它的终止而产生任何危害。因为你不可能知道在所有的用户线程退出运行前，守护线程是否已经完成了预期的服务任务。一旦所有的用户线程退出了，虚拟机也就退出运行了。 因此，不要在守护线程中执行业务逻辑操作（比如对数据的读写等）。

## 7.定时器

JDK的java.util包中提供了一个实用类定时器Timer，它能够定时执行特定的任务。