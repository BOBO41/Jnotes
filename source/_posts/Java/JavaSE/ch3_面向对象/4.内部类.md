---
title : 4.内部类
categories : 
- JavaSE
- ch3面向对象
date : 2018-5-11
---

# 内部类

**定义在另一个类中的类称为内部类。**

使用内部类的原因：

- 内部类是外部类的成员，因此内部类可以使用外部类的所有数据和方法，包括private修饰的。
- 内部类可以对同一个包中的其他类隐藏起来。
- 当想要定义一个回调函数且不想编写大量代码时，使用匿名内部类比较便捷。

**内部类的分类**

- 成员内部类
  - 实例内部类
  - 静态内部类
- 局部内部类（没有使用意义）

## 实例内部类

- 当外部类实例存在的时候，才能创建内部类

  ```java
  Outer.Inner inner = new Outer().new Inner();
  // 或者
  Outer outer = new Outer();
  Outer.Inner inner = outer.new Inner();
  ```

- 在内部类中，可以直接访问外部类的所有成员，包括成员方法和成员变量

- 在外部类中不能直接访问内部类的成员，必须通过内部类的实例去访问

- 在实例内部类中不能定义静态成员，只能定义实例成员

- 如果实例内部类B与外部类A包含同名的成员，那么在类B中this.var表示类B的成员，A.this.var表示类A的成员

## 静态内部类

- 静态内部类不会自动持有外部类的特定实例的引用，在创建静态内部类的实例时，不必创建外部类的实例
- 静态内部类可以直接访问外部类的静态成员，如果访问外部类的实例成员，要通过外部类的实例去访问
- 静态内部类中可以定义静态成员和实例成员

## 局部内部类

- 局部内部类不能包含静态成员

## 匿名内部类

匿名内部类存在的意义：有些实现类或子类我们只需要使用一次，没必要特意编写这个类，这时候我们就可以使用匿名内部类。匿名内部类仅能被使用一次，创建匿名内部类时它会立即创建一个该类的实例，该类的定义会立即消失，所以匿名内部类是不能够被重复使用。

**创建匿名内部类**

```
new 父类构造器（参数列表）|实现接口（）  
    {  
     //匿名内部类的类体部分  
    }
```

在这里我们看到使用匿名内部类我们必须要继承一个父类或者实现一个接口，当然也仅能只继承一个父类或者实现一个接口。同时它也是没有class关键字，这是因为匿名内部类是直接使用new来生成一个对象的引用。

**注意事项**

- 1、使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。

- 2、匿名内部类中是不能定义构造函数的。

- 3、匿名内部类中不能存在任何的静态成员变量和静态方法。

- 4、匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。

- 5、匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。

- 6、给匿名内部类传递参数的时候，若该形参在内部类中需要被使用，那么该形参必须要为final

  ```java
  public class OuterClass {
      public void display(final String name,String age){
          class InnerClass{
              void display(){
                  System.out.println(name);
              }
          }
      }
  }
  ```

**匿名内部类初始化**

我们一般都是利用构造器来完成某个实例的初始化工作的，但是匿名内部类是没有构造器的，我们需要使用构造代码块来初始化匿名内部类。

```java
return new InnerClass() {
            int age_ ;
            String name_;
            //构造代码块完成初始化工作
            {
                if(0 < age && age < 200){
                    age_ = age;
                    name_ = name;
                }
            }
            public String getName() {
                return name_;
            }
            
            public int getAge() {
                return age_;
            }
        };
```

## 继承内部类

## 子类与父类中的内部类同名