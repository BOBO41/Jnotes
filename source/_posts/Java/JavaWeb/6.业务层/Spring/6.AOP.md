---
title : AOP
categories : 
- JavaWeb
- Spring
date : 2018-11-29
---

# AOP

## 1.什么是AOP

### 1.1横切关注点与AOP

**1.1.1横切关注点（crosscutting concern）**

在了解横切关注点之前，我们首先要了解什么是关注点（`concern`）。

关注点（`concern`）：根据功能对系统进行划分，划分出来的结果就是关注点。例如我们常常会把一个系统分为表示层、业务层、持久层，这每一层就是一个关注点。

其中，关注点又分为两种类型：

- 核心关注点（`core concerns`）
- 横切关注点（`crosscutting concerns`）

核心关注点：表示主要需求的单一和特定功能的关注点称为核心关注点。例如在一个银行系统，你会关注用户管理、账户管理、贷款管理，还有对持久层和表示层的实现等等，这些都是核心关注点。

横切关注点：适用于整个应用程序，并影响整个应用程序的关注点称为横切关注点。例如安全认证、日志、缓存、性能监控、并发控制、事务管理等等。

**1.1.2AOP**

​       随着项目的迭代，项目必然会变得越来越复杂，应对复杂，我们的解决方案就是模块化。通过把大问题分解成一个个小问题，然后再逐个击破。利用OOP很容易对核心关注点进行模块化。例如我们常常会看到类似的`LoanManagementService`类来实现业务逻辑，`AccountRepository`类来实现数据获取。对于横切关注点呢？传统上我们并没有对那些横切关注点进行模块化，就拿日志来说把，我们需要在每个类都写入一个日志字段，通过它实现日志记录功能，这就造成不同功能的代码纠缠（`Code tangling `）和代码分散（`Code scattering `）。然后很明显，OOP没办法帮我们处理这个问题，因为我们就是用了OOP所以才导致这个问题。

​	这时候就轮到AOP出场了，AOP是一种思想，它引入了新的模块化单元---切面(aspect)---来实现横切关注点的分离。例如日志记录的代码作为一个切面，事务管理的代码又作为一个切面，然后通过一些技术把这些切面（在编译时期或者在运行时）切入到核心关注点中，从而实现完整的功能。

下图是没有使用AOP时的情况

![](https://github.com/huangdaren1997/pictures/blob/master/Spring/%E6%B2%A1%E6%9C%89%E4%BD%BF%E7%94%A8AOP%E6%97%B6.png?raw=true)

下图是使用AOP时的情况

![1543651196231](https://github.com/huangdaren1997/pictures/blob/master/Spring/%E4%BD%BF%E7%94%A8AOP%E6%97%B6.png?raw=true)

可以看出，在没有使用AOP时，安全模块处于被动调用的情况，我们很难对它的调用者进行统一管理。

而使用AOP时，安全模块通过切面可以主动选择它的调用者，从而实现对调用者的统一管理。

总之：AOP提供横切关注点的模块化。

### 1.2AOP基本术语

- join point：在程序运行期间，程序会暴露出一些点（`point`），例如方法的执行、创建对象、抛出异常等等。这些点就叫做`joint point`。
- pointcut：`join point`有很多，我们要从中选择出满足我们需求的点，根据某些条件选出来的点，就叫做`pointcut`。
- advice：`advice`是在`joint point`中执行的行为，例如安全认证，事务管理等等。
- aspect：`aspect`（切面）是一个实现横切关注点的模块单元。`aspect`里面包含了`advice`和`join point`。（做什么？对谁做？）
- weaving：`把核心功能和切面组合在一起的过程叫做weaving`（编织）。



## 2.AspectJ

未完待续。。。。。。。。。。。。。。。

### 2.x@AspectJ



### Mapping pointcuts

定义好切面后，我们就需要添加pointcuts。我们通过@Pointcut注解表示一个pointcut。这个注解的值就是pointcut表达式。

举例说明:

```java
execution("修饰符 类路径 方法名(方法参数)")
    
// 任意公共方法的执行：
execution("public * *(..)")
    
// 任何一个以“set”开始的方法的执行：
execution("* set*(..)")
    
// AccountService 接口的任意方法的执行：
execution("* com.xyz.service.AccountService.*(..)")
    
// 定义在service包里的任意方法的执行：
execution("* com.xyz.service.*.*(..)")
    
//定义在service包和所有子包里的任意类的任意方法的执行：
execution("* com.xyz.service..*.*(..)")
    
//定义在pointcutexp包和所有子包里的JoinPointObjP2类的任意方法的执行：
execution("* com.test.spring.aop.pointcutexp..JoinPointObjP2.*(..))")
```



## 3.Spring AOP

### 3.1例子

**配置**

```java
@Configuration
@EnableAspectJAutoProxy // 启动AOP配置
@ComponentScan("com.hdr.learn.spring.aop")
public class AppConfig {

   @Bean
   public Speaker speaker(){
      return new Speaker();
   }

   @Bean
   public MethodLogAspect aspect(){
      return new MethodLogAspect();
   }

}
```

**核心关注点**

```java
public class Speaker {

   public void sayHello(String name) throws IllegalAccessException {
      System.out.println(String.format("hello %s",name));
   }
}
```

**切面**

```java
@Aspect
public class MethodLogAspect {

   @Pointcut("execution(public void com.hdr.learn.spring.aop.Speaker.sayHello(..))")
   public void pointCut() {
   }

   @Before("pointCut()")
   public void start(JoinPoint joinPoint) {
      System.out.println("Execute Method：" + joinPoint.getSignature().getName());
   }

   @AfterReturning("pointCut()")
   public void finish() {
      System.out.println("方法执行完毕");
   }
}
```

测试

```java
   public static void main(String[] args) throws IllegalAccessException {
      AnnotationConfigApplicationContext ctx = new 
          AnnotationConfigApplicationContext(AppConfig.class);
      Speaker speaker = (Speaker) ctx.getBean("speaker");
      speaker.sayHello("hdr");
      ctx.close();
   }
```

### 3.2SpringAOP底层原理

Spring AOP是一个基于动态代理来对横切关注点进行模块化的AOP系统。

根据我们编写的配置，Spring自动为`pointcut`生成代理。

关于代理的知识，可以看这篇文章。

可以看出使用代理其实还是挺繁琐的，所以Spring帮我们封装好了。

下图是Spring AOP 的实现机制

![1543815396110](/home/hdr/Documents/pictures/Spring/SpringAOP内部.png)

未完待续。。。。。。。。。。。。。。。。。。

