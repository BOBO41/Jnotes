# 单例模式

**单例模式就是一个类只能拥有一个实例.**

## 饥汉式单例模式

Java的Runtime类就是使用了单例模式,下面我们来看看他的源码.

```java
public class Runtime {
    private static Runtime currentRuntime = new Runtime();

    public static Runtime getRuntime() {
        return currentRuntime;
    }
    
    private Runtime() {}
    
    // ................
}
```

Runtime类的代码不少,但是关于单例模式的,只看上面的代码就可以了

- 定义一个静态变量,用来存储唯一实例
- 私有化构造器,禁止外部创建新实例
- 提供一个返回实例的方法

**上面这种结构的单例类叫做饥汉式单例模式**

## 懒汉式单例模式

```java
public class LazySingleton {
   private static LazySingleton singleton = null;

   private LazySingleton() {
   }

   private static LazySingleton getSingleton() {
      if (singleton == null) {
         singleton = new LazySingleton();
      }
      return singleton;
   }

}
```

## 双检测锁机制的单例模式

懒汉式单例模式在多线程中不安全。

```java
public class FixLazySingleton {
   private static DoubleCheckSingleton singleton = null;

   private DoubleCheckSingleton() {
   }
   
   public static synchronized DoubleCheckSingleton getSingleton(){
      if(singleton==null){
         singleton = new DoubleCheckSingleton();
      }
      return  singleton;
   }
}
//----------------------------------------------------------------------
/**
synchronized的作用
synchronized 关键字，代表这个方法加锁,相当于不管哪一个线程（例如线程A），运行到这个方法时,都要检查有没有其它线程B（或者C、 D等）正在用这个方法(或者该类的其他同步方法)，有的话要等正在使用synchronized方法的线程B（或者C 、D）运行完这个方法后再运行此线程A,没有的话,锁定调用者,然后直接运行。它包括两种用法：synchronized 方法和 synchronized 块。
*/

```

上面的做法虽然解决了懒汉式单例模式多线程不安全的问题,但是性能不好.

```java
public class DoubleCheckSingleton {
   private static DoubleCheckSingleton singleton = null;

   private DoubleCheckSingleton() {
   }

   public static DoubleCheckSingleton getSingleton(){
      if(singleton==null){
         synchronized(DoubleCheckSingleton.class){
            if(singleton==null){
               singleton = new DoubleCheckSingleton();
            }
         }

      }
      return  singleton;
   }
}
```

**这就是双检测锁机制的单例模式**

