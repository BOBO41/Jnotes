# Dependencies

## 依赖注入

依赖注入是对象定义其依赖然后容器把它的依赖传递给它的过程.

### 基于构造器的依赖注入

```java
package x.y;

public class Foo {

    public Foo(Bar bar, Baz baz) {
        // ...
    }
}
```

```xml
<beans>
    <bean id="foo" class="x.y.Foo">
        <constructor-arg ref="bar"/>
        <constructor-arg ref="baz"/>
    </bean>

    <bean id="bar" class="x.y.Bar"/>

    <bean id="baz" class="x.y.Baz"/>
</beans>
```

---

```java
package examples;

public class ExampleBean {

    // Number of years to calculate the Ultimate Answer
    private int years;

    // The Answer to Life, the Universe, and Everything
    private String ultimateAnswer;

    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }
}
```

```xml
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg type="int" value="7500000"/>
    <constructor-arg type="java.lang.String" value="42"/>
</bean>
```

---

```xml
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg index="0" value="7500000"/>
    <constructor-arg index="1" value="42"/>
</bean>
```

---

```xml
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg name="years" value="7500000"/>
    <constructor-arg name="ultimateAnswer" value="42"/>
</bean>
```

### 基于setter方法的依赖注入

```java
public class TextEditor {
    private SpellChecker spellChecker;

    public void setSpellChecker(SpellChecker spellChecker) {
        this.spellChecker = spellChecker;
    }

    public void checkSpelling(){
        spellChecker.checkSpelling();
    }
}
```

```xml
<bean id="spellChecker" class="beans.SpellChecker"/>

<bean id="textEditor" class="beans.TextEditor">
	<property name="spellChecker" ref="spellChecker"/>
</bean>
```

### 依赖解析的过程


### 依赖注入的例子

## 依赖与配置的细节

### value属性

value属性的值会被Spring转化成合适的类型.

```xml
<bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
    <!-- results in a setDriverClassName(String) call -->
    <property name="driverClassName" value="com.mysql.jdbc.Driver"/>
    <property name="url" value="jdbc:mysql://localhost:3306/mydb"/>
    <property name="username" value="root"/>
    <property name="password" value="masterkaoli"/>
</bean>
```

你也可以配置java.util.Properties实例

```xml
<bean id="mappings"
    class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">

    <!-- typed as a java.util.Properties -->
    <property name="properties">
        <value>
            jdbc.driver.className=com.mysql.jdbc.Driver
            jdbc.url=jdbc:mysql://localhost:3306/mydb
        </value>
    </property>
</bean>
```

Spring容器使用JavaBeans`PropertyEditor`机制,把`<value>`标签中的文字转换成java.util.Properties实例

### idref标签

idref标签是一种防错机制

```xml
<bean id="theTargetBean" class="..."/>

<bean id="theClientBean" class="...">
    <property name="targetName">
        <idref bean="theTargetBean"/>
    </property>
</bean>
```

```xml
<bean id="theTargetBean" class="..." />

<bean id="client" class="...">
    <property name="targetName" value="theTargetBean"/>
</bean>
```

虽然这两种方式作用相同,但是第一种优于第二种.因为使用idref标签允许容器在部署时验证引用的bean实际存在。 在第二个变体中，不对传递给客户端bean的targetName属性的值执行验证。 当客户端bean实际被实例化时，才会发现错别字（最可能是致命的结果）。 如果客户端bean是原型bean，则只能在部署容器后很长时间才能发现此错误和产生的异常。

### ref标签

ref标签可用于constructor-arg和property标签内部,通过该标签,你可以把容器管理的其它Bean作为依赖.

```xml
<!-- in the parent context -->
<bean id="accountService" class="com.foo.SimpleAccountService">
    <!-- insert dependencies as required as here -->
</bean>

<!-- in the child (descendant) context -->
<bean id="accountService" <!-- bean name is the same as the parent bean -->
    class="org.springframework.aop.framework.ProxyFactoryBean">
    <property name="target">
        <ref parent="accountService"/> <!-- notice how we refer to the parent bean -->
    </property>
    <!-- insert other configuration and dependencies as required here -->
</bean>
```

### 内部Bean

在`<property/>` 或 `<constructor-arg/>`标签内使用`<Bean>`标签定义的Bean称为了内部Bean.

```xml
<bean id="outer" class="...">
    <!-- instead of using a reference to a target bean, simply define the target bean inline -->
    <property name="target">
        <bean class="com.example.Person"> <!-- this is the inner bean -->
            <property name="name" value="Fiona Apple"/>
            <property name="age" value="25"/>
        </bean>
    </property>
</bean>
```

内部Bean不需要定义id和name,就算定义了也没用.同时也无法为它们设置作用域.内部Bean永远都是匿名的而且与它的外部Bean共生.

### 集合

Spring提供了`<list/>`, `<set/>`, `<map/>`, 和 `<props/>` 元素,分别用来为Java中的List、Set、Map、Properties类型注入值。

```xml
<bean id="moreComplexObject" class="example.ComplexObject">
    <!-- results in a setAdminEmails(java.util.Properties) call -->
    <property name="adminEmails">
        <props>
            <prop key="administrator">administrator@example.org</prop>
            <prop key="support">support@example.org</prop>
            <prop key="development">development@example.org</prop>
        </props>
    </property>
    <!-- results in a setSomeList(java.util.List) call -->
    <property name="someList">
        <list>
            <value>a list element followed by a reference</value>
            <ref bean="myDataSource" />
        </list>
    </property>
    <!-- results in a setSomeMap(java.util.Map) call -->
    <property name="someMap">
        <map>
            <entry key="an entry" value="just some string"/>
            <entry key ="a ref" value-ref="myDataSource"/>
        </map>
    </property>
    <!-- results in a setSomeSet(java.util.Set) call -->
    <property name="someSet">
        <set>
            <value>just some string</value>
            <ref bean="myDataSource" />
        </set>
    </property>
</bean>
```

#### 合并集合

Spring容器还提供了合并集合的功能。

```xml
<beans>
    <bean id="parent" abstract="true" class="example.ComplexObject">
        <property name="adminEmails">
            <props>
                <prop key="administrator">administrator@example.com</prop>
                <prop key="support">support@example.com</prop>
            </props>
        </property>
    </bean>
    <bean id="child" parent="parent">
        <property name="adminEmails">
            <!-- the merge is specified on the child collection definition -->
            <props merge="true">
                <prop key="sales">sales@example.com</prop>
                <prop key="support">support@example.co.uk</prop>
            </props>
        </property>
    </bean>
<beans>
```

```properties
administrator=administrator@example.com
sales=sales@example.com
support=support@example.co.uk
```



### Null与空字符串

```xml
<bean class="ExampleBean">
    <property name="email" value=""/>
</bean>
```

```java
exampleBean.setEmail("");
```

```xml
<bean class="ExampleBean">
    <property name="email">
        <null/>
    </property>
</bean>
```

```java
exampleBean.setEmail(null);
```



## 使用depends-on

跟ref作用相同,他们之间的却别目前我还不懂.

```xml
<bean id="beanOne" class="ExampleBean" depends-on="manager"/>
<bean id="manager" class="ManagerBean" />
```

## 懒加载Bean

默认的,所有的singleton Bean在初始化容器时,就会被创建,如果你需要在调用它的时候再创建,可以使用懒加载

```xml
<bean id="lazy" class="com.something.ExpensiveToCreateBean" lazy-init="true"/>
<bean name="not.lazy" class="com.something.AnotherBean"/>
```

当如,如果一个非懒加载的singleton Bean需要用到懒加载Bean,该懒加载Bean,会在一开始就实例化.

## 自动装配

自动装配,自动为你注入合作对象.
使用基于XML的配置元数据时，可以使用<bean />元素的autowire属性为bean定义指定autowire模式。 自动装配功能有四种模式。 您指定每个bean的自动装配，因此可以选择要自动装配的那些。 下表描述了四种自动装配模式：
- no (默认)需要明确说明引用
- byName 通过属性名自动装配.匹配名字与属性名相同的Bean
- byType 通过类型自动装配.匹配类型与属性类型相同的Bean
- constructor 类似于byType但适用于构造函数参数。 如果容器中没有构造函数参数类型的一个bean，则会引发致命错误。
### 禁止一个Bean被自动装配
`autowire-candidate=false`


## 方法注入
