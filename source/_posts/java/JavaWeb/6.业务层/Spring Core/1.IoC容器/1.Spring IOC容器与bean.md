# Spring IoC 容器与beans

## IoC容器

本章介绍了Spring框架对控制反转（inversion of control）这一设计原则的实现。

在实际开发中，常常会有一个对象的功能的实现需要依赖另一个对象的情况，也就是说一个对象为了完成工作，必须获得另一个对象。传统开发中，对象获取其依赖对象的过程由它自身来完成，这个做法会导致代码冗余以及代码难以调试。而控制反转设计原则，则是把对象获取其依赖对象的过程，交由容器来完成。容器为对象注入它所依赖的对象。由于获取依赖对象的方式被反转了，因此得名控制反转。实现控制反转功能的容器就是IoC容器。

 `org.springframework.beans` 和 `org.springframework.context` 包是Spring IoC容器的基础。

`BeanFactory`接口提供了一种能够管理任何类型对象的配置机制。

`ApplicationContext`是`BeanFactory`的子接口,它添加了跟多的更能,例如更加方便的使用Spring的 AOP功能,信息资源处理(用于国际化),等等.

简单来说,`BeanFactory`提供配置框架和基本功能,`ApplicationContext`在此基础了上添加了企业级应用开发所需的功能.

在Spring,由Spring容器管理的用于组成你应用程序主干的组件叫做Bean.Bean是由Spring容器初始化、组装以及管理的对象.我们使用配置文件说明Bean与Bean之间的依赖关系.

## Bean

在软件开发中，习惯把可重用的组件叫做Bean。例如JavaBean其实就是可重用的组件，然后它还带有Java的色彩，所以就叫JavaBean。在Spring中，由IoC容器管理的组件就叫做Bean。

---

# 容器总览

`org.springframework.context.ApplicationContext`代表Spring IoC容器,它负责Bean的实例化、配置以及组装.

容器读取配置元数据了解需要创建哪些对象,以及如何配置和管理这些对象.配置元数据可以是XML文件也可以是Java代码.

spring提供了一些`ApplicationContext`接口的实现类.在独立的应用程序中,我们常常会使用

`ClassPathXmlApplicationContext`
`FileSystemXmlApplicationContext`
`AnnotationConfigApplicationContext`



在实际的应用场景中,我们不需要直接创建Spring IoC 容器.例如在Web应用中,我们只需要在web.xml文件中添加几行模板代码就足够了.

下图展示了Spring是如何工作的

![](https://docs.spring.io/spring/docs/current/spring-framework-reference/images/container-magic.png)

## 配置元数据

如上图所示,Spring IoC容器需要配置元数据,配置元数据告诉Spring需要对哪些对象进行实例化以及如何配置和组装它们.

通过XML文件的形式来写配置是比较直观和简单的,下面大部分地方我们都会通过这种配置方式来展示Spring IoC容器的关键概念和功能. 

> 现在的主流是混合使用Java注解和Java代码的配置方式,我们后面会具体讲

Spring配置由一到多个Bean Definition（Bean定义）组成.(这些Bean定义由容器管理).

在基于XML的配置方式中,我们使用bean标签来定义bean.下面是一个例子

**services.xml**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- services -->
    <bean id="petStore" class="org.springframework.samples.jpetstore.services.PetStoreServiceImpl">
        <property name="accountDao" ref="accountDao"/>
        <property name="itemDao" ref="itemDao"/>
    <!--id是bean独一无二的标志,class则是这个Bean的类型.至于如何配置Bean的依赖关系,我们会在后面讲到.-->
    </bean>
    <!-- more bean definitions for services go here -->

</beans>
```

**daos.xml**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="accountDao"
        class="org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao">
        <!-- additional collaborators and configuration for this bean go here -->
    </bean>
    <!-- more bean definitions for data access objects go here -->

</beans>
```

在基于Java的配置方法中，我们使用@Bean注解来定义Bean.下面是一个例子

```java
@Configuration
public class ServicesConfig {

	@Bean
	public PetStoreServiceImpl petStore(){
		return new PetStoreServiceImpl();
	}

}
```

```java
@Configuration
public class DaosConfig {

	@Bean
	public AccountDao accountDao(){
		return new AccountDao();
	}

}
```

## 实例化容器

实例化容器很简单,如下

```java
// xml配置
ApplicationContext ct = 
    new ClassPathXmlApplicationContext("services.xml", "daos.xml");

// java配置
ApplicationContext ct = 
    new AnnotationConfigApplicationContext(ServicesConfig.class, DaosConfig.class);
```

### 导入其他配置文件

**导入XML配置**

```xml
<beans>
    <import resource="services.xml"/>
    <import resource="resources/messageSource.xml"/>
    <import resource="/resources/themeSource.xml"/>

    <bean id="bean1" class="..."/>
    <bean id="bean2" class="..."/>
</beans>
```

**导入Java配置**

```java
@Import(ServicesConfig.class)
@Import(DaosConfig.class)
@Configuration
public class AppConfig {
	// bean definition
}
```

## 使用容器

使用T getBean(String name, Class<T> requiredType)可以从容器中获取Bean

```java
// create and configure beans
ApplicationContext context = 
    new ClassPathXmlApplicationContext("services.xml", "daos.xml");

// retrieve configured instance
PetStoreService service = context.getBean("petStore", PetStoreService.class);

// use configured instance
List<String> userList = service.getUsernameList();
```

不过在实际生产中,我们完全不需要调用到getBean方法,慢慢你就会体会到的了.



## 容器扩展点

通常，应用程序开发人员不需要子类化ApplicationContext实现类。 相反，可以通过插入特殊集成接口的实现来扩展Spring IoC容器。 接下来的几节将介绍这些集成接口。

### 使用BeanPostProcessor来自定义Bean

BeanPostProcessor接口定义了可以实现的回调方法，以提供您自己的（或覆盖容器的默认）实例化逻辑，依赖关系解析逻辑等。 如果要在Spring容器完成实例化，配置和初始化bean之后实现某些自定义逻辑，则可以插入一个或多个BeanPostProcessor实现。

您可以配置多个BeanPostProcessor实例，并且可以通过设置order属性来控制这些BeanPostProcessor实例的执行顺序。 仅当BeanPostProcessor实现Ordered接口时，才能设置此属性。 如果编写自己的BeanPostProcessor，则应考虑实现Ordered接口。 有关更多详细信息，请参阅BeanPostProcessor和Ordered接口的Javadoc。 另请参阅有关BeanPostProcessor实例的编程注册的说明。

> BeanPostProcessor实例在bean（或对象）实例上运行。 也就是说，Spring IoC容器实例化一个bean实例，然后BeanPostProcessor实例完成它们的工作。
>
> BeanPostProcessor实例的范围是每个容器的范围。 仅当您使用容器层次结构时，这才是相关的。 如果在一个容器中定义BeanPostProcessor，它只对该容器中的bean进行后处理。 换句话说，在一个容器中定义的bean不会被另一个容器中定义的BeanPostProcessor进行后处理，即使两个容器都是同一层次结构的一部分。
>
> 要更改实际的bean定义（即定义bean的蓝图），您需要使用BeanFactoryPostProcessor，如使用BeanFactoryPostProcessor定制配置元数据中所述。

org.springframework.beans.factory.config.BeanPostProcessor接口由两个回调方法组成。当这样的类被注册为容器的后处理器时，对于容器创建的每个bean实例，后处理器在容器初始化方法之前从容器中获取回调（例如InitializingBean.afterPropertiesSet（），在调用任何声明的init方法之后，并在任何bean初始化回调之后。后处理器可以对bean实例执行任何操作，包括完全忽略回调。 bean后处理器通常检查回调接口，或者它可以用代理包装bean。一些Spring AOP基础结构类实现为bean后处理器，以便提供代理包装逻辑。

ApplicationContext自动检测在实现BeanPostProcessor接口的配置元数据中定义的任何bean。 ApplicationContext将这些bean注册为后处理器，以便在创建bean时可以稍后调用它们。 Bean后处理器可以以与任何其他bean相同的方式部署在容器中。

注意，在配置类上使用@Bean工厂方法声明BeanPostProcessor时，工厂方法的返回类型应该是实现类本身，或者至少是org.springframework.beans.factory.config.BeanPostProcessor接口，显然指示该bean的后处理器性质。否则，ApplicationContext无法在完全创建之前按类型自动检测它。由于BeanPostProcessor需要尽早实例化以便应用于上下文中其他bean的初始化，因此这种早期类型检测至关重要。

> 以编程方式注册BeanPostProcessor实例
>
> 虽然BeanPostProcessor注册的推荐方法是通过ApplicationContext自动检测（如前所述），但您可以使用addBeanPostProcessor方法以编程方式对ConfigurableBeanFactory进行注册。 当您需要在注册之前评估条件逻辑或甚至跨层次结构中的上下文复制Bean post处理器时，这非常有用。 但请注意，以编程方式添加的BeanPostProcessor实例不遵循Ordered接口。 这里，注册顺序决定了执行的顺序。 另请注意，以编程方式注册的BeanPostProcessor实例始终在通过自动检测注册的实例之前处理，而不管任何显式排序。

> BeanPostProcessor实例和AOP自动代理
>
> 实现BeanPostProcessor接口的类是特殊的，容器会对它们进行不同的处理。作为ApplicationContext的特殊启动阶段的一部分，它们直接引用的所有BeanPostProcessor实例和bean都会在启动时实例化。接下来，所有BeanPostProcessor实例都以排序方式注册，并应用于容器中的所有其他bean。因为AOP自动代理是作为BeanPostProcessor本身实现的，所以BeanPostProcessor实例和它们直接引用的bean都没有资格进行自动代理，因此没有编织方面。
>
> 对于任何此类bean，您应该看到一条信息性日志消息：Bean someBean不适合所有BeanPostProcessor接口处理（例如：不符合自动代理条件）。
>
> 如果您通过使用自动装配或@Resource（可能会回退到自动装配）将bean连接到BeanPostProcessor，则Spring可能会在搜索类型匹配依赖项候选项时访问意外的bean，从而使它们不符合自动代理或其他类型的条件豆后处理。例如，如果您有一个使用@Resource注释的依赖项，其中字段或setter名称不直接对应于bean的声明名称而且没有使用name属性，则Spring会访问其他bean以按类型匹配它们。

### 使用BeanFactoryPostProcessor自定义配置元数据

### 使用FactoryBean自定义实例化逻辑

---

# Bean总览

Spring IoC容器管理一到多个Bean.我们在配置元数据中对Bean进行定义,例如XML中`<bean>`标签.

在容器内部,这些bean的定义被抽象为 BeanDefinition对象.该对象包含以下信息

- *A package-qualified class name:* 这个bean的类型
- bean行为配置元素,说明bean在容器里面的行为,例如作用域 生命周期 回调等等.
- bean的合作或依赖关系
- 要在新创建的对象中设置的其他配置设置,如管理连接池的bean中使用的连接数，或池的大小限制。

`BeanDefinition` 对象具有以下属性

- class   类型
- name  名字
- scope  作用域
- constructor arguments  构造器参数
- properties   属性
- autowiring mode  自动装箱模式
- lazy-initializtion mode  懒加载模式
- initialization method     
- destruction method      

ApplicationContext还允许用户注册在容器外部创建的现有对象。 这是通过getBeanFactory（）方法访问ApplicationContext的BeanFactory来完成的，该方法返回BeanFactory的实现类DefaultListableBeanFactory。 DefaultListableBeanFactory通过方法registerSingleton（..）和registerBeanDefinition（..）支持此注册。 

## 此处该有一个例子

## Bean命名

每个Bean都有一到多个识别标志.这些识别标志在容器中必须独一无二.

在基于XML的配置方式,你可以使用id/name属性来设置bean的识别标志.

id属性只能设置一个值,name属性可以通过逗号/分号/空格作为分隔符,设置多个值.

id/name其实也不一定需要设置,Spring会自动为bean生成名字,但是如果你需要引用这个bean,那你应该给它一个识别标志.

### Bean命名的约定

`'accountManager'`, `'accountService'`, `'userDao'`, `'loginController'

### 在bean标签外设置bean的别名

```xml
<alias name="fromName" alias="toName"/>
```

## Bean实例化

BeanDefinition实质上就是创建Bean的说明书.容器根据说明书创建对象.

Spring容器对Bean进行实例化,有三种方式.

- 使用类构造器
- 使用静态工厂
- 使用实例工厂

```xml
// 使用类构造器
<bean id="BeanId" class="com.packt.webstore.SpringDemo.Bean"/>
//使用静态工厂
<bean id="BeanId" class="com.packt.webstore.SpringDemo.BeanStaticFactory" 
      factory-method="createBean"></bean>
//使用实例工厂
	//实例化工厂Bean
<bean id="BeanFactory" class="com.packt.webstore.SpringDemo.BeanFactory"/>
	//创建Bean
<bean id="BeanId" factory-bean="BeanFactory" factory-method="createBean"></bean>
```

## Bean的作用域

- singleton
- prototype
- request
- session
- application
- websocket

### 自定义Bean的作用域

[自定义Bean的作用域](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-scopes-custom)

## 定制Bean的本质  （不懂）

Spring框架提供了一些接口,让我们可以自定义Bean的本质.

- Lifecycle Callbacks
- ApplicationContextAware和BeanNameAware
- Other Aware Interfaces

### Lifecycle Callbacks

要与容器的bean生命周期管理进行交互，可以实现Spring InitializingBean和DisposableBean接口。 容器为前者调用afterPropertiesSet（），为后者调用destroy（），让bean在初始化和销毁bean时执行某些操作。

JSR-250中定义的 @PostConstruct和@PreDestroy注释通常被认为是在现代Spring应用程序中接收生命周期回调的最佳实践。 使用这些注释意味着您的bean不会耦合到特定于Spring的接口。

如果您不想使用JSR-250注释但仍想删除耦合，请考虑使用init-method和destroy-method对象定义元数据。

在内部，Spring Framework使用BeanPostProcessor实现来处理它可以找到的任何回调接口并调用适当的方法。 如果您需要Spring默认提供的自定义功能或其他生命周期行为，您可以自己实现BeanPostProcessor。 有关更多信息，请参阅容器扩展点。

除了初始化和销毁回调之外，Spring管理的对象还可以实现Lifecycle接口，以便这些对象可以参与启动和关闭过程，这是由容器自身的生命周期驱动的。

#### InitializingBean

`org.springframework.beans.factory.InitializingBean`接口允许bean在容器中设置好所有必需属性后执行初始化工作。 InitializingBean接口指定一个方法：

```java
void afterPropertiesSet() throws Exception;
```

我们建议您不要使用InitializingBean接口，因为它会不必要地将代码耦合到Spring。 或者，我们建议使用@PostConstruct注释或指定POJO初始化方法。 对于基于XML的配置元数据，可以使用init-method属性指定具有void无参数签名的方法的名称。 使用Java配置，您可以使用@Bean的initMethod属性。

```xml
<bean id="exampleInitBean" class="examples.ExampleBean" init-method="init"/>
```

```java
public class ExampleBean {

    public void init() {
        // do some initialization work
    }
}
```

#### Destruction Callbacks

实现`org.springframework.beans.factory.DisposableBean`接口允许bean在包含它的容器销毁时获得回调。 DisposableBean接口指定一个方法：

```java
void destroy() throws Exception;
```

我们同样不推荐使用该接口,我们推荐使用下面的方法

```xml
<bean id="exampleInitBean" class="examples.ExampleBean" destroy-method="cleanup"/>
```

```java
public class ExampleBean {

    public void cleanup() {
        // do some destruction work (like releasing pooled connections)
    }
}
```

#### Default Initialization and Destroy Methods

您可以将Spring容器配置为“查找”命名初始化并销毁每个bean上的回调方法名称。 这意味着，作为应用程序开发人员，您可以编写应用程序类并使用名为init（）的初始化回调，而无需为每个bean定义配置init-method =“init”属性。 Spring IoC容器在创建bean时调用该方法（并且符合前面描述的标准生命周期回调契约）。 此功能还强制执行初始化和销毁方法回调的一致命名约定。

```java
public class DefaultBlogService implements BlogService {

    private BlogDao blogDao;

    public void setBlogDao(BlogDao blogDao) {
        this.blogDao = blogDao;
    }

    // this is (unsurprisingly) the initialization callback method
    public void init() {
        if (this.blogDao == null) {
            throw new IllegalStateException("The [blogDao] property must be set.");
        }
    }
}
```

```xml
<beans default-init-method="init">

    <bean id="blogService" class="com.something.DefaultBlogService">
        <property name="blogDao" ref="blogDao" />
    </bean>

</beans>
```

顶级`<beans/>`元素属性上存在default-init-method属性会导致Spring IoC容器将bean类上的init方法识别为初始化方法回调。 当bean被创建和组装时，如果bean类具有这样的方法，则在适当的时候调用它。

您可以使用顶级`<beans/>`元素上的default-destroy-method属性，以类似方式（在XML中）配置destroy方法回调。

#### Combining Lifecycle Mechanisms

从Spring 2.5开始，您有三个控制bean生命周期行为的选项：

- The [`InitializingBean`](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-lifecycle-initializingbean) and [`DisposableBean`](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-lifecycle-disposablebean) callback interfaces
- Custom `init()` and `destroy()` methods
- The [`@PostConstruct` and `@PreDestroy` annotations](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-postconstruct-and-predestroy-annotations). You can combine these mechanisms to control a given bean.

如果为bean配置了多个生命周期机制，并且每个机制都配置了不同的方法名称，则每个配置的方法都按照后面列出的顺序执行。 但是，如果为初始化方法配置了相同的方法名称（例如，init（） - 对于多个这些生命周期机制，该方法将执行一次。

为同一个bean配置的多个生命周期机制，具有不同的初始化方法，如下所示：

1. Methods annotated with `@PostConstruct`
2. `afterPropertiesSet()` as defined by the `InitializingBean` callback interface
3. A custom configured `init()` method

Destroy方法以相同的顺序调用：

1. Methods annotated with `@PreDestroy`
2. `destroy()` as defined by the `DisposableBean` callback interface
3. A custom configured `destroy()` method

#### Startup and Shutdown Callbacks

Lifecycle接口为具有自己的生命周期要求的任何对象定义基本方法（例如启动和停止某些后台进程）：

```java
public interface Lifecycle {

    void start();

    void stop();

    boolean isRunning();
}
```

任何Spring管理的对象都可以实现Lifecycle接口。 然后，当ApplicationContext本身接收到启动和停止信号时（例如，对于运行时的停止/重启场景），它会将这些调用级联到该上下文中定义的所有生命周期实现。 它通过委托LifecycleProcessor完成此操作，如下面的清单所示：

```java
public interface LifecycleProcessor extends Lifecycle {

    void onRefresh();

    void onClose();
}
```

请注意，LifecycleProcessor本身是Lifecycle接口的扩展。 它还添加了另外两种方法来响应刷新和关闭的上下文。

请注意，常规org.springframework.context.Lifecycle接口是显式启动和停止通知的简单合约，并不意味着在上下文刷新时自动启动。 要对特定bean的自动启动（包括启动阶段）进行细粒度控制，请考虑实现org.springframework.context.SmartLifecycle。

 此外，请注意，在销毁之前不保证停止通知。 在常规关闭时，所有Lifecycle bean在传播一般销毁回调之前首先收到停止通知。 但是，在上下文生命周期中的热刷新或中止刷新尝试时，仅调用destroy方法。

启动和关闭调用的顺序非常重要。 如果任何两个对象之间存在“依赖”关系，则依赖方在其依赖之后开始，并且在其依赖之前停止。 但是，有时，直接依赖性是未知的。 您可能只知道某种类型的对象应该在另一种类型的对象之前开始。 在这些情况下，SmartLifecycle接口定义了另一个选项，即在其超级接口Phased上定义的getPhase（）方法。 以下清单显示了Phased接口的定义：

```java
public interface Phased {

    int getPhase();
}
```

以下清单显示了SmartLifecycle接口的定义：

```java
public interface SmartLifecycle extends Lifecycle, Phased {

    boolean isAutoStartup();

    void stop(Runnable callback);
}
```

I DONT KNOW WHAT THE FUCK IS IT.

---

#### 非Web应用中关闭IoC容器



### ApplicationContextAware 和 BeanNameAware

在Spring中，xxxxAware意味着它能提供xxxx，例如ApplicationContextAware接口，字面上看实现了这个接口的类可以感知到ApplicationContext，也就是说它能提供ApplicationContext。

当ApplicationContext创建实现org.springframework.context.ApplicationContextAware接口的对象实例时，将为该实例提供对该ApplicationContext的引用。 以下清单显示了ApplicationContextAware接口的定义：

```java
public interface ApplicationContextAware {
    void setApplicationContext(ApplicationContext applicationContext) throws BeansException;
}
```

因此，bean可以通过ApplicationContext接口以编程方式操作创建它们的ApplicationContext，或者通过将引用转换为此接口的已知子类（例如ConfigurableApplicationContext，它公开其他功能）。一种用途是对其他bean进行编程检索。有时这种能力很有用。但是，一般情况下，您应该避免使用它，因为它将代码耦合到Spring并且不遵循Inversion of Control样式，其中协作者作为属性提供给bean。 ApplicationContext的其他方法提供对文件资源的访问，发布应用程序事件和访问MessageSource。 ApplicationContext的附加功能中描述了这些附加功能。

从Spring 2.5开始，自动装配是另一种获取ApplicationContext引用的替代方法。 “传统”构造函数和byType自动装配模式（如自动装配协作者中所述）可以分别为构造函数参数或setter方法参数提供ApplicationContext类型的依赖关系。要获得更大的灵活性，包括自动装配字段和多参数方法的功能，请使用基于注释的新自动装配功能。如果这样做，ApplicationContext将自动装入一个字段，构造函数参数或方法参数，如果相关的字段，构造函数或方法带有@Autowired注释，则该参数需要ApplicationContext类型。有关更多信息，请参阅使用@Autowired。

当ApplicationContext创建实现org.springframework.beans.factory.BeanNameAware接口的类时，将为该类提供对其关联对象定义中定义的名称的引用。以下清单显示了BeanNameAware接口的定义：

```java
public interface BeanNameAware {

    void setBeanName(String name) throws BeansException;
}
```

在普通bean属性填充之后但在初始化回调之前（例如InitializingBean，afterPropertiesSet或自定义init方法）调用回调。

### Other Aware Interfaces

除了ApplicationContextAware和BeanNameAware（前面已讨论过）之外，Spring还提供了一系列Aware接口，让bean向容器指示它们需要某种基础结构依赖性。 作为一般规则，名称是依赖类型的良好指示。 下表总结了最重要的Aware接口：

[其他Aware接口](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aware-list)

## Bean 定义的继承

bean定义可以包含许多配置信息，包括构造函数参数，属性值和特定于容器的信息，例如初始化方法，静态工厂方法名称等。子bean定义从父定义继承配置数据。子定义可以覆盖某些值或根据需要添加其他值。使用父bean和子bean定义可以节省大量的输入。实际上，这是一种模板形式。

如果以编程方式使用ApplicationContext接口，则子bean定义由ChildBeanDefinition类表示。大多数用户不在此级别上使用它们。相反，它们在类（如ClassPathXmlApplicationContext）中以声明方式配置bean定义。使用基于XML的配置元数据时，可以使用parent属性指定子bean定义，将父bean指定为此属性的值。以下示例显示了如何执行此操作：

```xml
<bean id="inheritedTestBean" abstract="true" class="org.springframework.beans.TestBean">
    <property name="name" value="parent"/>
    <property name="age" value="1"/>
</bean>

<bean id="inheritsWithDifferentClass" class="org.springframework.beans.DerivedTestBean"
    parent="inheritedTestBean" init-method="initialize">  
    <property name="name" value="override"/>
    <!-- the age property value of 1 will be inherited from parent -->
</bean>
```

如果没有指定，则bean bean定义使用父定义中的bean类，但也可以覆盖它。 在后一种情况下，子bean类必须与父类兼容（即，它必须接受父类的属性值）。

子bean定义从父级继承范围，构造函数参数值，属性值和方法覆盖，并具有添加新值的选项。 您指定的任何范围，初始化方法，销毁方法或静态工厂方法设置都会覆盖相应的父设置。

其余设置始终取自子定义：取决于，autowire模式，依赖性检查，单例和惰性初始化。

前面的示例通过使用abstract属性将父bean定义显式标记为abstract。 如果父定义未指定类，则需要将父bean定义显式标记为abstract，如以下示例所示：

```xml
<bean id="inheritedTestBeanWithoutClass" abstract="true">
    <property name="name" value="parent"/>
    <property name="age" value="1"/>
</bean>

<bean id="inheritsWithClass" class="org.springframework.beans.DerivedTestBean"
        parent="inheritedTestBeanWithoutClass" init-method="initialize">
    <property name="name" value="override"/>
    <!-- age will inherit the value of 1 from the parent bean definition-->
</bean>
```

父bean不能单独实例化，因为它不完整，并且也明确标记为抽象。 当定义是抽象的时，它只能用作纯模板bean定义，用作子定义的父定义。 尝试使用这样一个抽象的父bean，通过将它作为另一个bean的ref属性引用或者使用父bean ID进行显式的getBean（）调用会返回错误。 类似地，容器的内部preInstantiateSingletons（）方法忽略定义为abstract的bean定义。

> ApplicationContext默认情况下预先实例化所有单例。 因此，重要的是（至少对于单例bean），如果您有一个（父）bean定义，您打算仅将其用作模板，并且此定义指定了一个类，则必须确保将abstract属性设置为true 否则应用程序上下文将实际（尝试）预先实例化抽象bean。

