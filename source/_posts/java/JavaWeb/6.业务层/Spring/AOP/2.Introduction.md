# Introductions

`Introductions`是Spring AOP的重要部分。通过它，我们可以动态的为对象引入新的功能。在Spring，你可以为对象引入接口的实现类。它的使用场景就是，你需要添加的功能是`corsscutting`但是它又不好通过传统的`advice`实现。

## Introduction 简介

Spring把`introductions`看做是特殊的`around advice`。`introductions`只能应用在类上面，所以它不能跟`pointcut`一起使用。因为`introductions`是为类添加接口实现类，而`pointcut`负责决定`advice`应用到哪些方法上。

我们通过实现`IntroductionInterceptor`接口来创建一个`Introduction`。Spring提供了`IntroductionInterceptor`接口的默认实现`DelegatingIntroductionInterceptor`。通过继承它和实现想要引入的接口，我们就能创建出一个`introduction`。

正如使用`pointcut`和`advice`时，我们需要`PointcutAdvisor`，使用`introduction`时我们需要使用`IntroductionAdvisor`

## 通过Introduction检测对象的修改

对象修改检测是一种非常有用的技术。例如，当你调用一个方法对持久层对象进行修改，但该对象实质上并有做出任何的改变，这时候如果调用数据库的更新语句那就没什么意义了。使用对象修改检测能有效增大应用的吞吐量。如果是自己动手写，检测对象没有有发生改变，那是很麻烦的，这时候`introduction`就有了用武之地。

下面我们使用`introduction`创建一个完成的修改检测框架。

```java
/**
* 检测对象是否被修改的接口
*/
public interface IsModified {
   boolean isModified();
}
```

```java
public class IsModifiedMixin extends DelegatingIntroductionInterceptor implements IsModified {

   private boolean isModified = false;

   private Map<Method, Method> methodCache = new HashMap<>();

   @Override
   public boolean isModified() {
      return isModified;
   }


   @Override
   public Object invoke(MethodInvocation invocation) throws Throwable {
      if (!isModified) {
         if ((invocation.getMethod().getName().startsWith("set"))
               && (invocation.getArguments().length == 1)) {
            Method getter = getGetter(invocation.getMethod());

            if (getter != null) {
               Object newVal = invocation.getArguments()[0];
               Object oldVal = getter.invoke(invocation.getThis(), null);

               if ((newVal == null) && (oldVal == null)) {
                  isModified = false;
               } else if ((newVal == null) && (oldVal != null)) {
                  isModified = true;
               } else if ((newVal != null) && (oldVal == null)) {
                  isModified = true;
               } else {
                  isModified = !newVal.equals(oldVal);
               }
            }
         }
      }
      return super.invoke(invocation);
   }

   private Method getGetter(Method setter) {
      Method getter = methodCache.get(setter);

      if (getter != null) {
         return getter;
      }

      String getterName = setter.getName().replaceFirst("set", "get");
      try {
         getter = setter.getDeclaringClass().getMethod(getterName, null);
         synchronized (methodCache) {
            methodCache.put(setter, getter);
         }
         return getter;
      } catch (NoSuchMethodException e) {
         return null;
      }
   }

}
```

