# 配置文件

配置文件与映射文件对于MyBatis框架来说，具有非常重要的意义。本文将对配置文件进行讲解。

在配置文件中，我们通过配置元素来配置MyBatis。按照他们定义的顺序，MyBatis的配置元素一共有

properties settings typeAliases typeHandlers objectFactory objectWrapperFactory reflectorFactory plugins

environments databaseIdProvider mappers

## 配置文件模板

```xml
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
	<!--在这里使用配置元素-->
</configuration>
```

## Properties元素

Properties元素有两个作用

1.获取外部属性文件的内容

2.定义属性配置

配置属性后，就可以在配置文件中替换需要动态配置的属性值。 

```xml
<properties resource="config.properties">     <!---通过resource属性引用外部文件-->
  <property name="username" value="hdr"/>     <!--自定义属性配置-->
  <property name="password" value="admin"/>     <!--自定义属性配置-->
</properties>
```

### 使用属性

```xml
<dataSource type="POOLED">
  <property name="driver" value="${driver}"/> 
  <property name="url" value="${url}"/> 
  <property name="username" value="${username}"/>
  <property name="password" value="${password}"/>
</dataSource>
```

上面例子中的 username 和 password 将会由 properties 元素中设置的相应值来替换。 

 driver 和 url 属性将会由 config.properties 文件中对应的值来替换。 

### 属性的加载顺序

如果属性在不只一个地方进行了配置，那么 MyBatis 将按照下面的顺序来加载： 

- 在 properties 元素内定义的属性首先被读取。
- 然后根据 **resource** 属性或 **url** 属性读取属性文件，并覆盖已存在的同名属性。
- 最后读取作为方法参数传递的属性，并覆盖已读取的同名属性。

总结：通过方法参数传递的属性具有最高优先级，resource/url 属性中指定的配置文件次之，最低优先级的是 properties。 

---

## Settings 元素

使用Settings元素，我们可以针对当前程序对MyBatis的默认全局设置进行重写。

```xml
<settings>
	<setting name="xx" value="xxx"/>
    <setting name="xx" value="xxx"/>
</settings>
```

具体选项请看 [setting选项](http://www.mybatis.org/mybatis-3/zh/configuration.html)

---

## typeAliases 元素

类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。 

### 定义typeAliases

```xml
<typeAliases>
  <typeAlias alias="User" type="com.hdr.mybatisDemo.domain.User"/> 
  <!---这时候User代表com.hdr.mybatisDemo.domain.User-->
  <package name="com.hdr.mybatisDemo.domain"/>
  <!--指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean-->
</typeAliases>
```

**注意：**

指定包中Java Bean，如果没有注解则使用 Bean 的首字母小写的非限定类名来作为它的别名。 

 比如 com.hdr.mybatisDemo.beans.User 的别名为 `user`；

若有注解，则别名为其注解值。看下面的例子： 

```java
@Alias("User")
public class Author {
    ...
}
```

MyBatis默认实现了一些类型别名，具体请看 [别名](http://www.mybatis.org/mybatis-3/zh/configuration.html#typeAliases)。

### 使用typeAliases

```xml
<update id="update" parameterType="User">
    update tb_user
    set
    username = #{userName} ,
    password = #{password},
    age=#{age}
    where username=#{userName}
</update>
```

---

## typeHandlers 元素

MyBatis通过对JDBC进行抽象，从而大大简化我们对持久层的操作。

下面我们通过一个例子来看看这个过程是怎么实现的。

```xml
<insert id="insertStudent" parameterType="Student">
	INSERT INTO STUDENTS(STUD_ID,NAME,EMAIL,DOB)
	VALUES(#{id},#{name},#{email},#{dob})
</insert>
```

1. MyBatis会创建一个PreparedStatement接口如下

   ```java
   PreparedStatement pstmt = connection.prepareStatement
   ("INSERT INTO STUDENTS(STUD_ID,NAME,EMAIL,DOB) VALUES(?,?,?,?)");
   ```

2. 检查传递过来的属性(studentId name email)的数据类型，然后调用相应的setXXX（）方法

   ```java
   pstmt.setInt(1,student.getId());
   pstmt.setString(2, student.getName());
   pstmt.setString(3, student.getEmail());
   pstmt.setTimestamp(4, new Timestamp((student.getDob()).getTime()));
   ```

不错吧~ MyBatis真的能让我们少写点代码呢~

看了上面的例子，你可能会有点疑问，所有的数据类型都能被处理吗？

不是的，MyBatis内部定义了一些类型处理器，可以处理byte[], java.util.Date, java.sql.Date, java.sql.Time, java.
sql.Timestamp, java enums,等等。如果要处理其它类型，那么就需要你自己实现一个Type handler。

### 重写或自定义type handler

重写或自定义类型处理器有两种方法：

- 实现 `org.apache.ibatis.type.TypeHandler` 接口
- 继承 `org.apache.ibatis.type.BaseTypeHandler`类， 然后可以选择性地将它映射到一个 JDBC 类型。 

**假设我们现在处于这种状态**

```java
public class Student
{
    private Integer id;
    private String name;
    private String email;
    private PhoneNumber phone;  
    // Setters and getters
}
```

```java
public class PhoneNumber
{
    private String countryCode;
    private String stateCode;
    private String number;
    
    public PhoneNumber() {}
    
    public PhoneNumber(String countryCode, String stateCode, String number) {
        this.countryCode = countryCode;
        this.stateCode = stateCode;
        this.number = number;
    }
    public PhoneNumber(String string) {
        if(string != null){
        	String[] parts = string.split("-");
            if(parts.length>0) this.countryCode=parts[0];
            if(parts.length>1) this.stateCode=parts[1];
            if(parts.length>2) this.number=parts[2];
        }
	}
    public String getAsString() {
		return countryCode+"-"+stateCode+"-"+number;
    }
    // setters and getters
}
```

很明显，Student类型中的phone字段是一种自定义的类型，要存储该类型，我们就要为她实现type handler

```java
// ExampleTypeHandler.java
/*
  MyBatis提供了两种途径，让我们指定被关联的 JDBC 类型
  ① 在配置文件typeHandler元素上增加一个jdbcType属性（比如：jdbcType="VARCHAR"）；
  ② 给TypeHandler类增加一个 @MappedJdbcTypes 注解来指定与其关联的JDBC类型列表。
    如果同时使用，前者会覆盖后者。
*/
@MappedJdbcTypes(JdbcType.VARCHAR)
/*
 根据泛型，MyBatis 可以得知该类型处理器处理的 Java 类型。
 MyBatis还另外提供了两种做法，可以让我们实现相同的效果。
 ① 在配置文件typeHandler元素上增加一个 javaType 属性（比如：javaType="String"）；
 ② 给TypeHandler类增加一个 @MappedTypes 注解来指定与其关联的 Java 类型列表。
   如果同时使用，前者会覆盖后者。
*/
public class PhoneTypeHandler extends BaseTypeHandler<PhoneNumber>{
    
    @Override
    public void setNonNullParameter(PreparedStatement ps , int i , PhoneNumber parameter ,
                                    JdbcType jdbcType) throws SQLException{
        ps.setString(i,parameter.getAsString());
    }
    
    @Override
    public PhoneNumber getNullableResult(Result rs, String columnName) throws SQLException{
        return new PhoneNumber(rs.getString(columnName));
    }
    @Override
	public PhoneNumber getNullableResult(ResultSet rs, int columnIndex)throws SQLException {
		return new PhoneNumber(rs.getString(columnIndex));
	}
    @Override
    public PhoneNumber getNullableResult(CallableStatement cs, int columnIndex)throws SQLException{
    	return new PhoneNumber(cs.getString(columnIndex));
    }
    
}
```

**注册type handler**

```xml
<!-- mybatis-config.xml -->
<typeHandlers>
  <typeHandler handler="com.hdr.mybatisDemo.typeHandler.PhoneTypeHandler"/>
  <package name="com.hdr.mybatisDemo.typeHandler"/>
  <!--指定一个包名，MyBatis 会在包名下面搜索需要的类型处理器-->
</typeHandlers>
```

**补充：使用一个type handler 处理多个自定义java类**

```java
//GenericTypeHandler.java
public class GenericTypeHandler<E extends MyObject> extends BaseTypeHandler<E> {
/*
  为了使用泛型类型处理器， 需要增加一个接受该类的class作为参数的构造器，
  这样在构造一个类型处理器的时候 MyBatis 就会传入一个具体的类。
*/
  private Class<E> type;

  public GenericTypeHandler(Class<E> type) {
    if (type == null) throw new IllegalArgumentException("Type argument cannot be null");
    this.type = type;
  }
```

---

## 对象工厂元素

MyBatis  使用一个对象工厂（ObjectFactory）实例来创建结果对象(result)。

默认的对象工厂，要么通过默认构造方法，要么在参数映射存在的时候通过参数构造方法来**实例化目标类**。 

如果想覆盖对象工厂的默认行为，则可以通过创建自己的对象工厂来实现。 

```java
// ExampleObjectFactory.java
public class ExampleObjectFactory extends DefaultObjectFactory {
  public Object create(Class type) {
    return super.create(type);
  }
  public Object create(Class type, List<Class> constructorArgTypes, List<Object> constructorArgs) {
    return super.create(type, constructorArgTypes, constructorArgs);
  }
  public void setProperties(Properties properties) {
    super.setProperties(properties);
  }
  public <T> boolean isCollection(Class<T> type) {
    return Collection.class.isAssignableFrom(type);
  }}
```

ObjectFactory接口包含了两个创建用的方法，一个是处理默认构造方法的，另外一个是处理带参数的构造方法的。 

setProperties 方法用来配置 ObjectFactory，在初始化你的 ObjectFactory 实例后， objectFactory 元素体中定义的属性会被传递给 setProperties 方法。 

```xml
<!-- mybatis-config.xml -->
<objectFactory type="org.mybatis.example.ExampleObjectFactory">
  <property name="someProperty" value="100"/>
</objectFactory>
```

---

### objectWrapperFactory reflectorFactory plugins

---

## enviroments 元素

environments元素下可以编写一到多个environment元素。（注意有s和没有s）

一个environment元素可以粗略看做一个数据库。

```xml
<environments default="development">
	<environment id="development">
     	<transactionManager type="JDBC"/>
     	<dataSource type="POOLED">
        	<property name="driver" value="com.mysql.jdbc.Driver"/>
            <property name="url" value="jdbc:mysql://127.0.0.1:3306/mybatis3"/>
            <property name="username" value="root"/>
            <property name="password" value="admin"/>
        </dataSource>
    </environment>
    
</environments>
```

### default="shoppingcart"

你可以看到environments元素有个default的属性，这是干嘛用的呢？

其实，在我们build一个SqlSessionFactory的时候，是要指定使用哪一个environment元素中的配置信息。

```java
SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader,"development");
```

但是我们之前例子并没有传递这个值的呀，不也是可以吗？

```java
SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader);
```

这是因为default属性在暗中帮助呢

default属性的作用就是，设置默认使用哪一个environment元素的配置信息建立SqlSessionFactory对象。

### transactionManager 与 dataSource

我们可以看到，environment元素具有两个子元素，分别是transactionManager 与 dataSource。

#### transactionManager元素 

MyBatis支持两种类型的事务管理器，分别是JDBC和MANAGED。

**什么是事务管理?**

事务管理是对于一系列数据库操作进行管理，一个事务包含一个或多个[SQL](https://baike.baidu.com/item/SQL)语句，是逻辑管理的工作单元 。事务中的SQL语句，如果有任何一条出现异常，那么回滚之前的所有操作。这样可以防止出现脏数据，防止数据库数据出现问题。

- JDBC – 这个配置就是直接使用了 JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。
- MANAGED – 这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期。     默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。

**补充**：

1. 在JDBC中是通过Connection对象进行事务管理的，默认是自动提交事务，可以手工将自动提交关闭，关闭后需要通过commit方法进行提交，rollback方法进行回滚，如果不提交，则数据不会真正的插入到数据库中。
2. 如果你正在使用 Spring + MyBatis，则没有必要配置事务管理器， 因为 Spring 模块会使用自带的管理器来覆盖前面的配置。 

#### dataSource

dataSource元素是用来配置连接数据库的属性的。

```xml
<dataSource type="JNDI">
	<property name="data_source" value="java:comp/jdbc/ShoppingcartDS"/>
</dataSource>
```

dataSource元素的type属性具有三个值，分别是UNPOOLED, POOLED, JNDI。

UNPOOLED- 对于每次数据库操作，MyBatis会打开一个新的session执行数据库操作，操作完成后关闭session。

POOLED- MyBatis会创建一个数据库连接池，要对数据库进行操作就从这个池里获取连接对象。（一般用于研发和测试）

JNDI- MyBatis通过JDNI获取连接，生产环境中最好使用它。

补充：JNDI API 允许java软件客户端，通过名称发现和查找数据和资源。

-----

**databaseIdProvider** 

---

## Mappers元素

Mappers元素是用来对Mapper XML文件进行定位的。

```xml
<mappers>
    <!-- 使用相对于类路径的资源引用 -->
  <mapper resource="org/mybatis/builder/AuthorMapper.xml"/>
    <!-- 使用完全限定资源定位符（URL） -->
  <mapper url="file:///var/mappers/BlogMapper.xml"/>
    <!-- 使用映射器接口实现类的完全限定类名 -->
  <mapper class="org.mybatis.builder.PostMapper"/>
    <!-- 将包内的映射器接口实现全部注册为映射器 -->
  <package name="org.mybatis.builder"/>
</mappers>
```

## 总结：

在本文,我们对配置文件中常用的配置元素进行了讲解,剩余部分可以自行到官方中查询。





