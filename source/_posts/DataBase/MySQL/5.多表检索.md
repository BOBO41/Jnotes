# 多表检索

SELECT 的语法

```sql
SELECT select_list
FROM table_list
WHERE row_constraint
GROUP BY grouping_columns # GROUP BY sex;
ORDER BY sorting_columns # ORDER BY last_name DESC, first_name ASC;
HAVING group_constraint
LIMIT count;
```

匹配模式

LIKE ，`_` 匹配任何单个字符， `%`匹配任何字符序列

## 1.使用连接实现多表检索

连接（join）

### 内连接

一个表的的所有行与另一个表的所有行，排列组合。

我们可以通过ON子句来添加排列组合的规则,从而减少排列组合的结果数

```sql
SELECT * FROM t1 INNER JOIN t2 ON t1.i1 = t2.i2
```

### 左（外）连接和右（外）连接

内连接只会显示在连个表里都匹配上的行。外连接除了显示同样的结果，还可以把其中一个表在另一个表没有匹配的行也显示出来。左连接就是把左表里没有匹配的内容也显示出来。

```sql
SELECT *
FROM t1
       LEFT JOIN t2 on t1.i1 = t2.i2
ORDER BY t1.i1 ASC;
```

## 2.使用子查询实现多表检索

子查询：用括号括起来，并嵌入另一条语句里的那条SELECT语句。

```sql
SELECT * FROM socre WHERE event_id IN (SELECT event_id FROM grade_event WHERE category = 'T');
```

子查询可以返回各种不同类型的信息

- 标量子查询：返回一个值
- 列子查询：返回一个由一个值或多个值构成的列
- 行子查询：返回一个由一个值或多个值构成的行
- 表子查询：返回一个由一个行或多个行组成的表

### IN 和 NOT IN 子查询

```sql
# 查询逃课学生
SELECT * FROM student WHERE student_id IN (SELECT student_id FROM absence);
# 查询全勤学生
SELECT * FROM student WHERE student_id NOT IN (SELECT student_id FROM absence);
```

### ALL、ANY和SOME子查询

```sql
# 外查询找出比子查询的到的生日都要小的生日
SELECT last_name ,first_name birth FORM persident WHERE birth <= ALL (SELECT birth FROM president);

SELECT last_name ,first_name birth FORM persident WHERE birth <= ANY (SELECT birth FROM president);

SELECT last_name ,first_name , state , city FORM persident WHERE (state,city) = ANY (SELECT state , city FORM persident WHERE last_name = 'Roosevelt');
```

### EXISTS 和 NOT EXISTS 子查询

这两个运算符只会测试某个子查询是否返回了行。如果有返回，EXISTS结果为真。

### FORM子句里的子查询

```sql
SELECT * FROM (SELECT 1,2) AS t1 INNER JOIN (SELECT 3,4) AS t2;
```

