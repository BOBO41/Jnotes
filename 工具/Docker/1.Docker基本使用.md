# 简介

# 镜像

```bash
# 查看本地镜像
docker iamge ls
# 搜索镜像
docker search ubuntu
# 获取镜像
docker pull [opt] [Docker Registry address[:port]/] repositoryName[:label]
docker pull ubuntu
# 删除镜像
docker image rm [选项] <镜像1> [<镜像2> ...]
# 其中，<镜像> 可以是 镜像短 ID、镜像长 ID、镜像名 或者 镜像摘要。
# 镜像的详细信息
docker inspect img-id
#--------------------------------------------------------
# 创建镜像
  # 基于容器创建
  docker container commit 
  # 基于本地模板
  cat ubuntu-14.04xxx.tar.gz | docker import - ubuntu:14.04
# 镜像的保存与读取
  docker image save
  docker image load
```

# 容器

```bash
# 创建容器  -it 很关键
docker container create -it ubuntu
# 查看容器
docker container ls -a
# 启动容器 
docker container start  容器ID
# 进入容器
docker container attach 容器ID
# 终止容器
docker container stop 容器ID
# 删除容器
docker container rm 容器ID
# 退出容器
按住ctrl然后按p按q

https://stackoverflow.com/questions/45216612/docker-getting-exited-just-after-start
```

# Dockerfile

Dockerfile是一个文本格式的配置文件，使用Dockerfile可以快速创建自定义的镜像。

Dockerfile由一行行命令语句组成，主要分为四部分，基础镜像信息、维护者信息、镜像操作指令、容器启动时执行指令。

```dockerfile
# This dockerfile uses the redis image
# VERSION 2 - DEITION 1
# Author: hdr
# Command format: instruction [argumetns/command]..

# 第一行必须指定基于的基础镜像
FROM redis
# 维护者信息
MAINTAINER hdr huangdaren1997@gmail.com
# 镜像的操作指令
....
# 容器启动时执行指令
```

**指令详解**

```dockerfile
FORM <iamge> 或 FORM <image>:<tag>
MAINTAINER <name>
# 每条RUN指令将在当前镜像基础上执行指定命令，并提交为新的镜像。
RUN <command>
RUN apt update && apt install -y vim
# CMD 容器启动时会执行的命令，每个Dockerfile只能有一个CMD命令，如果有多条，则执行最后一条
# 如果启动容器的时候指定了运行的命令，则运行指定的命令
CMD echo "hello world"
# 暴露端口  感觉没-p好用
EXPOSE 6379
# ENV <key> <value> 指定一个环境变量，会被后续的RUN指令使用，并且在容器运行时保持
ENV JAVA_HOME xxxxxxxxx
ENV PATH $JAVA_HOME/bin:$PATH
# ADD <src> <dest> 复制文件，可以是dockerfile的相对路径、URL、tar文件
# ENTRYPOINT 容器启动后执行的命令,也是只能有一个
ENTRYPOINT echo "hello world"
# VOLUME 
......
```

`docker image build dockerfile-path image-name`

# 网络配置

Docker通过一些网络驱动（Network drivers）来实现通信。这些驱动分别有

-   host：用于容器与宿主主机的通信
-   bridge： 默认的网络驱动，用于容器间的通信
-   overlay：
-   macvlan：为容器指定一个MAC地址
-   none：终止该容器的所有网络



## host networking

创建一个nginx容器，然后把容器的80端口绑定到宿主主机的8080端口，通过宿主主机访问nginx页面

```shell
docker image pull nginx
docker container create -it -p8080:80 --name my_nginx nginx
docker container start my_nginx
```

[How do I assign a port mapping to an existing Docker container?](https://stackoverflow.com/questions/19335444/how-do-i-assign-a-port-mapping-to-an-existing-docker-container)

## bridge network

### 使用默认的桥接网络

```shell
docker run -dit --name ubt1 ubuntu
docker run -dit --name ubt2 ubuntu
docker network inspect bridge # 在Containers可以看到目前具有的容器，以及容器的ip地址
docker container attach ubt1
apt install -y net-tools # 安装ifconfig
apt install -y iputils-ping # 安装ping 工具
ping 172.17.0.3 # ping另一个容器的ip地址
```

官方不建议在生产环境下使用这种网络连接

### 用户定义桥接网络

```shell
# 自定义一个桥接网络
docker network create --driver bridge ubt-net
# 创建3个容器，一个加入ubt-net,一个加入bridge,一个两个都加入
docker run -dit --name ubt1 --netowork ubt-net  ubuntu bash
docker run -dit --name ubt2  ubuntu bash
docker run -dit --name ubt3  ubuntu bash
docker network connect ubt-net ubt3
# 3既可以与1相互访问，也可以与2相互访问，但是1和2不能相互访问
```

这种方案有什么有点呢？那就是在ping的时候，你可以使用`ping ubt4` 而不是`ping ip`

## overlay networks

用来解决swarm services的网络问题。

简单来说，swarm允许我们以节点（node）的方式组织集群（cluster）;每个节点上面可以部署一个或者多个服务（service）;每个服务又可以包括一个或者多个（container）

# 数据管理

## 三种数据管理方式

默认的，容器中创建的所有文件都被存储在容器层面，说人话就是：

-   容器被删除了，数据也就不复存在
-   很难移动这些数据
-   性能也一般

Docker为我们提供了两种方式对文件进行永久存储，如果你用的是Linux，还有第三种方法，不过这种方式只是把文件存储在内存中。以下是这三种方式:

-   volume:与本地文件系统中被Docker管理的那部分挂钩
-   bind:直接与本地文件系统挂钩
-   tmpfs:存储在内存中，只有Linux系统可以使用

![](../images/docker-types-of-mounts.png)

### 什么时候用volumes

-   多个容器之间共享数据。创建容器的时候，如果没有显示创建一个volume，那么它会默认创建一个，就算该容器后面被删除了，这个volume还是会存在。关于对volume的操作，请查看`docker volume --help`
-   当Docker宿主不能保证一定能提供所需的文件或目录时
-   需要把数据存储在非Docker宿主环境，例如远程服务器等等
-   当你需要对数据进行备份、迁移等等，volumes是个不错的选择

### 什么时候用bind mounts

其实bind mounts是个老东西0.0

### 什么时候用tmpfs mounts

`tmpfs` mounts are best used for cases when you do not want the data to persist either on the host machine or within the container. 

## volumes

对于volumes的操作，主要有三个命令，一个是`docker volume` 用来管理volume。另外是`--mount`和`-v 、--volume`

推荐用`--mount`所以不讲`-v、--volume`

`--mount`后面接收的是一组键值对

-   type=bind、volume、tmpfs
-   source=volume名称
-   target=容器内路径
-   readonly=
-   volume-opt=

**例子**

```bash
# 使用--mount
docker container run -dit --name redis-master --mount type=volume,source=redis-config,target=/redis/config --network redis-network redis
# 可以在/var/lib/docker/volumes查看创建的volume
```



[Manage application data](https://docs.docker.com/storage/)

[How can I add a volume to an existing Docker container?](https://stackoverflow.com/questions/28302178/how-can-i-add-a-volume-to-an-existing-docker-container)



