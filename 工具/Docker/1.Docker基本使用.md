# 简介

# 镜像

```bash
# 查看本地镜像
docker iamge ls
# 搜索镜像
docker search ubuntu
# 获取镜像
docker pull [opt] [Docker Registry address[:port]/] repositoryName[:label]
docker pull ubuntu
# 删除镜像
docker image rm [选项] <镜像1> [<镜像2> ...]
# 其中，<镜像> 可以是 镜像短 ID、镜像长 ID、镜像名 或者 镜像摘要。
# 镜像的详细信息
docker inspect img-id
#--------------------------------------------------------
# 创建镜像
  # 基于容器创建
  docker container commit 
  # 基于本地模板
  cat ubuntu-14.04xxx.tar.gz | docker import - ubuntu:14.04
# 镜像的保存与读取
  docker image save
  docker image load
```

# 容器

```bash
# 创建容器  -it 很关键
docker container create -it ubuntu
# 查看容器
docker container ls -a
# 启动容器 
docker container start  容器ID
# 进入容器
docker container attach 容器ID
# 终止容器
docker container stop 容器ID
# 删除容器
docker container rm 容器ID

https://stackoverflow.com/questions/45216612/docker-getting-exited-just-after-start
```

# 数据管理

[Manage application data](https://docs.docker.com/storage/)

[How can I add a volume to an existing Docker container?](https://stackoverflow.com/questions/28302178/how-can-i-add-a-volume-to-an-existing-docker-container)



# 网络配置

Docker通过一些网络驱动（Network drivers）来实现通信。这些驱动分别有

-   host：用于容器与宿主主机的通信
-   bridge： 默认的网络驱动，用于容器间的通信
-   overlay：
-   macvlan：为容器指定一个MAC地址
-   none：终止该容器的所有网络



## host networking

创建一个nginx容器，然后把容器的80端口绑定到宿主主机的8080端口，通过宿主主机访问nginx页面

```shell
docker image pull nginx
docker container create -it -p8080:80 --name my_nginx nginx
docker container start my_nginx
```

[How do I assign a port mapping to an existing Docker container?](https://stackoverflow.com/questions/19335444/how-do-i-assign-a-port-mapping-to-an-existing-docker-container)

## bridge network

### 使用默认的桥接网络

```shell
docker run -dit --name ubt1 ubuntu
docker run -dit --name ubt2 ubuntu
docker network inspect bridge # 在Containers可以看到目前具有的容器，以及容器的ip地址
docker container attach ubt1
apt install -y net-tools # 安装ifconfig
apt install -y iputils-ping # 安装ping 工具
ping 172.17.0.3 # ping另一个容器的ip地址
```

官方不建议在生产环境下使用这种网络连接

### 用户定义桥接网络

```shell
# 自定义一个桥接网络
docker network create --driver bridge ubt-net
# 创建3个容器，一个加入ubt-net,一个加入bridge,一个两个都加入
docker run -dit --name ubt1 --netowork ubt-net  ubuntu bash
docker run -dit --name ubt2  ubuntu bash
docker run -dit --name ubt3  ubuntu bash
docker network connect ubt-net ubt3
# 3既可以与1相互访问，也可以与2相互访问，但是1和2不能相互访问
```

这种方案有什么有点呢？那就是在ping的时候，你可以使用`ping ubt4` 而不是`ping ip`

## overlay networks

用来解决swarm services的网络问题。

简单来说，swarm允许我们以节点（node）的方式组织集群（cluster）;每个节点上面可以部署一个或者多个服务（service）;每个服务又可以包括一个或者多个（container）