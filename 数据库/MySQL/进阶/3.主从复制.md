# 主从复制

## 简介

MySQL数据库提供的主从复制功能可以方便的实现数据的多处自动备份，实现数据库的拓展。多个数据备份不仅可以加强数据的安全性，也可以通过读写分离进一步提升数据库的负载性能。

## 工作原理

MySQL之间数据复制的基础是二进制日志文件（binary log file）。一台MySQL数据库一旦启用二进制日志后，它的数据库中所有操作都会以“事件”的方式记录在二进制日志中，其他数据库作为slave通过一个I/O线程与主服务器保持通信，并监控master的二进制日志文件的变化，如果发现master二进制日志文件发生变化，则会把变化复制到自己的中继日志中，然后slave的一个SQL线程会把相关的“事件”执行到自己的数据库中，以此实现从数据库和主数据库的一致性，也就实现了主从复制。

**实现MySQL主从复制需要进行的配置：**

-   主服务器：

    -   开启二进制日志
    -   配置唯一的server-id
    -   获得master二进制日志文件名及位置
    -   创建一个用于slave和master通信的用户账号

-   从服务器：

    -   配置唯一的server-id

-   -   使用master分配的用户账号读取master二进制日志
    -   启用slave服务

## 实践

主数据库master修改：

**1.修改mysql配置**

找到主数据库的配置文件my.cnf(或者my.ini)，我的在/etc/mysql/my.cnf,在[mysqld]部分插入如下两行：

```
[mysqld]
log-bin=mysql-bin #开启二进制日志
server-id=1 #设置server-id
```

**2.重启mysql，创建用于同步的用户账号**

打开mysql会话shell>mysql -hlocalhost -uname -ppassword

创建用户并授权：用户：rel1密码：slavepass

```mysql
# 创建用户
CREATE USER 'slaver'@'%' IDENTIFIED BY '123456';
# 分配权限
GRANT REPLICATION SLAVE ON *.* TO 'slaver'@'%';
# 刷新权限
flush privileges;
```

**3.查看master状态，记录二进制文件名(mysql-bin.000003)和位置(73)：**

```
mysql > SHOW MASTER STATUS;
+------------------+----------+--------------+------------------+
| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |
+------------------+----------+--------------+------------------+
| mysql-bin.000001 | 1026     |              |                  |
+------------------+----------+--------------+------------------+
```

二、从服务器slave修改：

**1.修改mysql配置**

同样找到my.cnf配置文件，添加server-id

```
[mysqld]
server-id=2 #设置server-id，必须唯一
```

**2.重启mysql，打开mysql会话，执行同步SQL语句**(需要主服务器主机名，登陆凭据，二进制文件的名称和位置)：

```
change master to
	master_host='xxxxxx',
	master_user='slaver',
	master_password='123456',
	master_log_file='mysql-bin.000001',
	master_log_pos=1026;
```

**3.启动slave同步进程：**

```
mysql>start slave;
```

4.查看slave状态：

```mysql
mysql> show slave status\G;
*************************** 1. row ***************************
 				...
             Slave_IO_Running: Yes
            Slave_SQL_Running: Yes
        ...
# 当Slave_IO_Running和Slave_SQL_Running都为YES的时候就表示主从同步设置成功了。
```

master开启二进制日志后默认记录所有库所有表的操作，可以通过配置来指定只记录指定的数据库甚至指定的表的操作，具体在mysql配置文件的[mysqld]可添加修改如下选项：

```properties
# 不同步哪些数据库  
binlog-ignore-db = mysql  
binlog-ignore-db = test  
binlog-ignore-db = information_schema  
  
# 只同步哪些数据库，除此之外，其他不同步  
binlog-do-db = game
```



## 常见问题

### Slave_IO_Running:No

1.  设置从服务器的bind-address = *
2.  主服务器的端口是否开放了
3.  信息设置是否正确

### Slave_SQL_Running:NO

Google.......

# 读写分离

## 三方软件

- ProxySQL
- 阿里云的[RDS](https://cn.aliyun.com/product/rds)，其实就是阿里云什么都帮你搞好了，你直接连接一个地址就可以了。

## 代码层面读写分离

### 1.ReplicationDriver

MySQL 提供支持读写分离的驱动类：`com.mysql.jdbc.ReplicationDriver`用来替代`com.mysql.jdbc.Driver`。

```properties
#注意，所有参数主从统一,用户名和密码也必须相同
jdbc.url=jdbc:mysql:replication://<master>,<slave>.../...?...=... 
```

触发Slave的情况:1.`auto_commit = false` 2.`readOnly=true`

```java
// 事务开启后，查询自动切换到从库,readOnly默认为false
@Transactional(propagation=Propagation.REQUIRED, readOnly = true)
public List<OrderBase> findOrderList(String orderCode);
```

#### 常见情景的结果分析

**当Service中出现自身实例方法的调用时**

```java
@Transactional(propagation=Propagation.REQUIRED, readOnly = true)
public OrderBase getOrder(String orderCode) {
    findSubOrderList(orderCode);
}

@Transactional(propagation=Propagation.REQUIRED, readOnly = false)
public void updateOrder(OrderBase orderBase) {
    findSubOrderList(orderBase.getCode());
    // ...
}

@Transactional(propagation=Propagation.REQUIRED, readOnly = true)
public List<OrderSub> findSubOrderList(String orderCode) {
}
```

`getOrder`和`updateOrder`都调用了`findSubOrderList`方法，这时`findSubOrderList`方法的调用对象是`this`，而不是被Spring事务管理器替换过的`service`对象，此时`findSubOrderList`方法上的@Transaction注解无效，它会根据上文环境来决定使用主库还是从库，从而避免一个事务内部出现读写库不统一的情况。

**service调用了其它service的方法**

```java
// OrderSerivceImpl:
@Transactional(propagation=Propagation.REQUIRED, readOnly = true)
public OrderBase getOrder(String orderCode) {
    orderCouponService.getById(couponId);
}
  
@Transactional(propagation=Propagation.REQUIRED, readOnly = false)
public OrderBase createOrder(OrderGeneratorDto dto) {
    orderCouponService.saveCoupon(coupon);
}
 
@Transactional(propagation=Propagation.REQUIRED, readOnly = false)
public OrderBase updateOrder(OrderBase orderBase) {
    orderCouponService.getById(couponId);
}
  
// OrderCouponServiceImpl:
@Transactional(propagation=Propagation.REQUIRED, readOnly = true)
public OrderCoupon getById(Integer couponId) {
}
  
@Transactional(propagation=Propagation.REQUIRED, readOnly = false)
public OrderCoupon saveCoupon(OrderCoupon coupon) {
}
```

1, 当外部调用`OrderSerivce`的`getOrder`时，该方法的`@Transaction`注解生效，设置从库查询。`getOrder`内部调用了`OrderCouponService`的`getById`方法，由于`orderCouponService`是被Spring事务管理器替换过的`service`对象，所以`getById`方法上的`@Transaction`注解生效。由于`Require`这个事务传播的特性，`getById`不会创建新的事务，也就是说使用的是`getOrder`的事务，所以依旧是由从库读取数据。

2, 当外部调用`OrderSerivce`的`saveOrder`时，该方法的`@Transaction`注解生效，设置操作主库。`saveOrder`内部调用了`OrderCouponService`的`saveCoupon`方法，同样由于Require的特性，没有创建新事务，操作主库。

3, 当外部调用`OrderSerivce`的`updateOrder`时，`updateOrder`方法的`@Transaction`注解生效，设置操作主库。`updateOrder`内部调用了`OrderCouponService`的`getById`方法，同样由于Require的特性，没有创建新事务，从主库读出数据。



### 2.Spring的AbstractRountingDataSource

