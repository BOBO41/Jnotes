

# 索引

什么是索引？

数据库索引是帮助数据库高效获取数据的一种数据结构。在MySQL中有B+Tree索引、Hash索引。

Hash索引的优点：在元素分布均匀的时候，查询速度是最快的。

Hash索引的缺点：无法进行范围查找，在Hash碰撞严重的情况，性能还不如B+Tree索引。



## 1.索引的类型

**PRIMARY KEY主键索引**

不允许出现相同的值,且不能为NULL值,一个表只能有一个主键索引

**UNIQUE唯一索引**

不可以出现相同的值,可以有NULL值

**INDEX普通索引**

允许出现相同的索引内容

**FULLTEXT INDEX 全文索引**

上述三种索引都是针对列的值发挥作用,但全文索引,可以针对值中的某个单词,比如一篇文章中的某个词.

只有myisam以及英文支持,并且效率让人不敢恭维,可以用coreseek和xunsearch等第三方应用来完成这个需求

## 2.索引的CURD

### 2.1创建索引

```sql
ALTER TABLE table_name ADD INDEX index_name (index_columns)；
ALTER TABLE table_name ADD UNIQUE index_name (index_columns)；
ALTER TABLE table_name ADD PRIMARY KEY index_name (index_columns)；
ALTER TABLE table_name ADD FULLTEXT index_name (index_columns)；

CREATE TABLE `test1` (
  `id` smallint(5) UNSIGNED AUTO_INCREMENT NOT NULL, -- 注意,下面创建了主键索引,这里就不用创建了
  `username` varchar(64) NOT NULL COMMENT '用户名',
  `nickname` varchar(50) NOT NULL COMMENT '昵称/姓名',
  `intro` text,
  PRIMARY KEY (`id`), 
  UNIQUE KEY `unique1` (`username`), -- 索引名称,可要可不要,不要就是和列名一样
  KEY `index1` (`nickname`),
  FULLTEXT KEY `intro` (`intro`)
) ENGINE=MyISAM AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 COMMENT='后台用户表';
```

### 2.2查看索引

```sql
SHOW INDEX FROM tablename；
```

### 2.3删除索引

```SQL
ALTER TABLE table_name DROP INDEX index_name;
```

### 2.4修改索引

在MySQL中并没有提供修改索引的直接指令，一般情况下，我们需要先删除掉原索引，再根据需要创建一个同名的索引，从而变相地实现修改索引操作。

## 3.深入理解B-Tree索引

B-Tree是为磁盘等外存储设备设计的一种平衡查找树。

机械硬盘的逻辑结构主要分为磁道、扇区和拄面。

硬盘的磁道密度非常高，通常一面上就有上千个磁道。但是相邻的磁道之间并不是紧挨着的，这是因为磁化单元相隔太近会相互产生影响。

在磁盘上每个同心圆是磁道，从圆心向外呈放射状地产生分割线（扇骨），将每个磁道等分为若干弧段，每个弧段就是一个扇区。每个扇区的大小是固定的，为 512Byte。扇区也是磁盘的最小存储单位。

柱面又是什么呢？如果硬盘是由多个盘片组成的，每个盘面都被划分为数目相等的磁道，那么所有盘片都会从外向内进行磁道编号，最外侧的就是 0 磁道。具有相同编号的磁道会形成一个圆柱，这个圆柱就被称作磁盘的柱面。

**块：**块是一个虚拟概念，并不是真是存在于磁盘上，操作系统从磁盘读取数据到内存时是以块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来。因为磁盘进行读写的基本单位是扇区，而操作系统与磁盘之间是块，所以系统想进行读写，最节省的方式就是扇区的整数倍。现在块的大小一般都是4096kb（4M）。

直接看这个视频吧[B Trees and B+ Trees. How they are useful in Databases](https://www.youtube.com/watch?v=aZjYr87r1b8)

[BTree和B+Tree详解](https://www.cnblogs.com/vianzhang/p/7922426.html)

[漫画：什么是B-树](https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653190965&idx=1&sn=53f78fa037386f85531832cd5322d2a0&chksm=8c9909efbbee80f90512f0c36356c31cc74c388c46388dc2317d43c8f8597298f233ca9c29e9&mpshare=1&scene=1&srcid=0208vXq0iykJaOwBpC4bU3yg&pass_ticket=qVqRQ6IA2qnC2lusXuKfz2YsImRgP4BK3i4JjVNiMtdxqCK6NdhpP%2BNLsI0I39hk#rd)

[漫画：什么是B+树](https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653191027&idx=1&sn=4ba22e3ec8bd149f69fc0aba72e4347e&chksm=8c9909a9bbee80bfa1d8497ff0525df130414c1731b5aa5287bf16ea1cf86c8d8e6f20782184&mpshare=1&scene=1&srcid=0208vH4JXmzbpOV8odFaAi8D&pass_ticket=qVqRQ6IA2qnC2lusXuKfz2YsImRgP4BK3i4JjVNiMtdxqCK6NdhpP%2BNLsI0I39hk#rd)

[MySQL索引背后的数据结构与算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)

## 4.创建索引的技巧

1. 维度高的列创建索引

    数据列中**不重复值**的个数越多,维度就越高，如数据表中存在8行数据a ,b ,c,d,a,b,c,d这个表的维度为4。
    要为维度高的列创建索引,如性别和年龄,那年龄的维度就高于性别，性别这样的列不适合创建索引,因为维度过低。

2. 对 **where,on,group by,order by** 中出现的列使用索引

3. 对较小的数据列使用索引,这样会使索引文件更小,同时内存中也可以装载更多的索引键

4. 为较长的字符串使用**前缀索引**

5. 不要过多创建索引,除了增加额外的磁盘空间外,对于`DML`操作的速度影响很大,因为其每增删改一次就得从新建立索引

6. 使用**组合索引**,可以减少文件索引大小,在使用时速度要优于多个单列索引

### 4.1组合索引与前缀索引

**注意,这两种称呼是对建立索引技巧的一种称呼,并非索引的类型。**

#### 4.1.1组合索引

MySQL单列索引和组合索引究竟有何区别呢？

为了形象地对比两者,先建一个表：

```sql
CREATE TABLE `myIndex` (
  `i_testID` INT NOT NULL AUTO_INCREMENT, 
  `vc_Name` VARCHAR(50) NOT NULL, 
  `vc_City` VARCHAR(50) NOT NULL, 
  `i_Age` INT NOT NULL, 
  `i_SchoolID` INT NOT NULL, 
  PRIMARY KEY (`i_testID`) 
);
```

假设表内已有1000条数据,在这 10000 条记录里面分布了 5 条` vc_Name="erquan"` 的记录,只不过 city,age,school 的组合各不相同。
来看这条 T-SQL：

```sql
SELECT `i_testID` FROM `myIndex` WHERE `vc_Name`='erquan' AND `vc_City`='郑州' AND `i_Age`=25; -- 关联搜索;
```

**首先考虑建MySQL单列索引：**

在 `vc_Name` 列上建立了索引。执行 `T-SQL` 时,`MYSQL` 很快将目标锁定在了 `vc_Name=erquan` 的 5 条记录上,取出来放到一中间结果集。在这个结果集里,先排除掉 `vc_City` 不等于"郑州"的记录,再排除 `i_Age` 不等于 25 的记录,最后筛选出唯一的符合条件的记录。
虽然在 `vc_Name` 上建立了索引,查询时`MYSQL`不用扫描整张表,效率有所提高,但离我们的要求还有一定的距离。同样的,在 `vc_City` 和`i_Age`分别建立的MySQL单列索引的效率相似。

为了进一步榨取 MySQL 的效率,就要考虑建立组合索引。就是将`vc_Name,vc_City,i_Age`建到一个索引里：

```sql
 ALTER TABLE `myIndex` ADD INDEX `name_city_age` (vc_Name(10),vc_City,i_Age);
```

建表时,vc_Name 长度为 50,这里为什么用 10 呢？这就是下文要说到的前缀索引,因为一般情况下名字的长度不会超过 10,这样会加速索引查询速度,还会减少索引文件的大小,提高 INSERT 的更新速度。

执行 T-SQL 时,MySQL 无须扫描任何记录就到找到唯一的记录！！

如果分别在 vc_Name,vc_City,i_Age 上建立单列索引,让该表有 3 个单列索引,查询时和上述的组合索引效率一样吗？答案是大不一样,远远低于我们的组合索引。虽然此时有了三个索引,**但 MySQL 只能用到其中的那个它认为似乎是最有效率的单列索引,另外两个是用不到的**。

建立这样的组合索引,其实是相当于分别建立了

```
vc_Name,vc_City,i_Age
vc_Name,vc_City
vc_Name
```

这样的三个组合索引！为什么没有 vc_City,i_Age 等这样的组合索引呢？这是因为 mysql 组合索引**"最左前缀"**的结果。简单的理解就是只从最左面的开始组合。并不是只要包含这三列的查询都会用到该组合索引,下面的几个 T-SQL 会用到：

```
SELECT * FROM myIndex WHREE vc_Name="erquan" AND vc_City="郑州"
SELECT * FROM myIndex WHREE vc_Name="erquan"
```

而下面几个则不会用到：

```
SELECT * FROM myIndex WHREE i_Age=20 AND vc_City="郑州"
SELECT * FROM myIndex WHREE vc_City="郑州"
```

**也就是,name_city_age (vc_Name(10),vc_City,i_Age) 从左到右进行索引,如果没有左前索引Mysql不执行索引查询**

#### 4.1.2前缀索引

如果索引列长度过长,这种列索引时将会产生很大的索引文件,不便于操作,可以使用前缀索引方式进行索引
前缀索引应该控制在一个合适的点,控制在0.31黄金值即可(大于这个值就可以创建)

```sql
SELECT COUNT(DISTINCT(LEFT(`title`,10)))/COUNT(*) FROM Arctic; 
-- 这个值大于0.31就可以创建前缀索引,Distinct去重复

ALTER TABLE `user` ADD INDEX `uname`(title(10)); 
-- 增加前缀索引SQL,将人名的索引建立在10,这样可以减少索引文件大小,加快索引查询速度
```

### 4.2不用索引的SQL

要尽量避免这些不走索引的SQL

```sql
SELECT `sname` FROM `stu` WHERE `age`+10=30;
-- 不会使用索引,因为所有索引列参与了计算

SELECT `sname` FROM `stu` WHERE LEFT(`date`,4) <1990; 
-- 不会使用索引,因为使用了函数运算,原理与上面相同

SELECT * FROM `houdunwang` WHERE `uname` LIKE'后盾%' -- 走索引
SELECT * FROM `houdunwang` WHERE `uname` LIKE "%后盾%" -- 不走索引
-- 正则表达式不使用索引,这应该很好理解,所以为什么在SQL中很难看到regexp关键字的原因

-- 字符串与数字比较不使用索引;
CREATE TABLE `a` (`a` char(10));
EXPLAIN SELECT * FROM `a` WHERE `a`="1" -- 走索引
EXPLAIN SELECT * FROM `a` WHERE `a`=1 -- 不走索引

select * from dept where dname='xxx' or loc='xx' or deptno=45 
--如果条件中有or,即使其中有条件带索引也不会使用。
--换言之,就是要求使用的所有字段,都必须建立索引, 我们建议大家尽量避免使用or关键字

-- 如果mysql估计使用全表扫描要比使用索引快,则不使用索引
```

### 4.3索引的弊端

不要盲目的创建索引,只为查询操作频繁的列创建索引,创建索引会使查询操作变得更加快速,但是会降低增加、删除、更新操作的速度,因为执行这些操作的同时会对索引文件进行重新排序或更新;

但是,在互联网应用中,查询的语句远远大于DML的语句,甚至可以占到80%~90%,所以也不要太在意,只是在大数据导入时,可以先删除索引,再批量插入数据,最后再添加索引;

## X.Explain优化查询检测

EXPLAIN可以帮助开发人员分析`SQL`问题,EXPLAIN显示了`MySQL`如何使用索引来处理`SELECT`语句以及连接表,可以帮助选择更好的索引和写出更优化的查询语句.

