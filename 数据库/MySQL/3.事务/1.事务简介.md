

# 事务简介

事务：事务是由一组操作组成的最小的不可再分的工作单元

事务管理：在执行事务的过程中出错，则撤销该事务所做过的操作，只有当事务的所有操作都成功，才提交事务。

## 事务的四大特性

事务的四种特性ACDI

- 原子性（Atomicity）

    事务是由一组操作组成的最小的不可再分的工作单元，事务中操作的执行要么全部成功，要么全部失败，不会结束在中间某个环节。如果事务执行过程中发生错误，则回滚到事务开始前的状态，就像这个事务从来没有执行过一样。

- 一致性（Consistency）

    一个事务执行之前和执行之后数据库都必须处于一致性状态。如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态。如果在事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态。

- 隔离性（Isolation）

    指的是在并发环境中，当不同的事务对象相同的数据进行操作时，每个事务都有各自的完整数据空间。并发事务之间所做的修改相互隔离。事务查看到的数据，要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，它不会查看到修改过程中的状态。

- 持久性（Durability）

    指的是只要事务成功提交，它对数据库所做的更新就必须永久保存下来。即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。

## 事务的隔离级别

事务的隔离是用来防止事务的并发问题，让我们先来看看事务的并发问题

-   脏读：在数据库访问中，事务T1将某一值修改，然后事务T2读取该值，此后T1因为某种原因撤销对该值的修改，这就导致了T2所读取到的数据是无效的。
-   不可重复读：在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据。这是由于查询时系统中其他事务修改的提交而引起的。比如事务T1读取某一数据，事务T2读取并修改了该数据，T1为了对读取值进行检验而再次读取该数据，便得到了不同的结果。
-   幻读：一个事务在执行过程中突然看到一个从未见过的行。

**不可重复读与幻读的区别**

不可重复读的重点是修改: 
同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 

幻读的重点在于新增或者删除： 
同样的条件, 第1次和第2次读出来的记录数不一样 

从总的结果来看, 似乎不可重复读和幻读都表现为两次读取的结果不一致。
但如果你从控制的角度来看, 两者的区别就比较大。 
对于前者, 只需要锁住满足条件的记录。 
对于后者, 要锁住满足条件及其相近的记录。

事务的隔离级别分为四种

-   read uncommited：是最低的事务隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。
-   read commited：保证一个事物提交后才能被另外一个事务读取。另外一个事务不能读取该事物未提交的数据。
-   repeatable read：这种事务隔离级别可以防止脏读，不可重复读。但是可能会出现幻象读。它除了保证一个事务不能被另外一个事务读取未提交的数据之外还避免了以下情况产生（不可重复读）。
-   serializable：这是花费最高代价但最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读之外，还避免了幻象读


## MySQL中的事务提交与回滚

在MySQL中，默认情况下，事务是自动提交的，也就是说，只要执行一条DML语句就开启了事物，并且提交了事务。

```sql
-- MySQL自动提交
SET AUTOCOMMIT=0; -- 启动自动提交
SET AUTOCOMMIT=1; -- 关闭自动提交
-- 提交操作
start transaction; -- 手动开启事务
insert into t_user(name) values('pp');
commit; -- commit之后即可改变底层数据库数据
-- 操作回滚
start transaction;
insert into t_user(name) values('yy');
rollback;
```


