-   [基本数据结构](#基本数据结构)
-   [深入Redis数据结构](#深入Redis数据结构)
-   [使用场景](#使用场景)
-   [持久化](#Redis的数据持久化)
-   [缓存问题](#Redis缓存常见问题)



谈谈你对Redis的认识。

Redis是一个高性能的key-value数据库，它为我们提供了5种数据结构，分别是字符串、列表、哈希、有序集合、无序集合，常用的场景有session缓存、热点数据缓存、排行榜等等。Redis 提供了两种持久化方式:RDB（默认） 和AOF


# 基本数据结构

`redis`为我们提供了5种数据结构

- String
- list
- hash
- set
- zset（有序集合）

## String类型的CRUD

`Redis`的字符串是动态字符串，是可以修改的字符串，内部结构实现上类似于 Java 的 `ArrayList`，采用预分配冗余空间的方式来减少内存的频繁分配，当字符串长度小于` 1M `时，扩容都是加倍现有的空间，如果超过 `1M`，扩容时一次只会多扩 `1M`的空间。需要注意的是字符串最大长度为 `512M`。

```bash
# 添加
set key value
setnx key value
# 删除
del key
# 查
exists key
get key
# 批量处理
mset key1 value1 key2 value2
mget key1 key2 
# 过期
expire key second
setex key value second
```

## list

Redis 的列表相当于 Java 语言里面的 LinkedList，注意它是链表而不是数组。这意味着 list 的插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为 O(n)，当列表弹出了最后一个元素之后，该数据结构自动被删除，内存被回收。

Redis 的列表结构常用来做异步队列使用。将需要延后处理的任务结构体序列化成字符串塞进 Redis 的列表，另一个线程从这个列表中轮询数据进行处理。

```bash
# 右边进入
rpush books python java golang
# 左边进入  这个有点反人类，一般从从右边进即可
lpush books python java golang
# 右边出
rpop books
# 左边出
lpop books
```

## hash

```bash
hset books java "think in java"
hset books golang "concurrency in go"
hset books python "python cookbook"

hget books golang
hlen books
hgetall books
```

## Set

```bash
sadd books python
smembers books
sismember books java
scard books  # 获取长度相当于 count()
spop books
```

## zset(有序集合)

`zset`它类似于 Java 的 `SortedSet` 和 `HashMap` 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以给每个 value 赋予一个 score，代表这个 value 的排序权重。

`zset`可以用来存粉丝列表，value 值是粉丝的用户 ID，score 是关注时间。我们可以对粉丝列表按关注时间进行排序。

`zset` 还可以用来存储学生的成绩，value 值是学生的 ID，score 是他的考试成绩。我们可以对成绩按分数进行排序就可以得到他的名次。

```bash
zadd books 9.0 "think in java"
zadd books 8.9 "java concurrency"
zadd books 8.6 "java cookbook"

zrange books 0 -1  # 按 score 排序列出，参数区间为排名范围
zrevrange books 0 -1  # 按 score 逆序列出，参数区间为排名范围

zcard books  # 相当于 count()
# 获取指定 value 的 score score 使用 double 类型进行存储，所以存在小数点精度问题
zscore books "java concurrency" 

zrem books "java concurrency"
```



# 深入Redis数据结构

## 字典

dictht 是一个散列表结构，使用拉链法保存哈希冲突。

```c
/* This is our hash table structure. Every dictionary has two of this as we
 * implement incremental rehashing, for the old to the new table. */
typedef struct dictht {
    dictEntry **table;
    unsigned long size;
    unsigned long sizemask;
    unsigned long used;
} dictht;
typedef struct dictEntry {
    void *key;
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    } v;
    struct dictEntry *next;
} dictEntry;
```

Redis 的字典 dict 中包含两个哈希表 dictht，这是为了方便进行 rehash 操作。在扩容时，将其中一个 dictht 上的键值对 rehash 到另一个 dictht 上面，完成之后释放空间并交换两个 dictht 的角色。

```c
typedef struct dict {
    dictType *type;
    void *privdata;
    dictht ht[2];
    long rehashidx; /* rehashing not in progress if rehashidx == -1 */
    unsigned long iterators; /* number of iterators currently running */
} dict;
```

rehash 操作不是一次性完成，而是采用渐进方式，这是为了避免一次性执行过多的 rehash 操作给服务器带来过大的负担。

渐进式 rehash 通过记录 dict 的 rehashidx 完成，它从 0 开始，然后每执行一次 rehash 都会递增。例如在一次 rehash 中，要把 dict[0] rehash 到 dict[1]，这一次会把 dict[0] 上 table[rehashidx] 的键值对 rehash 到 dict[1] 上，dict[0] 的 table[rehashidx] 指向 null，并令 rehashidx++。

在 rehash 期间，每次对字典执行添加、删除、查找或者更新操作时，都会执行一次渐进式 rehash。

采用渐进式 rehash 会导致字典中的数据分散在两个 dictht 上，因此对字典的查找操作也需要到对应的 dictht 去执行。

```c
/* Performs N steps of incremental rehashing. Returns 1 if there are still
 * keys to move from the old to the new hash table, otherwise 0 is returned.
 *
 * Note that a rehashing step consists in moving a bucket (that may have more
 * than one key as we use chaining) from the old to the new hash table, however
 * since part of the hash table may be composed of empty spaces, it is not
 * guaranteed that this function will rehash even a single bucket, since it
 * will visit at max N*10 empty buckets in total, otherwise the amount of
 * work it does would be unbound and the function may block for a long time. */
int dictRehash(dict *d, int n) {
    int empty_visits = n * 10; /* Max number of empty buckets to visit. */
    if (!dictIsRehashing(d)) return 0;

    while (n-- && d->ht[0].used != 0) {
        dictEntry *de, *nextde;

        /* Note that rehashidx can't overflow as we are sure there are more
         * elements because ht[0].used != 0 */
        assert(d->ht[0].size > (unsigned long) d->rehashidx);
        while (d->ht[0].table[d->rehashidx] == NULL) {
            d->rehashidx++;
            if (--empty_visits == 0) return 1;
        }
        de = d->ht[0].table[d->rehashidx];
        /* Move all the keys in this bucket from the old to the new hash HT */
        while (de) {
            uint64_t h;

            nextde = de->next;
            /* Get the index in the new hash table */
            h = dictHashKey(d, de->key) & d->ht[1].sizemask;
            de->next = d->ht[1].table[h];
            d->ht[1].table[h] = de;
            d->ht[0].used--;
            d->ht[1].used++;
            de = nextde;
        }
        d->ht[0].table[d->rehashidx] = NULL;
        d->rehashidx++;
    }

    /* Check if we already rehashed the whole table... */
    if (d->ht[0].used == 0) {
        zfree(d->ht[0].table);
        d->ht[0] = d->ht[1];
        _dictReset(&d->ht[1]);
        d->rehashidx = -1;
        return 0;
    }

    /* More to rehash... */
    return 1;
}
```

## 跳跃表

是有序集合的底层实现之一。

跳跃表是基于多指针有序链表实现的，可以看成多个有序链表。

[![img](https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/beba612e-dc5b-4fc2-869d-0b23408ac90a.png)](https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/beba612e-dc5b-4fc2-869d-0b23408ac90a.png)

在查找时，从上层指针开始查找，找到对应的区间之后再到下一层去查找。下图演示了查找 22 的过程。

[![img](https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/0ea37ee2-c224-4c79-b895-e131c6805c40.png)](https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/0ea37ee2-c224-4c79-b895-e131c6805c40.png)

与红黑树等平衡树相比，跳跃表具有以下优点：

-   插入速度非常快速，因为不需要进行旋转等操作来维护平衡性；
-   更容易实现；
-   支持无锁操作。

# 使用场景

## 计数器

可以对 String 进行自增自减运算，从而实现计数器功能。

Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。

## 缓存

将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。

## 查找表

例如 DNS 记录就很适合使用 Redis 进行存储。

查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。

## 消息队列

List 是一个双向链表，可以通过 lpop 和 lpush 写入和读取消息。

不过最好使用 Kafka、RabbitMQ 等消息中间件。

## 会话缓存

可以使用 Redis 来统一存储多台应用服务器的会话信息。

当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。

## 分布式锁实现

在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。

可以使用 Reids 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。

## 其它

Set 可以实现交集、并集等操作，从而实现共同好友等功能。

ZSet 可以实现有序性操作，从而实现排行榜等功能。

# Redis的数据持久化

Redis提供两种机制实现数据的持久化，分别是RDB和AOF。

## RDB

RDB是Redis DataBase的缩写，RDB是一个经过压缩的二进制文件，通过该文件可以还原生成RDB时的数据库状态。

**RDB的创建与载入**

有两个命令创建RDB文件，分别是SAVE、BGSAVE。

前者会阻塞Redis服务器进程，直到RDB文件创建完毕，后者则是创建一个子进程，由子进程生成RDB文件。

RDB文件的载入工作是在服务器启动时自动执行的，因为没有专门用于载入RDB文件的命令。载入RDB文件的期间，Redis服务器会处于阻塞状态。

## AOF

AOF Append Only File，通过保存Redis服务器所执行的命令来记录数据库状态。

当AOF持久化功能打开后，服务器执行完一个命令后，会将指令添加到缓冲区，然后再把缓冲区中的数据写入到AOF文件。AOF文件会越来越大，Redis提供了一条执行让我们重写AOF文件，从而减少文件的大小 BGREWRITEAOF。

# Redis缓存常见问题

## 缓存雪崩

缓存失效了，导致大量的请求发送到数据库上，导致数据库瘫痪。

发生的原因：1.Redis出故障挂掉了 2.对缓存数据设置相同的过期时间，导致某段时间内大量缓存失效。

对于Redis出故障
事发前：实现Redis的高可用，避免Redis挂掉这种情况的发生
事发中：万一Redis真的挂了，我们可以设置本地缓存(ehcache)+限流(hystrix)
事发后：redis持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据。

对于过期时间相近
在缓存的时候给过期时间加上一个随机值，这样就会大幅度的减少缓存在同一时间过期。

## 缓存穿透

黑客特意请求缓存中不存在的数据，例如向ID为正数的表请求负数的ID，导致所有请求都发送到数据库上。

解决方案有两种：

1.使用布隆过滤器或者压缩filter提前拦截

2.当我们从数据库找不到的时候，我们也将这个**空对象设置到缓存里边去**。一般会为空对象设置一个**较短的过期时间**。

## 缓存与数据库双写一致

数据更新的时候可能造成数据库和缓存的数据不一致。

一般来说，执行更新操作时，我们会有两种选择：

-   先操作数据库，再操作缓存
-   先操作缓存，再操作数据库

首先，要明确的是，无论我们选择哪个，我们都希望这**两个操作要么同时成功，要么同时失败**。所以，这会演变成一个**分布式事务**的问题。

所以，**如果原子性被破坏了**，可能会有以下的情况：

-   **操作数据库成功了，操作缓存失败了**。
-   **操作缓存成功了，操作数据库失败了**。

对于缓存，一般我们都是采取**删除缓存**缓存策略的，直接删除缓存，等再次读取时，到数据库找，在数据库找到再写到缓存里边。

**先更新数据库，再删除缓存**

-   先操作数据库，成功；
-   再删除缓存，也成功；

-   如果第一步(操作数据库)就失败了，我们可以直接返回错误(Exception)，不会出现数据不一致。
-   第一步成功(操作数据库)，第二步失败(删除缓存)，会导致**数据库里是新数据，而缓存里是旧数据**。

[具体看这里](https://mp.weixin.qq.com/s?__biz=MzI3NDA4OTk1OQ==&mid=2649902243&idx=1&sn=ec8b267811f6fe83f1b77fb0e2ee9d24&chksm=f31fbe2bc468373ddd477314b60da9469023c4312878df4743a2df37100676f748e873d742f6&mpshare=1&scene=1&srcid=&pass_ticket=C2tn3mi3z0DiLURJ6AIw5pUlV%2BSGPc0J5htQ5vXmOu5J9uCACcLs6s1x5us3p%2BZf#rd)

# 主从复制

# 哨兵

# 集群

# 发布与订阅

# Redis有哪些架构？讲讲各自的特点

https://www.cnblogs.com/jasontec/p/9699242.html