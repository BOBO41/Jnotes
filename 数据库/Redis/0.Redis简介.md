-   [基本数据结构](#基本数据结构)
-   [深入Redis数据结构](#深入Redis数据结构)
-   [使用场景](#使用场景)
-   [持久化](#Redis的数据持久化)
-   [缓存问题](#Redis缓存常见问题)



谈谈你对Redis的认识。

Redis是一个高性能的key-value数据库，它为我们提供了5种数据结构，分别是字符串、列表、哈希、有序集合、无序集合，常用的场景有session缓存、热点数据缓存、排行榜等等。Redis 提供了两种持久化方式:RDB（默认） 和AOF

# 使用场景

## 计数器

可以对 String 进行自增自减运算，从而实现计数器功能。

Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。

## 缓存

将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。

## 查找表

例如 DNS 记录就很适合使用 Redis 进行存储。

查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。

## 消息队列

List 是一个双向链表，可以通过 lpop 和 lpush 写入和读取消息。

不过最好使用 Kafka、RabbitMQ 等消息中间件。

## 会话缓存

可以使用 Redis 来统一存储多台应用服务器的会话信息。

当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。

## 分布式锁实现

在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。

可以使用 Reids 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。

## 其它

Set 可以实现交集、并集等操作，从而实现共同好友等功能。

ZSet 可以实现有序性操作，从而实现排行榜等功能。

# Redis的数据持久化

Redis提供两种机制实现数据的持久化，分别是RDB和AOF。

## RDB

RDB是Redis DataBase的缩写，RDB是一个经过压缩的二进制文件，通过该文件可以还原生成RDB时的数据库状态。

**RDB的创建与载入**

有两个命令创建RDB文件，分别是SAVE、BGSAVE。

前者会阻塞Redis服务器进程，直到RDB文件创建完毕，后者则是创建一个子进程，由子进程生成RDB文件。

RDB文件的载入工作是在服务器启动时自动执行的，因为没有专门用于载入RDB文件的命令。载入RDB文件的期间，Redis服务器会处于阻塞状态。

## AOF

AOF Append Only File，通过保存Redis服务器所执行的命令来记录数据库状态。

当AOF持久化功能打开后，服务器执行完一个命令后，会将指令添加到缓冲区，然后再把缓冲区中的数据写入到AOF文件。AOF文件会越来越大，Redis提供了一条执行让我们重写AOF文件，从而减少文件的大小 BGREWRITEAOF。

# Redis缓存常见问题

## 缓存雪崩

缓存失效了，导致大量的请求发送到数据库上，导致数据库瘫痪。

发生的原因：1.Redis出故障挂掉了 2.对缓存数据设置相同的过期时间，导致某段时间内大量缓存失效。

对于Redis出故障
事发前：实现Redis的高可用，避免Redis挂掉这种情况的发生
事发中：万一Redis真的挂了，我们可以设置本地缓存(ehcache)+限流(hystrix)
事发后：redis持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据。

对于过期时间相近
在缓存的时候给过期时间加上一个随机值，这样就会大幅度的减少缓存在同一时间过期。

## 缓存穿透

黑客特意请求缓存中不存在的数据，例如向ID为正数的表请求负数的ID，导致所有请求都发送到数据库上。

解决方案有两种：

1.使用布隆过滤器或者压缩filter提前拦截

2.当我们从数据库找不到的时候，我们也将这个**空对象设置到缓存里边去**。一般会为空对象设置一个**较短的过期时间**。

## 缓存与数据库双写一致

数据更新的时候可能造成数据库和缓存的数据不一致。

一般来说，执行更新操作时，我们会有两种选择：

-   先操作数据库，再操作缓存
-   先操作缓存，再操作数据库

首先，要明确的是，无论我们选择哪个，我们都希望这**两个操作要么同时成功，要么同时失败**。所以，这会演变成一个**分布式事务**的问题。

所以，**如果原子性被破坏了**，可能会有以下的情况：

-   **操作数据库成功了，操作缓存失败了**。
-   **操作缓存成功了，操作数据库失败了**。

对于缓存，一般我们都是采取**删除缓存**缓存策略的，直接删除缓存，等再次读取时，到数据库找，在数据库找到再写到缓存里边。

**先更新数据库，再删除缓存**

-   先操作数据库，成功；
-   再删除缓存，也成功；
-   如果第一步(操作数据库)就失败了，我们可以直接返回错误(Exception)，不会出现数据不一致。
-   第一步成功(操作数据库)，第二步失败(删除缓存)，会导致**数据库里是新数据，而缓存里是旧数据**。

[具体看这里](https://mp.weixin.qq.com/s?__biz=MzI3NDA4OTk1OQ==&mid=2649902243&idx=1&sn=ec8b267811f6fe83f1b77fb0e2ee9d24&chksm=f31fbe2bc468373ddd477314b60da9469023c4312878df4743a2df37100676f748e873d742f6&mpshare=1&scene=1&srcid=&pass_ticket=C2tn3mi3z0DiLURJ6AIw5pUlV%2BSGPc0J5htQ5vXmOu5J9uCACcLs6s1x5us3p%2BZf#rd)

# 主从复制

# 集群

# 哨兵





# Redis有哪些架构？讲讲各自的特点

https://www.cnblogs.com/jasontec/p/9699242.html