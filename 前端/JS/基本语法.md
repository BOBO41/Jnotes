## 基本语法

**声明变量**

```javascript
var name = "hdr";
```

**条件语句**

**循环语句**

**变量提升**

## 对象

**定义**

简单说，对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。

```javascript
var obj = {
  foo: 'Hello',
  bar: 'World'
};
```

属性可以动态创建，不必在对象声明时就指定。

```javascript
obj.age = 18;
```

**属性的CRUD**

```javascript
# 读取属性
obj.foo
obj['bar']
# 添加属性
obj.foo = 'Hello';
obj['bar'] = 'World';
# 修改属性
同上
# 删除属性  delete命令只能删除对象本身的属性，无法删除继承的属性
delete obj.foo
# 查看是否具有属性
'p' in obj 
obj.hasOwnProperty('toString') # 只查看自身具有的属性
# 遍历属性
var obj = {a: 1, b: 2, c: 3};
for (var i in obj) {
  console.log('键名：', i);
  console.log('键值：', obj[i]);
}
# 它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。
# 它不仅遍历对象自身的属性，还遍历继承的属性。
```

## 函数

**声明**

```javascript
# JavaScript 有三种声明函数的方法。
# 1. function关键字
function print(s) {
  console.log(s);
}
var print = function(s) { # 把匿名函数赋值给一个变量
  console.log(s);
};
# 2. Function构造器（几乎没人用）
```

**函数的属性和方法**

```javascript
# 函数的name属性返回函数的名字。
# 函数的length属性返回函数所需参数个数。
# 函数的toString方法返回一个字符串，内容是函数的源码。
```

**函数的作用域**

作用域分为：全局作用于、局部作用域

函数可以层层递进，寻找它需要的变量

```javascript
var n = 999;
function f1() {
    return function () {
        return function () {
            console.log(n);
        }
    }
}
var f = f1()();
f();
```

**闭包**

函数内部可以访问函数外部的变量，反过来则不行。如果我们非要从函数外部读取函数内部的数据呢，那要怎么实现？这就要使用闭包了，闭包就是能够读取其他函数内部变量的函数，在JS中可以把闭包简单理解成“定义在一个函数内部的函数”，原理就是通过函数A中的函数B来操作函数A中的变量。

```javascript
function A() {
    var name = "黄大仁";

    function B() {
        console.log(name);
    }

    return B;
}
```

闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些内部变量始终保持在内存中。

```java
function createIncrementor(start) {
    return function () {
        return ++start;
    };
}

var inc = createIncrementor(5);
console.log(inc()); // 6
console.log(inc()); // 7

var inc2 = createIncrementor(10);
console.log(inc2()); // 11
```

上面代码中，`start`是函数`createIncrementor`的内部变量。通过闭包，`start`的状态被保留了，每一次调用都是在上一次调用的基础上进行计算。从中可以看到，闭包`inc`使得函数`createIncrementor`的内部环境，一直存在。为什么会这样呢？原因就在于`inc`始终在内存中，而`inc`的存在依赖于`createIncrementor`，因此也始终在内存中，不会在调用结束后，被垃圾回收机制回收。

闭包的另一个用处，是封装对象的私有属性和私有方法。

```java
function Person(name) {
  var _age;
  function setAge(n) {
    _age = n;
  }
  function getAge() {
    return _age;
  }

  return {
    name: name,
    getAge: getAge,
    setAge: setAge
  };
}

var p1 = Person('张三');
p1.setAge(25);
p1.getAge() // 25
```

## 面向对象编程

### 构造函数

JS中使用构造函数来作为创建对象的模板。构造函数顾名思义就是一个函数，不过它有自己的特征和用法。

```javascript
function Vehicle () {
  'use strict'; # 使用严格模式，避免没有使用new 关键字调用构造函数
  this.price = 1000;
};
# 或者
function Fubar(foo, bar) {
  if (!(this instanceof Fubar)) {
    return new Fubar(foo, bar);
  }
  this._foo = foo;
  this._bar = bar;
}
```

上面代码中，`Vehicle`就是构造函数。为了与普通函数区别，构造函数名字的第一个字母通常大写。

构造函数的特点有两个。

-   函数体内部使用了`this`关键字，代表了所要生成的对象实例。
-   生成对象的时候，必须使用`new`命令。

### new关键字

`new`命令的作用，就是执行构造函数，返回一个实例对象。

使用`new`命令时，它后面的函数依次执行下面的步骤。

1.  创建一个空对象，作为将要返回的对象实例。
2.  将这个空对象的原型，指向构造函数的`prototype`属性。
3.  将这个空对象赋值给函数内部的`this`关键字。
4.  开始执行构造函数内部的代码。

也就是说，构造函数内部，`this`指的是一个新生成的空对象，所有针对`this`的操作，都会发生在这个空对象上。构造函数之所以叫“构造函数”，就是说这个函数的目的，就是操作一个空对象（即`this`对象），将其“构造”为需要的样子。

```javascript
function Person(name) {
    'use strict';
    this.name = name;
    var _age;
    
    // getter
    this.getAge = function () {
        return _age;
    };
    
    // setter
    this.setAge = function (age) {
        if (age >= 120) {
            console.log("too damn old !")
        } else if (age < 0) {
            console.log("r u fucking kidding me ?")
        } else {
            _age = age;
        }
    };

}
```

### this关键字

```javascript
var obj = { foo:  5 };
```

上面的代码将一个对象赋值给变量`obj`。JavaScript 引擎会先在内存里面，生成一个对象`{ foo: 5 }`，然后把这个对象的内存地址赋值给变量`obj`。也就是说，变量`obj`是一个地址（reference）。后面如果要读取`obj.foo`，引擎先从`obj`拿到内存地址，然后再从该地址读出原始的对象，返回它的`foo`属性。

原始的对象以**字典结构**保存，每一个属性名都对应一个**属性描述对象**。举例来说，上面例子的`foo`属性，实际上是以下面的形式保存的。

```
{
  foo: {
    [[value]]: 5
    [[writable]]: true
    [[enumerable]]: true
    [[configurable]]: true
  }
}
```

注意，`foo`属性的值保存在属性描述对象的`value`属性里面。

这样的结构是很清晰的，问题在于属性的值可能是一个函数。

```javascript
var obj = { foo: function () {} };
```

这时，引擎会将函数单独保存在内存中，然后再将函数的地址赋值给`foo`属性的`value`属性。

```javascript
{
  foo: {
    [[value]]: 函数的地址
    ...
  }
}
```

由于函数是一个单独的值，所以它可以在不同的环境（上下文）执行。

```javascript
var f = function () {};
var obj = { f: f };

// 单独执行
f()

// obj 环境执行
obj.f()
```

JavaScript 允许在函数体内部，引用当前环境的其他变量。

```javascript
var f = function () {
  console.log(x);
};
```

上面代码中，函数体里面使用了变量`x`。该变量由运行环境提供。

现在问题就来了，由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，`this`就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。

```javascript
function sayHi() {
    if (this.name != null) {
        console.log("Hello I am " + this.name);
    }else{
        console.log("Hello");
    }
}

var tom = {
    name: "tom",
    sayHi: sayHi
};

sayHi();
tom.sayHi();
```

### 对象的继承

构造函数有一个缺点，同一个构造函数的多个实例之间，无法共享属性，从而造成对系统资源的浪费。例如一个构造函数中的方法，每个对象都会创建这些方法，从而导致内存的浪费。为了解决这个问题，我们需要使用继承。

JavaScript 继承机制的设计思想就是，原型对象的所有属性和方法，都能被实例对象共享。也就是说，如果属性和方法定义在原型上，那么所有实例对象就能共享，不仅节省了内存，还体现了实例对象之间的联系。

```javascript
function Animal(name) {
  this.name = name;
}
typeof Animal.prototype; // object
Animal.prototype.color = 'white';
var cat1 = new Animal('大毛');
var cat2 = new Animal('二毛');
cat1.color // 'white'
cat2.color // 'white'
```

原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在**所有**实例对象上。

## 异步操作

### 定时器

#### setTimeout()

`setTimeout`函数用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，以后可以用来取消这个定时器。

```javascript
var timerId = setTimeout(func|code, delay);
setTimeout(f)
// 等同于
setTimeout(f, 0)
// 除了前两个参数，setTimeout还允许更多的参数。它们将依次传入推迟执行的函数（回调函数）。
setTimeout(function (a,b) {
  console.log(a + b);
}, 1000, 1, 1);
// 上面代码中，setTimeout共有4个参数。最后那两个参数，将在1000毫秒之后回调函数执行时，作为回调函数的参数。
//如果回调函数是对象的方法，那么setTimeout使得方法内部的this关键字指向全局环境，而不是定义时所在的那个对象。
var x = 1;
var obj = {
  x: 2,
  y: function () {
    console.log(this.x);
  }
};
setTimeout(obj.y, 1000) // 1
// 为了防止出现这个问题，一种解决方法是将obj.y放入函数。
setTimeout(function () {
  obj.y();
}, 1000);// 2
// 另一种解决方法是，使用bind方法，将obj.y这个方法绑定在obj上面。
setTimeout(obj.y.bind(obj), 1000)
```

#### setInterval()

`setInterval`函数的用法与`setTimeout`完全一致，区别仅仅在于`setInterval`指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。

```javascript
var $div = $("div");
var opacity = 1;
var fader = setInterval(function () {
    if (opacity > 0) {
        $div.css("opacity", opacity -= 0.1);
    } else {
        clearInterval(fader);
    }
}, 500);

// clearTimeout()，clearInterval()
```