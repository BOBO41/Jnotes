## 基本语法

**声明变量**

```javascript
var name = "hdr";
```

**条件语句**

**循环语句**

**变量提升**

## 对象

**定义**

简单说，对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。

```javascript
var obj = {
  foo: 'Hello',
  bar: 'World'
};
```

属性可以动态创建，不必在对象声明时就指定。

```javascript
obj.age = 18;
```

**属性的CRUD**

```javascript
# 读取属性
obj.foo
obj['bar']
# 添加属性
obj.foo = 'Hello';
obj['bar'] = 'World';
# 修改属性
同上
# 删除属性  delete命令只能删除对象本身的属性，无法删除继承的属性
delete obj.foo
# 查看是否具有属性
'p' in obj 
obj.hasOwnProperty('toString') # 只查看自身具有的属性
# 遍历属性
var obj = {a: 1, b: 2, c: 3};
for (var i in obj) {
  console.log('键名：', i);
  console.log('键值：', obj[i]);
}
# 它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。
# 它不仅遍历对象自身的属性，还遍历继承的属性。
```

## 函数

**声明**

```javascript
# JavaScript 有三种声明函数的方法。
# 1. function关键字
function print(s) {
  console.log(s);
}
var print = function(s) { # 把匿名函数赋值给一个变量
  console.log(s);
};
# 2. Function构造器（几乎没人用）
```

**函数的属性和方法**

```javascript
# 函数的name属性返回函数的名字。
# 函数的length属性返回函数所需参数个数。
# 函数的toString方法返回一个字符串，内容是函数的源码。
```

**函数的作用域**

作用域分为：全局作用于、局部作用域

函数可以层层递进，寻找它需要的变量

```javascript
var n = 999;
function f1() {
    return function () {
        return function () {
            console.log(n);
        }
    }
}
var f = f1()();
f();
```

**闭包**

函数内部可以访问函数外部的变量，反过来则不行。如果我们非要从函数外部读取函数内部的数据呢，那要怎么实现？这就要使用闭包了，闭包就是能够读取其他函数内部变量的函数，在JS中可以把闭包简单理解成“定义在一个函数内部的函数”，原理就是通过函数A的函数B来操作函数A中的变量。

```javascript
function A() {
    var name = "黄大仁";

    function B() {
        console.log(name);
    }

    return B;
}
```

闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中。

```java
function createIncrementor(start) {
    return function () {
        return ++start;
    };
}

var inc = createIncrementor(5);
console.log(inc()); // 6
console.log(inc()); // 7

var inc2 = createIncrementor(10);
console.log(inc2()); // 11
```

上面代码中，`start`是函数`createIncrementor`的内部变量。通过闭包，`start`的状态被保留了，每一次调用都是在上一次调用的基础上进行计算。从中可以看到，闭包`inc`使得函数`createIncrementor`的内部环境，一直存在。为什么会这样呢？原因就在于`inc`始终在内存中，而`inc`的存在依赖于`createIncrementor`，因此也始终在内存中，不会在调用结束后，被垃圾回收机制回收。

闭包的另一个用处，是封装对象的私有属性和私有方法。

```java
function Person(name) {
  var _age;
  function setAge(n) {
    _age = n;
  }
  function getAge() {
    return _age;
  }

  return {
    name: name,
    getAge: getAge,
    setAge: setAge
  };
}

var p1 = Person('张三');
p1.setAge(25);
p1.getAge() // 25
```

## 面向对象编程

### 构造函数

JS中使用构造函数来作为创建对象的模板。构造函数顾名思义就是一个函数，不过它有自己的特征和用法。

```javascript
function Vehicle () {
  'use strict'; # 使用严格模式，避免没有使用new 关键字调用构造函数
  this.price = 1000;
};
# 或者
function Fubar(foo, bar) {
  if (!(this instanceof Fubar)) {
    return new Fubar(foo, bar);
  }
  this._foo = foo;
  this._bar = bar;
}
```

上面代码中，`Vehicle`就是构造函数。为了与普通函数区别，构造函数名字的第一个字母通常大写。

构造函数的特点有两个。

-   函数体内部使用了`this`关键字，代表了所要生成的对象实例。
-   生成对象的时候，必须使用`new`命令。

### new关键字

`new`命令的作用，就是执行构造函数，返回一个实例对象。

使用`new`命令时，它后面的函数依次执行下面的步骤。

1.  创建一个空对象，作为将要返回的对象实例。
2.  将这个空对象的原型，指向构造函数的`prototype`属性。
3.  将这个空对象赋值给函数内部的`this`关键字。
4.  开始执行构造函数内部的代码。

也就是说，构造函数内部，`this`指的是一个新生成的空对象，所有针对`this`的操作，都会发生在这个空对象上。构造函数之所以叫“构造函数”，就是说这个函数的目的，就是操作一个空对象（即`this`对象），将其“构造”为需要的样子。

```javascript
function Person(name) {
    'use strict';
    this.name = name;
    var _age;
    
    // getter
    this.getAge = function () {
        return _age;
    };
    
    // setter
    this.setAge = function (age) {
        if (age >= 120) {
            console.log("too damn old !")
        } else if (age < 0) {
            console.log("r u fucking kidding me ?")
        } else {
            _age = age;
        }
    };

}
```

### this关键字

```javascript
var obj = { foo:  5 };
```

上面的代码将一个对象赋值给变量`obj`。JavaScript 引擎会先在内存里面，生成一个对象`{ foo: 5 }`，然后把这个对象的内存地址赋值给变量`obj`。也就是说，变量`obj`是一个地址（reference）。后面如果要读取`obj.foo`，引擎先从`obj`拿到内存地址，然后再从该地址读出原始的对象，返回它的`foo`属性。

原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。举例来说，上面例子的`foo`属性，实际上是以下面的形式保存的。

```
{
  foo: {
    [[value]]: 5
    [[writable]]: true
    [[enumerable]]: true
    [[configurable]]: true
  }
}
```

注意，`foo`属性的值保存在属性描述对象的`value`属性里面。

这样的结构是很清晰的，问题在于属性的值可能是一个函数。

```javascript
var obj = { foo: function () {} };
```

这时，引擎会将函数单独保存在内存中，然后再将函数的地址赋值给`foo`属性的`value`属性。

```javascript
{
  foo: {
    [[value]]: 函数的地址
    ...
  }
}
```

由于函数是一个单独的值，所以它可以在不同的环境（上下文）执行。

```javascript
var f = function () {};
var obj = { f: f };

// 单独执行
f()

// obj 环境执行
obj.f()
```

JavaScript 允许在函数体内部，引用当前环境的其他变量。

```javascript
var f = function () {
  console.log(x);
};
```

上面代码中，函数体里面使用了变量`x`。该变量由运行环境提供。

现在问题就来了，由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，`this`就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。

```javascript
function sayHi() {
    if (this.name != null) {
        console.log("Hello I am " + this.name);
    }else{
        console.log("Hello");
    }
}

var tom = {
    name: "tom",
    sayHi: sayHi
};

sayHi();
tom.sayHi();
```

