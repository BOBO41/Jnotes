# 对象

简单说，对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。

对象的创建有三种方法。对象直接量、构造函数、ES5的Object.create()。

## 对象直接量

```javascript
var obj = {
    "name": "hdr",
    "sayHi": function () {
        console.log("Hello World");
    },
    get age(){ // getter
        return this.age;},
    set age(age){ // setter
        this.age = age;}
};
```

对象直接量是一个表达式，每次执行该表达式都会创建并初始化一个新的对象。

## 构造函数

```javascript
function Person (name) {
  'use strict'; # 使用严格模式，避免没有使用new 关键字调用构造函数
  this.name = name;
};

var p = new Person("hdr");
```

## Object.create()

ES5定义了一个名为Object.create()的方法，用于创建一个新对象。该方法有两个重载。

```typescript
create(o: object | null): any;
create(o: object | null, properties: PropertyDescriptorMap & ThisType<any>): any;
```

第一个参数是提供一个**原型对象**。第二个参数设置属性的特性。

### 原型对象

函数具有一个`prototype`属性，对象具有一个`__proto__`属性，这两个属性指向一个对象，这个对象就是原型对象。

```javascript
typeof Object.prototype; // object
typeof {}.__proto__; // object
```

原型对象的意义：原型对象的属性和方法会被共享。

```javascript
function Animal() {
    this.name = "animal";
    this.sayHi = function () {
        console.log("hello world");
    }
}

function Dog() {}

Dog.prototype = new Animal(); // 修改原型对象，让Dog具有Animal对象的属性和方法
Dog.prototype = new Animal(); // 所有 new Dog()创建的对象，原型对象都是Animal对象。
// dog.__proto__ = new Animal(); 只有该Dog对象的原型是Animal对象。
var dog = new Dog();
console.log(dog.name);
dog.sayHi();
```

### 属性的特性

从ES5开始，对属性进行了抽象，提供了一个PropertyDescriptor对象(属性描述符)。它有4个属性，分别是值、可写性、可枚举性、可配置性。

```typescript
interface PropertyDescriptor {
    configurable?: boolean;
    enumerable?: boolean;
    value?: any;
    writable?: boolean;
    get?(): any;
    set?(v: any): void;
}
```

通过调用`Object.getOwnPropertyDescriptor()`可以获取某个对象特定属性的属性描述符。

```javascript
var obj = {"name": "hdr"};
Object.getOwnPropertyDescriptor(obj,"name");
// {value: hdr, writable: true, enumerable: true, configurable: true}
// 让属性不可修改
Object.defineProperty(obj,"age",
                      {value: 22, writable: false, enumerable: true, configurable: true});
obj.age = 18; // 操作失败
```

# 函数

## 定义一个函数

```javascript
var f = function(){console.log("hello world")};
// -----------------------------------------------------
function printProps(o){
    for(var p in o) colose.log(p + " : " + o[p])
}
// -----------------------------------------------------
function hypotenuse(a,b){
    function square(x) {return x*x ;}
    return Math.sqrt(square(a) + square(b))
}
```



## 闭包

闭包就是能够读取其他函数内部变量的函数，在JS中可以把闭包简单理解成“定义在一个函数内部的函数”，通过函数A中的函数B来操作函数A中的变量。

```javascript
function createIncrementor(start) {
    var counter = function () {
        return ++start;
    };
    return counter;
}

var inc = createIncrementor(5);
console.log(inc()); // 6
console.log(inc()); // 7

var inc2 = createIncrementor(10);
console.log(inc2()); // 11

function counter(){
    var n = 0;
    return {
        count : function(){return n++},
        reset : function(){n = 0}
    }
}
```

**理解闭包所需的两个关键点**

- 函数定义时的作用域链到函数执行时依然有效。
- 每次调用JS函数的时候，都会为之创建一个新的对象用来保存局部变量，在闭包作用下，该对象因为被引用，所以不会被垃圾回收，所以能存活下来。

